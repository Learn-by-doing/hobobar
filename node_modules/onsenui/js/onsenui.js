/*! onsenui v2.1.0 - 2017-02-01 */
if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


/*!

Copyright (C) 2014-2016 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

if ('customElements' in window) {
  window.customElements.define = undefined;
}

(function(window){'use strict';

  // DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK
  // THIS IS A PROJECT BASED ON A BUILD SYSTEM
  // THIS FILE IS JUST WRAPPED UP RESULTING IN
  // build/document-register-element.js
  // and its .max.js counter part

  var
    document = window.document,
    Object = window.Object
  ;

  var htmlClass = (function (info) {
    // (C) Andrea Giammarchi - @WebReflection - MIT Style
    var
      catchClass = /^[A-Z]+[a-z]/,
      filterBy = function (re) {
        var arr = [], tag;
        for (tag in register) {
          if (re.test(tag)) arr.push(tag);
        }
        return arr;
      },
      add = function (Class, tag) {
        tag = tag.toLowerCase();
        if (!(tag in register)) {
          register[Class] = (register[Class] || []).concat(tag);
          register[tag] = (register[tag.toUpperCase()] = Class);
        }
      },
      register = (Object.create || Object)(null),
      htmlClass = {},
      i, section, tags, Class
    ;
    for (section in info) {
      for (Class in info[section]) {
        tags = info[section][Class];
        register[Class] = tags;
        for (i = 0; i < tags.length; i++) {
          register[tags[i].toLowerCase()] =
          register[tags[i].toUpperCase()] = Class;
        }
      }
    }
    htmlClass.get = function get(tagOrClass) {
      return typeof tagOrClass === 'string' ?
        (register[tagOrClass] || (catchClass.test(tagOrClass) ? [] : '')) :
        filterBy(tagOrClass);
    };
    htmlClass.set = function set(tag, Class) {
      return (catchClass.test(tag) ?
        add(tag, Class) :
        add(Class, tag)
      ), htmlClass;
    };
    return htmlClass;
  }({
    "collections": {
      "HTMLAllCollection": [
        "all"
      ],
      "HTMLCollection": [
        "forms"
      ],
      "HTMLFormControlsCollection": [
        "elements"
      ],
      "HTMLOptionsCollection": [
        "options"
      ]
    },
    "elements": {
      "Element": [
        "element"
      ],
      "HTMLAnchorElement": [
        "a"
      ],
      "HTMLAppletElement": [
        "applet"
      ],
      "HTMLAreaElement": [
        "area"
      ],
      "HTMLAttachmentElement": [
        "attachment"
      ],
      "HTMLAudioElement": [
        "audio"
      ],
      "HTMLBRElement": [
        "br"
      ],
      "HTMLBaseElement": [
        "base"
      ],
      "HTMLBodyElement": [
        "body"
      ],
      "HTMLButtonElement": [
        "button"
      ],
      "HTMLCanvasElement": [
        "canvas"
      ],
      "HTMLContentElement": [
        "content"
      ],
      "HTMLDListElement": [
        "dl"
      ],
      "HTMLDataElement": [
        "data"
      ],
      "HTMLDataListElement": [
        "datalist"
      ],
      "HTMLDetailsElement": [
        "details"
      ],
      "HTMLDialogElement": [
        "dialog"
      ],
      "HTMLDirectoryElement": [
        "dir"
      ],
      "HTMLDivElement": [
        "div"
      ],
      "HTMLDocument": [
        "document"
      ],
      "HTMLElement": [
        "element",
        "abbr",
        "address",
        "article",
        "aside",
        "b",
        "bdi",
        "bdo",
        "cite",
        "code",
        "command",
        "dd",
        "dfn",
        "dt",
        "em",
        "figcaption",
        "figure",
        "footer",
        "header",
        "i",
        "kbd",
        "mark",
        "nav",
        "noscript",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "small",
        "strong",
        "sub",
        "summary",
        "sup",
        "u",
        "var",
        "wbr"
      ],
      "HTMLEmbedElement": [
        "embed"
      ],
      "HTMLFieldSetElement": [
        "fieldset"
      ],
      "HTMLFontElement": [
        "font"
      ],
      "HTMLFormElement": [
        "form"
      ],
      "HTMLFrameElement": [
        "frame"
      ],
      "HTMLFrameSetElement": [
        "frameset"
      ],
      "HTMLHRElement": [
        "hr"
      ],
      "HTMLHeadElement": [
        "head"
      ],
      "HTMLHeadingElement": [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ],
      "HTMLHtmlElement": [
        "html"
      ],
      "HTMLIFrameElement": [
        "iframe"
      ],
      "HTMLImageElement": [
        "img"
      ],
      "HTMLInputElement": [
        "input"
      ],
      "HTMLKeygenElement": [
        "keygen"
      ],
      "HTMLLIElement": [
        "li"
      ],
      "HTMLLabelElement": [
        "label"
      ],
      "HTMLLegendElement": [
        "legend"
      ],
      "HTMLLinkElement": [
        "link"
      ],
      "HTMLMapElement": [
        "map"
      ],
      "HTMLMarqueeElement": [
        "marquee"
      ],
      "HTMLMediaElement": [
        "media"
      ],
      "HTMLMenuElement": [
        "menu"
      ],
      "HTMLMenuItemElement": [
        "menuitem"
      ],
      "HTMLMetaElement": [
        "meta"
      ],
      "HTMLMeterElement": [
        "meter"
      ],
      "HTMLModElement": [
        "del",
        "ins"
      ],
      "HTMLOListElement": [
        "ol"
      ],
      "HTMLObjectElement": [
        "object"
      ],
      "HTMLOptGroupElement": [
        "optgroup"
      ],
      "HTMLOptionElement": [
        "option"
      ],
      "HTMLOutputElement": [
        "output"
      ],
      "HTMLParagraphElement": [
        "p"
      ],
      "HTMLParamElement": [
        "param"
      ],
      "HTMLPictureElement": [
        "picture"
      ],
      "HTMLPreElement": [
        "pre"
      ],
      "HTMLProgressElement": [
        "progress"
      ],
      "HTMLQuoteElement": [
        "blockquote",
        "q",
        "quote"
      ],
      "HTMLScriptElement": [
        "script"
      ],
      "HTMLSelectElement": [
        "select"
      ],
      "HTMLShadowElement": [
        "shadow"
      ],
      "HTMLSlotElement": [
        "slot"
      ],
      "HTMLSourceElement": [
        "source"
      ],
      "HTMLSpanElement": [
        "span"
      ],
      "HTMLStyleElement": [
        "style"
      ],
      "HTMLTableCaptionElement": [
        "caption"
      ],
      "HTMLTableCellElement": [
        "td",
        "th"
      ],
      "HTMLTableColElement": [
        "col",
        "colgroup"
      ],
      "HTMLTableElement": [
        "table"
      ],
      "HTMLTableRowElement": [
        "tr"
      ],
      "HTMLTableSectionElement": [
        "thead",
        "tbody",
        "tfoot"
      ],
      "HTMLTemplateElement": [
        "template"
      ],
      "HTMLTextAreaElement": [
        "textarea"
      ],
      "HTMLTimeElement": [
        "time"
      ],
      "HTMLTitleElement": [
        "title"
      ],
      "HTMLTrackElement": [
        "track"
      ],
      "HTMLUListElement": [
        "ul"
      ],
      "HTMLUnknownElement": [
        "unknown",
        "vhgroupv",
        "vkeygen"
      ],
      "HTMLVideoElement": [
        "video"
      ]
    },
    "nodes": {
      "Attr": [
        "node"
      ],
      "Audio": [
        "audio"
      ],
      "CDATASection": [
        "node"
      ],
      "CharacterData": [
        "node"
      ],
      "Comment": [
        "#comment"
      ],
      "Document": [
        "#document"
      ],
      "DocumentFragment": [
        "#document-fragment"
      ],
      "DocumentType": [
        "node"
      ],
      "HTMLDocument": [
        "#document"
      ],
      "Image": [
        "img"
      ],
      "Option": [
        "option"
      ],
      "ProcessingInstruction": [
        "node"
      ],
      "ShadowRoot": [
        "#shadow-root"
      ],
      "Text": [
        "#text"
      ],
      "XMLDocument": [
        "xml"
      ]
    }
  }));
  
  
    var
    // V0 polyfill entry
    REGISTER_ELEMENT = 'registerElement',
  
    // IE < 11 only + old WebKit for attributes + feature detection
    EXPANDO_UID = '__' + REGISTER_ELEMENT + (window.Math.random() * 10e4 >> 0),
  
    // shortcuts and costants
    ADD_EVENT_LISTENER = 'addEventListener',
    ATTACHED = 'attached',
    CALLBACK = 'Callback',
    DETACHED = 'detached',
    EXTENDS = 'extends',
  
    ATTRIBUTE_CHANGED_CALLBACK = 'attributeChanged' + CALLBACK,
    ATTACHED_CALLBACK = ATTACHED + CALLBACK,
    CONNECTED_CALLBACK = 'connected' + CALLBACK,
    DISCONNECTED_CALLBACK = 'disconnected' + CALLBACK,
    CREATED_CALLBACK = 'created' + CALLBACK,
    DETACHED_CALLBACK = DETACHED + CALLBACK,
  
    ADDITION = 'ADDITION',
    MODIFICATION = 'MODIFICATION',
    REMOVAL = 'REMOVAL',
  
    DOM_ATTR_MODIFIED = 'DOMAttrModified',
    DOM_CONTENT_LOADED = 'DOMContentLoaded',
    DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',
  
    PREFIX_TAG = '<',
    PREFIX_IS = '=',
  
    // valid and invalid node names
    validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
    invalidNames = [
      'ANNOTATION-XML',
      'COLOR-PROFILE',
      'FONT-FACE',
      'FONT-FACE-SRC',
      'FONT-FACE-URI',
      'FONT-FACE-FORMAT',
      'FONT-FACE-NAME',
      'MISSING-GLYPH'
    ],
  
    // registered types and their prototypes
    types = [],
    protos = [],
  
    // to query subnodes
    query = '',
  
    // html shortcut used to feature detect
    documentElement = document.documentElement,
  
    // ES5 inline helpers || basic patches
    indexOf = types.indexOf || function (v) {
      for(var i = this.length; i-- && this[i] !== v;){}
      return i;
    },
  
    // other helpers / shortcuts
    OP = Object.prototype,
    hOP = OP.hasOwnProperty,
    iPO = OP.isPrototypeOf,
  
    defineProperty = Object.defineProperty,
    empty = [],
    gOPD = Object.getOwnPropertyDescriptor,
    gOPN = Object.getOwnPropertyNames,
    gPO = Object.getPrototypeOf,
    sPO = Object.setPrototypeOf,
  
    // jshint proto: true
    hasProto = !!Object.__proto__,
  
    // V1 helpers
    fixGetClass = false,
    DRECEV1 = '__dreCEv1',
    customElements = window.customElements,
    usableCustomElements = !!(
      customElements &&
      customElements.define &&
      customElements.get &&
      customElements.whenDefined
    ),
    Dict = Object.create || Object,
    Map = window.Map || function Map() {
      var K = [], V = [], i;
      return {
        get: function (k) {
          return V[indexOf.call(K, k)];
        },
        set: function (k, v) {
          i = indexOf.call(K, k);
          if (i < 0) V[K.push(k) - 1] = v;
          else V[i] = v;
        }
      };
    },
    Promise = window.Promise || function (fn) {
      var
        notify = [],
        done = false,
        p = {
          'catch': function () {
            return p;
          },
          'then': function (cb) {
            notify.push(cb);
            if (done) setTimeout(resolve, 1);
            return p;
          }
        }
      ;
      function resolve(value) {
        done = true;
        while (notify.length) notify.shift()(value);
      }
      fn(resolve);
      return p;
    },
    justCreated = false,
    constructors = Dict(null),
    waitingList = Dict(null),
    nodeNames = new Map(),
    secondArgument = String,
  
    // used to create unique instances
    create = Object.create || function Bridge(proto) {
      // silly broken polyfill probably ever used but short enough to work
      return proto ? ((Bridge.prototype = proto), new Bridge()) : this;
    },
  
    // will set the prototype if possible
    // or copy over all properties
    setPrototype = sPO || (
      hasProto ?
        function (o, p) {
          o.__proto__ = p;
          return o;
        } : (
      (gOPN && gOPD) ?
        (function(){
          function setProperties(o, p) {
            for (var
              key,
              names = gOPN(p),
              i = 0, length = names.length;
              i < length; i++
            ) {
              key = names[i];
              if (!hOP.call(o, key)) {
                defineProperty(o, key, gOPD(p, key));
              }
            }
          }
          return function (o, p) {
            do {
              setProperties(o, p);
            } while ((p = gPO(p)) && !iPO.call(p, o));
            return o;
          };
        }()) :
        function (o, p) {
          for (var key in p) {
            o[key] = p[key];
          }
          return o;
        }
    )),
  
    // DOM shortcuts and helpers, if any
  
    MutationObserver = window.MutationObserver ||
                       window.WebKitMutationObserver,
  
    HTMLElementPrototype = (
      window.HTMLElement ||
      window.Element ||
      window.Node
    ).prototype,
  
    IE8 = !iPO.call(HTMLElementPrototype, documentElement),
  
    safeProperty = IE8 ? function (o, k, d) {
      o[k] = d.value;
      return o;
    } : defineProperty,
  
    isValidNode = IE8 ?
      function (node) {
        return node.nodeType === 1;
      } :
      function (node) {
        return iPO.call(HTMLElementPrototype, node);
      },
  
    targets = IE8 && [],
  
    attachShadow = HTMLElementPrototype.attachShadow,
    cloneNode = HTMLElementPrototype.cloneNode,
    dispatchEvent = HTMLElementPrototype.dispatchEvent,
    getAttribute = HTMLElementPrototype.getAttribute,
    hasAttribute = HTMLElementPrototype.hasAttribute,
    removeAttribute = HTMLElementPrototype.removeAttribute,
    setAttribute = HTMLElementPrototype.setAttribute,
  
    // replaced later on
    createElement = document.createElement,
    patchedCreateElement = createElement,
  
    // shared observer for all attributes
    attributesObserver = MutationObserver && {
      attributes: true,
      characterData: true,
      attributeOldValue: true
    },
  
    // useful to detect only if there's no MutationObserver
    DOMAttrModified = MutationObserver || function(e) {
      doesNotSupportDOMAttrModified = false;
      documentElement.removeEventListener(
        DOM_ATTR_MODIFIED,
        DOMAttrModified
      );
    },
  
    // will both be used to make DOMNodeInserted asynchronous
    asapQueue,
    asapTimer = 0,
  
    // internal flags
    setListener = false,
    doesNotSupportDOMAttrModified = true,
    dropDomContentLoaded = true,
  
    // needed for the innerHTML helper
    notFromInnerHTMLHelper = true,
  
    // optionally defined later on
    onSubtreeModified,
    callDOMAttrModified,
    getAttributesMirror,
    observer,
    observe,
  
    // based on setting prototype capability
    // will check proto or the expando attribute
    // in order to setup the node once
    patchIfNotAlready,
    patch
  ;
  
  // only if needed
  if (!(REGISTER_ELEMENT in document)) {
  
    if (sPO || hasProto) {
        patchIfNotAlready = function (node, proto) {
          if (!iPO.call(proto, node)) {
            setupNode(node, proto);
          }
        };
        patch = setupNode;
    } else {
        patchIfNotAlready = function (node, proto) {
          if (!node[EXPANDO_UID]) {
            node[EXPANDO_UID] = Object(true);
            setupNode(node, proto);
          }
        };
        patch = patchIfNotAlready;
    }
  
    if (IE8) {
      doesNotSupportDOMAttrModified = false;
      (function (){
        var
          descriptor = gOPD(HTMLElementPrototype, ADD_EVENT_LISTENER),
          addEventListener = descriptor.value,
          patchedRemoveAttribute = function (name) {
            var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
            e.attrName = name;
            e.prevValue = getAttribute.call(this, name);
            e.newValue = null;
            e[REMOVAL] = e.attrChange = 2;
            removeAttribute.call(this, name);
            dispatchEvent.call(this, e);
          },
          patchedSetAttribute = function (name, value) {
            var
              had = hasAttribute.call(this, name),
              old = had && getAttribute.call(this, name),
              e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})
            ;
            setAttribute.call(this, name, value);
            e.attrName = name;
            e.prevValue = had ? old : null;
            e.newValue = value;
            if (had) {
              e[MODIFICATION] = e.attrChange = 1;
            } else {
              e[ADDITION] = e.attrChange = 0;
            }
            dispatchEvent.call(this, e);
          },
          onPropertyChange = function (e) {
            // jshint eqnull:true
            var
              node = e.currentTarget,
              superSecret = node[EXPANDO_UID],
              propertyName = e.propertyName,
              event
            ;
            if (superSecret.hasOwnProperty(propertyName)) {
              superSecret = superSecret[propertyName];
              event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
              event.attrName = superSecret.name;
              event.prevValue = superSecret.value || null;
              event.newValue = (superSecret.value = node[propertyName] || null);
              if (event.prevValue == null) {
                event[ADDITION] = event.attrChange = 0;
              } else {
                event[MODIFICATION] = event.attrChange = 1;
              }
              dispatchEvent.call(node, event);
            }
          }
        ;
        descriptor.value = function (type, handler, capture) {
          if (
            type === DOM_ATTR_MODIFIED &&
            this[ATTRIBUTE_CHANGED_CALLBACK] &&
            this.setAttribute !== patchedSetAttribute
          ) {
            this[EXPANDO_UID] = {
              className: {
                name: 'class',
                value: this.className
              }
            };
            this.setAttribute = patchedSetAttribute;
            this.removeAttribute = patchedRemoveAttribute;
            addEventListener.call(this, 'propertychange', onPropertyChange);
          }
          addEventListener.call(this, type, handler, capture);
        };
        defineProperty(HTMLElementPrototype, ADD_EVENT_LISTENER, descriptor);
      }());
    } else if (!MutationObserver) {
      documentElement[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, DOMAttrModified);
      documentElement.setAttribute(EXPANDO_UID, 1);
      documentElement.removeAttribute(EXPANDO_UID);
      if (doesNotSupportDOMAttrModified) {
        onSubtreeModified = function (e) {
          var
            node = this,
            oldAttributes,
            newAttributes,
            key
          ;
          if (node === e.target) {
            oldAttributes = node[EXPANDO_UID];
            node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));
            for (key in newAttributes) {
              if (!(key in oldAttributes)) {
                // attribute was added
                return callDOMAttrModified(
                  0,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  ADDITION
                );
              } else if (newAttributes[key] !== oldAttributes[key]) {
                // attribute was changed
                return callDOMAttrModified(
                  1,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  MODIFICATION
                );
              }
            }
            // checking if it has been removed
            for (key in oldAttributes) {
              if (!(key in newAttributes)) {
                // attribute removed
                return callDOMAttrModified(
                  2,
                  node,
                  key,
                  oldAttributes[key],
                  newAttributes[key],
                  REMOVAL
                );
              }
            }
          }
        };
        callDOMAttrModified = function (
          attrChange,
          currentTarget,
          attrName,
          prevValue,
          newValue,
          action
        ) {
          var e = {
            attrChange: attrChange,
            currentTarget: currentTarget,
            attrName: attrName,
            prevValue: prevValue,
            newValue: newValue
          };
          e[action] = attrChange;
          onDOMAttrModified(e);
        };
        getAttributesMirror = function (node) {
          for (var
            attr, name,
            result = {},
            attributes = node.attributes,
            i = 0, length = attributes.length;
            i < length; i++
          ) {
            attr = attributes[i];
            name = attr.name;
            if (name !== 'setAttribute') {
              result[name] = attr.value;
            }
          }
          return result;
        };
      }
    }
  
    // set as enumerable, writable and configurable
    document[REGISTER_ELEMENT] = function registerElement(type, options) {
      upperType = type.toUpperCase();
      if (!setListener) {
        // only first time document.registerElement is used
        // we need to set this listener
        // setting it by default might slow down for no reason
        setListener = true;
        if (MutationObserver) {
          observer = (function(attached, detached){
            function checkEmAll(list, callback) {
              for (var i = 0, length = list.length; i < length; callback(list[i++])){}
            }
            return new MutationObserver(function (records) {
              for (var
                current, node, newValue,
                i = 0, length = records.length; i < length; i++
              ) {
                current = records[i];
                if (current.type === 'childList') {
                  checkEmAll(current.addedNodes, attached);
                  checkEmAll(current.removedNodes, detached);
                } else {
                  node = current.target;
                  if (notFromInnerHTMLHelper &&
                      node[ATTRIBUTE_CHANGED_CALLBACK] &&
                      current.attributeName !== 'style') {
                    newValue = getAttribute.call(node, current.attributeName);
                    if (newValue !== current.oldValue) {
                      node[ATTRIBUTE_CHANGED_CALLBACK](
                        current.attributeName,
                        current.oldValue,
                        newValue
                      );
                    }
                  }
                }
              }
            });
          }(executeAction(ATTACHED), executeAction(DETACHED)));
          observe = function (node) {
            observer.observe(
              node,
              {
                childList: true,
                subtree: true
              }
            );
            return node;
          };
          observe(document);
          if (attachShadow) {
            HTMLElementPrototype.attachShadow = function () {
              return observe(attachShadow.apply(this, arguments));
            };
          }
        } else {
          asapQueue = [];
          document[ADD_EVENT_LISTENER]('DOMNodeInserted', onDOMNode(ATTACHED));
          document[ADD_EVENT_LISTENER]('DOMNodeRemoved', onDOMNode(DETACHED));
        }
  
        document[ADD_EVENT_LISTENER](DOM_CONTENT_LOADED, onReadyStateChange);
        document[ADD_EVENT_LISTENER]('readystatechange', onReadyStateChange);
  
        HTMLElementPrototype.cloneNode = function (deep) {
          var
            node = cloneNode.call(this, !!deep),
            i = getTypeIndex(node)
          ;
          if (-1 < i) patch(node, protos[i]);
          if (deep) loopAndSetup(node.querySelectorAll(query));
          return node;
        };
      }
  
      if (-2 < (
        indexOf.call(types, PREFIX_IS + upperType) +
        indexOf.call(types, PREFIX_TAG + upperType)
      )) {
        throwTypeError(type);
      }
  
      if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {
        throw new Error('The type ' + type + ' is invalid');
      }
  
      var
        constructor = function () {
          return extending ?
            document.createElement(nodeName, upperType) :
            document.createElement(nodeName);
        },
        opt = options || OP,
        extending = hOP.call(opt, EXTENDS),
        nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,
        upperType,
        i
      ;
  
      if (extending && -1 < (
        indexOf.call(types, PREFIX_TAG + nodeName)
      )) {
        throwTypeError(nodeName);
      }
  
      i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;
  
      query = query.concat(
        query.length ? ',' : '',
        extending ? nodeName + '[is="' + type.toLowerCase() + '"]' : nodeName
      );
  
      constructor.prototype = (
        protos[i] = hOP.call(opt, 'prototype') ?
          opt.prototype :
          create(HTMLElementPrototype)
      );
  
      loopAndVerify(
        document.querySelectorAll(query),
        ATTACHED
      );
  
      return constructor;
    };
  
    document.createElement = (patchedCreateElement = function (localName, typeExtension) {
      var
        is = getIs(typeExtension),
        node = is ?
          createElement.call(document, localName, secondArgument(is)) :
          createElement.call(document, localName),
        name = '' + localName,
        i = indexOf.call(
          types,
          (is ? PREFIX_IS : PREFIX_TAG) +
          (is || name).toUpperCase()
        ),
        setup = -1 < i
      ;
      if (is) {
        node.setAttribute('is', is = is.toLowerCase());
        if (setup) {
          setup = isInQSA(name.toUpperCase(), is);
        }
      }
      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;
      if (setup) patch(node, protos[i]);
      return node;
    });
  
  }
  
  function ASAP() {
    var queue = asapQueue.splice(0, asapQueue.length);
    asapTimer = 0;
    while (queue.length) {
      queue.shift().call(
        null, queue.shift()
      );
    }
  }
  
  function loopAndVerify(list, action) {
    for (var i = 0, length = list.length; i < length; i++) {
      verifyAndSetupAndAction(list[i], action);
    }
  }
  
  function loopAndSetup(list) {
    for (var i = 0, length = list.length, node; i < length; i++) {
      node = list[i];
      patch(node, protos[getTypeIndex(node)]);
    }
  }
  
  function executeAction(action) {
    return function (node) {
      if (isValidNode(node)) {
        verifyAndSetupAndAction(node, action);
        loopAndVerify(
          node.querySelectorAll(query),
          action
        );
      }
    };
  }
  
  function getTypeIndex(target) {
    var
      is = getAttribute.call(target, 'is'),
      nodeName = target.nodeName.toUpperCase(),
      i = indexOf.call(
        types,
        is ?
            PREFIX_IS + is.toUpperCase() :
            PREFIX_TAG + nodeName
      )
    ;
    return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;
  }
  
  function isInQSA(name, type) {
    return -1 < query.indexOf(name + '[is="' + type + '"]');
  }
  
  function onDOMAttrModified(e) {
    var
      node = e.currentTarget,
      attrChange = e.attrChange,
      attrName = e.attrName,
      target = e.target,
      addition = e[ADDITION] || 2,
      removal = e[REMOVAL] || 3
    ;
    if (notFromInnerHTMLHelper &&
        (!target || target === node) &&
        node[ATTRIBUTE_CHANGED_CALLBACK] &&
        attrName !== 'style' && (
          e.prevValue !== e.newValue ||
          // IE9, IE10, and Opera 12 gotcha
          e.newValue === '' && (
            attrChange === addition ||
            attrChange === removal
          )
    )) {
      node[ATTRIBUTE_CHANGED_CALLBACK](
        attrName,
        attrChange === addition ? null : e.prevValue,
        attrChange === removal ? null : e.newValue
      );
    }
  }
  
  function onDOMNode(action) {
    var executor = executeAction(action);
    return function (e) {
      asapQueue.push(executor, e.target);
      if (asapTimer) clearTimeout(asapTimer);
      asapTimer = setTimeout(ASAP, 1);
    };
  }
  
  function onReadyStateChange(e) {
    if (dropDomContentLoaded) {
      dropDomContentLoaded = false;
      e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
    }
    loopAndVerify(
      (e.target || document).querySelectorAll(query),
      e.detail === DETACHED ? DETACHED : ATTACHED
    );
    if (IE8) purge();
  }
  
  function patchedSetAttribute(name, value) {
    // jshint validthis:true
    var self = this;
    setAttribute.call(self, name, value);
    onSubtreeModified.call(self, {target: self});
  }
  
  function setupNode(node, proto) {
    setPrototype(node, proto);
    if (observer) {
      observer.observe(node, attributesObserver);
    } else {
      if (doesNotSupportDOMAttrModified) {
        node.setAttribute = patchedSetAttribute;
        node[EXPANDO_UID] = getAttributesMirror(node);
        node[ADD_EVENT_LISTENER](DOM_SUBTREE_MODIFIED, onSubtreeModified);
      }
      node[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, onDOMAttrModified);
    }
    if (node[CREATED_CALLBACK] && notFromInnerHTMLHelper) {
      node.created = true;
      node[CREATED_CALLBACK]();
      node.created = false;
    }
  }
  
  function purge() {
    for (var
      node,
      i = 0,
      length = targets.length;
      i < length; i++
    ) {
      node = targets[i];
      if (!documentElement.contains(node)) {
        length--;
        targets.splice(i--, 1);
        verifyAndSetupAndAction(node, DETACHED);
      }
    }
  }
  
  function throwTypeError(type) {
    throw new Error('A ' + type + ' type is already registered');
  }
  
  function verifyAndSetupAndAction(node, action) {
    var
      fn,
      i = getTypeIndex(node)
    ;
    if (-1 < i) {
      patchIfNotAlready(node, protos[i]);
      i = 0;
      if (action === ATTACHED && !node[ATTACHED]) {
        node[DETACHED] = false;
        node[ATTACHED] = true;
        i = 1;
        if (IE8 && indexOf.call(targets, node) < 0) {
          targets.push(node);
        }
      } else if (action === DETACHED && !node[DETACHED]) {
        node[ATTACHED] = false;
        node[DETACHED] = true;
        i = 1;
      }
      if (i && (fn = node[action + CALLBACK])) fn.call(node);
    }
  }
  
  
  
  // V1 in da House!
  function CustomElementRegistry() {}
  
  CustomElementRegistry.prototype = {
    constructor: CustomElementRegistry,
    // a workaround for the stubborn WebKit
    define: usableCustomElements ?
      function (name, Class, options) {
        if (options) {
          CERDefine(name, Class, options);
        } else {
          var NAME = name.toUpperCase();
          constructors[NAME] = {
            constructor: Class,
            create: [NAME]
          };
          nodeNames.set(Class, NAME);
          customElements.define(name, Class);
        }
      } :
      CERDefine,
    get: usableCustomElements ?
      function (name) {
        return customElements.get(name) || get(name);
      } :
      get,
    whenDefined: usableCustomElements ?
      function (name) {
        return Promise.race([
          customElements.whenDefined(name),
          whenDefined(name)
        ]);
      } :
      whenDefined
  };
  
  function CERDefine(name, Class, options) {
    var
      is = options && options[EXTENDS] || '',
      CProto = Class.prototype,
      proto = create(CProto),
      attributes = Class.observedAttributes || empty,
      definition = {prototype: proto}
    ;
    // TODO: is this needed at all since it's inherited?
    // defineProperty(proto, 'constructor', {value: Class});
    safeProperty(proto, CREATED_CALLBACK, {
        value: function () {
          if (justCreated) justCreated = false;
          else if (!this[DRECEV1]) {
            this[DRECEV1] = true;
            new Class(this);
            if (CProto[CREATED_CALLBACK])
              CProto[CREATED_CALLBACK].call(this);
            var info = constructors[nodeNames.get(Class)];
            if (!usableCustomElements || info.create.length > 1) {
              notifyAttributes(this);
            }
          }
      }
    });
    safeProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {
      value: function (name) {
        if (-1 < indexOf.call(attributes, name))
          CProto[ATTRIBUTE_CHANGED_CALLBACK].apply(this, arguments);
      }
    });
    if (CProto[CONNECTED_CALLBACK]) {
      safeProperty(proto, ATTACHED_CALLBACK, {
        value: CProto[CONNECTED_CALLBACK]
      });
    }
    if (CProto[DISCONNECTED_CALLBACK]) {
      safeProperty(proto, DETACHED_CALLBACK, {
        value: CProto[DISCONNECTED_CALLBACK]
      });
    }
    if (is) definition[EXTENDS] = is;
    name = name.toUpperCase();
    constructors[name] = {
      constructor: Class,
      create: is ? [is, secondArgument(name)] : [name]
    };
    nodeNames.set(Class, name);
    document[REGISTER_ELEMENT](name.toLowerCase(), definition);
    whenDefined(name);
    waitingList[name].r();
  }
  
  function get(name) {
    var info = constructors[name.toUpperCase()];
    return info && info.constructor;
  }
  
  function getIs(options) {
    return typeof options === 'string' ?
        options : (options && options.is || '');
  }
  
  function notifyAttributes(self) {
    var
      callback = self[ATTRIBUTE_CHANGED_CALLBACK],
      attributes = callback ? self.attributes : empty,
      i = attributes.length,
      attribute
    ;
    while (i--) {
      attribute =  attributes[i]; // || attributes.item(i);
      callback.call(
        self,
        attribute.name || attribute.nodeName,
        null,
        attribute.value || attribute.nodeValue
      );
    }
  }
  
  function whenDefined(name) {
    name = name.toUpperCase();
    if (!(name in waitingList)) {
      waitingList[name] = {};
      waitingList[name].p = new Promise(function (resolve) {
        waitingList[name].r = resolve;
      });
    }
    return waitingList[name].p;
  }
  
  function polyfillV1() {
    if (customElements) delete window.customElements;
    defineProperty(window, 'customElements', {
      configurable: true,
      value: new CustomElementRegistry()
    });
    defineProperty(window, 'CustomElementRegistry', {
      configurable: true,
      value: CustomElementRegistry
    });
    for (var
      patchClass = function (name) {
        var Class = window[name];
        if (Class) {
          window[name] = function CustomElementsV1(self) {
            var info, isNative;
            if (!self) self = this;
            if (!self[DRECEV1]) {
              justCreated = true;
              info = constructors[nodeNames.get(self.constructor)];
              isNative = usableCustomElements && info.create.length === 1;
              self = isNative ?
                Reflect.construct(Class, empty, info.constructor) :
                document.createElement.apply(document, info.create);
              self[DRECEV1] = true;
              justCreated = false;
              if (!isNative) notifyAttributes(self);
            }
            return self;
          };
          window[name].prototype = Class.prototype;
          try {
            Class.prototype.constructor = window[name];
          } catch(WebKit) {
            fixGetClass = true;
            defineProperty(Class, DRECEV1, {value: window[name]});
          }
        }
      },
      Classes = htmlClass.get(/^HTML[A-Z]*[a-z]/),
      i = Classes.length;
      i--;
      patchClass(Classes[i])
    ) {}
    (document.createElement = function (name, options) {
      var is = getIs(options);
      return is ?
        patchedCreateElement.call(this, name, secondArgument(is)) :
        patchedCreateElement.call(this, name);
    });
  }
  
  // if customElements is not there at all
  if (!customElements) polyfillV1();
  else {
    // if available test extends work as expected
    try {
      (function (DRE, options, name) {
        options[EXTENDS] = 'a';
        DRE.prototype = create(HTMLAnchorElement.prototype);
        DRE.prototype.constructor = DRE;
        window.customElements.define(name, DRE, options);
        if (
          getAttribute.call(document.createElement('a', {is: name}), 'is') !== name ||
          (usableCustomElements && getAttribute.call(new DRE(), 'is') !== name)
        ) {
          throw options;
        }
      }(
        function DRE() {
          return Reflect.construct(HTMLAnchorElement, [], DRE);
        },
        {},
        'document-register-element-a'
      ));
    } catch(o_O) {
      // or force the polyfill if not
      // and keep internal original reference
      polyfillV1();
    }
  }
  
  try {
    createElement.call(document, 'a', 'a');
  } catch(FireFox) {
    secondArgument = function (is) {
      return {is: is};
    };
  }
  
}(window));

;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		// Ignore touches on contenteditable elements to prevent conflict with text selection.
		// (For details: https://github.com/ftlabs/fastclick/pull/211 )
		if (targetElement.isContentEditable) {
			return true;
		}

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

// see https://github.com/WebReflection/document-register-element/issues/21#issuecomment-102020311
var innerHTML = (function (document) {

  var
    EXTENDS = 'extends',
    register = document.registerElement,
    div = document.createElement('div'),
    dre = 'document-register-element',
    innerHTML = register.innerHTML,
    initialize,
    registered
  ;

  // avoid duplicated wrappers
  if (innerHTML) return innerHTML;

  try {

    // feature detect the problem
    register.call(
      document,
      dre,
      {prototype: Object.create(
        HTMLElement.prototype,
        {createdCallback: {value: Object}}
      )}
    );

    div.innerHTML = '<' + dre + '></' + dre + '>';

    // if natively supported, nothing to do
    if ('createdCallback' in div.querySelector(dre)) {
      // return just an innerHTML wrap
      return (register.innerHTML = function (el, html) {
        el.innerHTML = html;
        return el;
      });
    }

  } catch(meh) {}

  // in other cases
  registered = [];
  initialize = function (el) {
    if (
      'createdCallback' in el         ||
      'attachedCallback' in el        ||
      'detachedCallback' in el        ||
      'attributeChangedCallback' in el
    ) return;
    document.createElement.innerHTMLHelper = true;
    for (var
      parentNode = el.parentNode,
      type = el.getAttribute('is'),
      name = el.nodeName,
      node = document.createElement.apply(
        document,
        type ? [name, type] : [name]
      ),
      attributes = el.attributes,
      i = 0,
      length = attributes.length,
      attr, fc;
      i < length; i++
    ) {
      attr = attributes[i];
      node.setAttribute(attr.name, attr.value);
    }
    if (node.createdCallback) {
      node.created = true;
      node.createdCallback();
      node.created = false;
    }
    while ((fc = el.firstChild)) node.appendChild(fc);
    document.createElement.innerHTMLHelper = false;
    if (parentNode) parentNode.replaceChild(node, el);
  };
  // augment the document.registerElement method
  return ((document.registerElement = function registerElement(type, options) {
    var name = (options[EXTENDS] ?
      (options[EXTENDS] + '[is="' + type + '"]') : type
    ).toLowerCase();
    if (registered.indexOf(name) < 0) registered.push(name);
    return register.apply(document, arguments);
  }).innerHTML = function (el, html) {
    el.innerHTML = html;
    for (var
      nodes = el.querySelectorAll(registered.join(',')),
      i = nodes.length; i--; initialize(nodes[i])
    ) {}
    return el;
  });
}(document));
/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;

    this._events[event] = this._events[event]
      .filter(function(_fct) {
        if (fct) {
           return fct !== _fct;
        }
        else {
          return false;
        }
      });
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (!window.Promise) {
    window.Promise = Promise;
  }
})(this);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, (function () { 'use strict';

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var unwrap = function unwrap(string) {
  return string.slice(1, -1);
};
var isObjectString = function isObjectString(string) {
  return string.startsWith('{') && string.endsWith('}');
};
var isArrayString = function isArrayString(string) {
  return string.startsWith('[') && string.endsWith(']');
};
var isQuotedString = function isQuotedString(string) {
  return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
};

var error$1 = function error$1(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error$1(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trimLeft();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '\"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error$1(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trimLeft();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error$1(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error$1(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util = {};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util.match(element, query);
  };
};

/**
 * @param {Element} e
 * @param {String/Function} s CSS Selector.
 * @return {Boolean}
 */
util.match = function (e, s) {
  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findChild = function (element, query) {
  var match = util.prepareQuery(query);

  for (var i = 0; i < element.children.length; i++) {
    var node = element.children[i];
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findParent = function (element, query) {
  var match = util.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document) {
      return null;
    }
    if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.isAttached = function (element) {
  while (document.documentElement !== element) {
    if (!element) {
      return false;
    }
    element = element.parentNode;
  }
  return true;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal|ons-sliding-menu|ons-split-view)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  util.extend(element.style, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util.createElement = function (html) {
  var wrapper = document.createElement('div');
  innerHTML(wrapper, html);

  if (wrapper.children.length > 1) {
    throw new Error('"html" must be one wrapper element.');
  }

  return wrapper.children[0];
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util.createFragment = function (html) {
  var wrapper = document.createElement('div');
  innerHTML(wrapper, html);
  var fragment = document.createDocumentFragment();

  while (wrapper.firstChild) {
    fragment.appendChild(wrapper.firstChild);
  }

  return fragment;
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }
  return target.getAttribute('modifier').split(/\s+/).some(function (e) {
    return e === modifierName;
  });
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean} Whether it was added or not.
 */
util.addModifier = function (target, modifierName) {
  if (util.hasModifier(target, modifierName)) {
    return false;
  }

  modifierName = modifierName.trim();
  var modifierAttribute = target.getAttribute('modifier') || '';
  target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean} Whether it was found or not.
 */
util.removeModifier = function (target, modifierName) {
  if (!target.getAttribute('modifier')) {
    return false;
  }

  var modifiers = target.getAttribute('modifier').split(/\s+/);

  var newModifiers = modifiers.filter(function (item) {
    return item && item !== modifierName;
  });
  target.setAttribute('modifier', newModifiers.join(' '));

  return modifiers.length !== newModifiers.length;
};

util.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util.toggleAttribute = function (element, name, value) {
  if (value) {
    element.setAttribute(name, value);
  } else {
    element.removeAttribute(name);
  }
};

util.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 */
util.updateRipple = function (target) {
  var rippleElement = util.findChild(target, 'ons-ripple');

  if (target.hasAttribute('ripple')) {
    if (!rippleElement) {
      target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Obejct} Deferred promise.
 */
util.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
var TIMEOUT_RATIO = 1.4;

var util$2 = {};

// capitalize string
util$2.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * @param {Object} params
 * @param {String} params.property
 * @param {Float} params.duration
 * @param {String} params.timing
 */
util$2.buildTransitionValue = function (params) {
  params.property = params.property || 'all';
  params.duration = params.duration || 0.4;
  params.timing = params.timing || 'linear';

  var props = params.property.split(/ +/);

  return props.map(function (prop) {
    return prop + ' ' + params.duration + 's ' + params.timing;
  }).join(', ');
};

/**
 * Add an event handler on "transitionend" event.
 */
util$2.onceOnTransitionEnd = function (element, callback) {
  if (!element) {
    return function () {};
  }

  var fn = function fn(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();

      callback();
    }
  };

  var removeListeners = function removeListeners() {
    util$2._transitionEndEvents.forEach(function (eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };

  util$2._transitionEndEvents.forEach(function (eventName) {
    element.addEventListener(eventName, fn, false);
  });

  return removeListeners;
};

util$2._transitionEndEvents = function () {

  if ('ontransitionend' in window) {
    return ['transitionend'];
  }

  if ('onwebkittransitionend' in window) {
    return ['webkitTransitionEnd'];
  }

  if (util$2.vendorPrefix === 'webkit' || util$2.vendorPrefix === 'o' || util$2.vendorPrefix === 'moz' || util$2.vendorPrefix === 'ms') {
    return [util$2.vendorPrefix + 'TransitionEnd', 'transitionend'];
  }

  return [];
}();

util$2._cssPropertyDict = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var dict = {};
  var a = 'A'.charCodeAt(0);
  var z = 'z'.charCodeAt(0);

  var upper = function upper(s) {
    return s.substr(1).toUpperCase();
  };

  for (var i = 0; i < styles.length; i++) {

    var key = styles[i].replace(/^[\-]+/, '').replace(/[\-][a-z]/g, upper).replace(/^moz/, 'Moz');

    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== 'cssText' && key !== 'parentText') {
        dict[key] = true;
      }
    }
  }

  return dict;
}();

util$2.hasCssProperty = function (name) {
  return name in util$2._cssPropertyDict;
};

/**
 * Vendor prefix for css property.
 */
util$2.vendorPrefix = function () {
  var styles = window.getComputedStyle(document.documentElement, ''),
      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
  return pre;
}();

util$2.forceLayoutAtOnce = function (elements, callback) {
  this.batchImmediate(function () {
    elements.forEach(function (element) {
      // force layout
      element.offsetHeight;
    });
    callback();
  });
};

util$2.batchImmediate = function () {
  var callbacks = [];

  return function (callback) {
    if (callbacks.length === 0) {
      setImmediate(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$2.batchAnimationFrame = function () {
  var callbacks = [];

  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    setTimeout(callback, 1000 / 60);
  };

  return function (callback) {
    if (callbacks.length === 0) {
      raf(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$2.transitionPropertyName = function () {
  if (util$2.hasCssProperty('transitionDuration')) {
    return 'transition';
  }

  if (util$2.hasCssProperty(util$2.vendorPrefix + 'TransitionDuration')) {
    return util$2.vendorPrefix + 'Transition';
  }

  throw new Error('Invalid state');
}();

/**
 * @param {HTMLElement} element
 */
var Animit = function Animit(element) {
  if (!(this instanceof Animit)) {
    return new Animit(element);
  }

  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === '[object Array]') {
    this.elements = element;
  } else {
    throw new Error('First argument must be an array or an instance of HTMLElement.');
  }

  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};

Animit.prototype = {

  /**
   * @property {Array}
   */
  transitionQueue: undefined,

  /**
   * @property {Array}
   */
  elements: undefined,

  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function play(callback) {
    if (typeof callback === 'function') {
      this.transitionQueue.push(function (done) {
        callback();
        done();
      });
    }

    this.startAnimation();

    return this;
  },

  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function queue(transition, options) {
    var queue = this.transitionQueue;

    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }

    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }

    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error('Invalid arguments');
    }

    return this;
  },

  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function wait(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function (done) {
        setTimeout(done, 1000 * seconds);
      });
    }

    return this;
  },

  saveStyle: function saveStyle() {

    this.transitionQueue.push(function (done) {
      this.elements.forEach(function (element, index) {
        var css = this.lastStyleAttributeDict[index] = {};

        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }.bind(this));
      done();
    }.bind(this));

    return this;
  },

  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function restoreStyle(options) {
    options = options || {};
    var self = this;

    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }

    var transitionName = util$2.transitionPropertyName;

    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');

      this.transitionQueue.push(function (done) {
        var elements = this.elements;
        var timeoutId;

        var clearTransition = function clearTransition() {
          elements.forEach(function (element) {
            element.style[transitionName] = '';
          });
        };

        // add "transitionend" event handler
        var removeListeners = util$2.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });

        // for fail safe.
        timeoutId = setTimeout(function () {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1000 * TIMEOUT_RATIO);

        // transition and style settings
        elements.forEach(function (element, index) {

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === undefined) {
              css[name] = '';
            }
          }

          element.style[transitionName] = transitionValue;

          Object.keys(css).forEach(function (key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });

          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function (done) {
        reset();
        done();
      });
    }

    return this;

    function reset() {
      // Clear transition animation settings.
      self.elements.forEach(function (element, index) {
        element.style[transitionName] = 'none';

        var css = self.lastStyleAttributeDict[index];

        if (!css) {
          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
        }

        self.lastStyleAttributeDict[index] = undefined;

        for (var i = 0, name = ''; i < element.style.length; i++) {
          name = element.style[i];
          if (typeof css[element.style[i]] === 'undefined') {
            css[element.style[i]] = '';
          }
        }

        Object.keys(css).forEach(function (key) {
          element.style[key] = css[key];
        });
      });
    }
  },

  /**
   * Start animation sequence.
   */
  startAnimation: function startAnimation() {
    this._dequeueTransition();

    return this;
  },

  _dequeueTransition: function _dequeueTransition() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error('Current transition exists.');
    }
    this._currentTransition = transition;
    var self = this;
    var called = false;

    var done = function done() {
      if (!called) {
        called = true;
        self._currentTransition = undefined;
        self._dequeueTransition();
      } else {
        throw new Error('Invalid state: This callback is called twice.');
      }
    };

    if (transition) {
      transition.call(this, done);
    }
  }

};

/**
 * @param {Animit} arguments
 */
Animit.runAll = function () /* arguments... */{
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};

/**
 * @param {Object} options
 * @param {Float} [options.duration]
 * @param {String} [options.property]
 * @param {String} [options.timing]
 */
Animit.Transition = function (options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || 'linear';
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || 'all';
};

Animit.Transition.prototype = {

  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function build() {

    if (Object.keys(this.options.css).length === 0) {
      throw new Error('options.css is required.');
    }

    var css = createActualCssProps(this.options.css);

    if (this.options.duration > 0) {
      var transitionValue = util$2.buildTransitionValue(this.options);
      var self = this;

      return function (callback) {
        var elements = this.elements;
        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
        var timeoutId;

        var removeListeners = util$2.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          callback();
        });

        timeoutId = setTimeout(function () {
          removeListeners();
          callback();
        }, timeout);

        elements.forEach(function (element) {
          element.style[util$2.transitionPropertyName] = transitionValue;

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });
      };
    }

    if (this.options.duration <= 0) {
      return function (callback) {
        var elements = this.elements;

        elements.forEach(function (element) {
          element.style[util$2.transitionPropertyName] = '';

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });

        if (elements.length > 0) {
          util$2.forceLayoutAtOnce(elements, function () {
            util$2.batchAnimationFrame(callback);
          });
        } else {
          util$2.batchAnimationFrame(callback);
        }
      };
    }

    function createActualCssProps(css) {
      var result = {};

      Object.keys(css).forEach(function (name) {
        var value = css[name];

        if (util$2.hasCssProperty(name)) {
          result[name] = value;
          return;
        }

        var prefixed = util$2.vendorPrefix + util$2.capitalize(name);
        if (util$2.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });

      return result;
    }
  }
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja]オプションを指定します。[/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler) {
    element.addEventListener(type, handler, false);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler) {
    element.removeEventListener(type, handler, false);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find) {
    if (src.indexOf) {
      var index = src.indexOf(find);
      return index === -1 ? false : index;
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return false;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === false) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup();

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  });

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler) {
    var self = this;
    Event$1.on(self.element, gestures, handler, function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler) {
    var self = this;

    Event$1.off(self.element, gestures, handler, function (type) {
      var index = Utils.inArray({ gesture: type, handler: handler });
      if (index !== false) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 */
var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._renderPlatform = null;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._renderPlatform = platform.trim().toLowerCase();
      }
    }

    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ios';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'android';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'wp';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @methos isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'blackberry';
      } else if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'opera';
      } else {
        return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
      }
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'firefox';
      } else {
        return typeof InstallTrigger !== 'undefined';
      }
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'safari';
      } else {
        return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
      }
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'chrome';
      } else {
        return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
      }
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'ie';
      } else {
        return false || !!document.documentMode;
      }
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._renderPlatform) {
        return this._renderPlatform === 'edge';
      } else {
        return navigator.userAgent.indexOf(' Edge/') >= 0;
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var readyMap = new WeakMap();
var queueMap = new WeakMap();

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/dialog
 * @description
 *   [en]
 *     Utility methods to create different kinds of alert dialogs. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function (options) {
  // Prompt input string
  var inputString = '';
  if (options.isPrompt) {
    inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
  }

  // Buttons string
  var buttons = '';
  options.buttonLabels.forEach(function (label, index) {
    buttons += '\n      <button class="\n        alert-dialog-button\n        ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n        ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n      ">\n        ' + label + '\n      </button>\n    ';
  });

  // Dialog Element
  var el = {};
  var _destroyDialog = function _destroyDialog() {
    if (el.dialog.onDialogCancel) {
      el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
    }

    Object.keys(el).forEach(function (key) {
      return delete el[key];
    });
    el = null;

    if (options.destroy instanceof Function) {
      options.destroy();
    }
  };

  el.dialog = document.createElement('ons-alert-dialog');
  innerHTML(el.dialog, '\n    <div class="alert-dialog-mask"></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ');
  contentReady(el.dialog);

  // Set attributes
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && el.dialog.setAttribute(a, options[a]);
  });
  if (options.modifier) {
    util.addModifier(el.dialog, options.modifier);
  }

  var deferred = util.defer();

  // Prompt events
  if (options.isPrompt && options.submitOnEnter) {
    el.input = el.dialog.querySelector('.text-input');
    el.input.onkeypress = function (event) {
      if (event.keyCode === 13) {
        el.dialog.hide().then(function () {
          var resolveValue = el.input.value;
          _destroyDialog();
          options.callback(resolveValue);
          deferred.resolve(resolveValue);
        });
      }
    };
  }

  // Button events
  el.footer = el.dialog.querySelector('.alert-dialog-footer');
  util.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
    buttonElement.onclick = function () {
      el.dialog.hide().then(function () {
        var resolveValue = options.isPrompt ? el.input.value : index;
        el.dialog.remove();
        _destroyDialog();
        options.callback(resolveValue);
        deferred.resolve(resolveValue);
      });
    };

    el.footer.appendChild(buttonElement);
  });

  // Cancel events
  if (options.cancelable) {
    el.dialog.cancelable = true;
    el.dialog.onDialogCancel = function () {
      setImmediate(function () {
        el.dialog.remove();
        _destroyDialog();
      });
      var resolveValue = options.isPrompt ? null : -1;
      options.callback(resolveValue);
      deferred.reject(resolveValue);
    };
    el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
  }

  // Show dialog
  document.body.appendChild(el.dialog);
  options.compile(el.dialog);
  setImmediate(function () {
    el.dialog.show().then(function () {
      if (el.input && options.isPrompt && options.autofocus) {
        el.input.focus();
      }
    });
  });

  return deferred.promise;
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  typeof message === 'string' ? options.message = message : options = message;
  if (!options.message && !options.messageHTML) {
    throw new Error('Alert dialog must contain a message.');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    buttonLabels: ['OK'],
    primaryButtonIndex: 0,
    animation: 'default',
    cancelable: false
  }, defaults, options);
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Alert message.[/en]
 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
 * @param {String} [options.messageHTML]
 *   [en]Alert message in HTML.[/en]
 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialog要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialog要素のclass。[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.alert = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `1`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザに確認を促すダイアログを表示します。
 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.confirm = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    primaryButtonIndex: 1,
    title: 'Confirm'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is `0`.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`.[/en]
 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーに入力を促すダイアログを表示します。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.prompt = function (message, options) {
  options = _normalizeArguments(message, options, {
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });

  return notification._createAlertDialog(options);
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      throw new Error('Variable name must be a string.');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      throw new Error('Variable value must be a string or a function.');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      throw new Error('"' + name + '" is already defined.');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      throw new Error('Unable to parse empty string.');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          throw new Error('Nested interpolation not supported.');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          throw new Error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      throw new Error('Unterminated interpolation.');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        throw new Error('Variable "' + name + '" does not exist.');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          throw new Error('Must return a string.');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  html = ('' + html).trim();

  if (!html.match(/^<ons-page/)) {
    html = '<ons-page _muted>' + html + '</ons-page>';
  }

  return html;
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    window.document.addEventListener('DOMContentLoaded', callback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
    document.removeEventListener('DOMContentLoaded', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    document.addEventListener('DOMContentLoaded', function () {
      onReady();
    });
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

window.document.addEventListener('DOMContentLoaded', function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
    }
  }
}, false);

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    setImmediate(function () {
      var cache = internal$1.templateStore.get(page);

      if (cache) {
        var html = typeof cache === 'string' ? cache : cache[1];
        resolve(html);
      } else {
        (function () {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', page, true);
          xhr.onload = function (response) {
            var html = xhr.responseText;
            if (xhr.status >= 400 && xhr.status < 600) {
              reject(html);
            } else {
              resolve(html);
            }
          };
          xhr.onerror = function () {
            throw new Error('The page is not found: ' + page);
          };
          xhr.send(null);
        })();
      }
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).then(function (html) {
      return internal$1.normalizePageHTML(html);
    }, function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    }).then(function (html) {
      return internal$1.normalizePageHTML(html);
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      throw new Error('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.add(klass);
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return classList.remove(klass);
      });
    }

    /**
     * @param {Object} diff
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      for (var selector in scheme) {
        if (scheme.hasOwnProperty(selector)) {
          var targetElements = !selector || util.match(element, selector) ? [element] : element.querySelectorAll(selector);
          for (var i = 0; i < targetElements.length; i++) {
            ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
          }
        }
      }
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      throw Error('"delegate" parameter must be an object.');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      throw Error('"templateElement" parameter must be an instance of Element or null.');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render(items, height) {
      this._userDelegate._render(items, height);
    }

    /**
     * @param {Number} index
     * @param {Element} parent
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, parent, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, parent, function (element) {
          return done({ element: element });
        });
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          throw Error('createItemContent() must return an instance of Element.');
        }
        parent.appendChild(element);
        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        throw Error('countItems() must return a number.');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          throw Error('calculateItemHeight() must return a number.');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
    }

    this._topPositions = [];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }
    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, this._wrapperElement, function (item) {
        if (!_this._unknownItemHeight) {
          throw Error('Invalid state');
        }

        var done = function done() {
          _this._wrapperElement.removeChild(item.element);
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        var lastVisibility = _this._wrapperElement.style.visibility;
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            throw Error('Invalid state: this._itemHeight must be greater than zero.');
          }
          _this._wrapperElement.style.visibility = lastVisibility;
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      this._removeAllElements();
      this._onChange();
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this2 = this;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this));
      }

      var items = this._getItemsInView();

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        this._delegate._render(items, this._listHeight);
        return null;
      }

      var keep = {};

      items.forEach(function (item) {
        _this2._renderElement(item);
        keep[item.index] = true;
      });

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this2._removeElement(key);
      });

      this._wrapperElement.style.height = this._listHeight + 'px';
    }

    /**
     * @param {Object} item
     * @param {Number} item.index
     * @param {Number} item.top
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(_ref) {
      var _this3 = this;

      var index = _ref.index,
          top = _ref.top;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        item.element.style.top = top + 'px';
        return;
      }

      this._delegate.loadItemElement(index, this._wrapperElement, function (item) {
        util.extend(item.element.style, {
          position: 'absolute',
          top: top + 'px',
          left: 0,
          right: 0
        });

        _this3._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var item = this._renderedItems[index];

      this._delegate.destroyItem(index, item);

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this4 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this4._removeElement(key);
      });
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var start = 0;
      var end = this._itemCount - 1;

      if (this.staticItemHeight) {
        return parseInt(-current / this.staticItemHeight);
      }

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions() {
      var l = Math.min(this._topPositions.length, this._itemCount);
      this._topPositions[0] = 0;
      for (var i = 1, _l; i < _l; i++) {
        this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_getItemsInView',
    value: function _getItemsInView() {
      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      if (count !== this._itemCount) {
        this._itemCount = count;
        this._recalculateTopPositions();
      }

      var i = Math.max(0, this._calculateStartIndex(offset) - 30);

      var items = [];
      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        items.push({ top: top, index: i });
        top += this._getItemHeight(i);
      }
      this._listHeight = top;

      return items;
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this5 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this5, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'staticItemHeight',
    get: function get() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.LazyRepeatProvider = LazyRepeatProvider;
internal$1.LazyRepeatDelegate = LazyRepeatDelegate;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$3 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$3._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$3._ready = true;
      }, false);
    } else {
      util$3._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
window.addEventListener('DOMContentLoaded', function () {
  return util$3._onDOMContentLoaded();
}, false);

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$3.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$3.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        return {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none') {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'chevron': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  // Effects
  if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

    if (element.tagName.toLowerCase() === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (/material/.test(element.getAttribute('modifier'))) {
    util.removeModifier(element, 'material');

    if (util.removeModifier(element, 'material--flat')) {
      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var prepareAutoStyle = function prepareAutoStyle(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      platforms[mobileOS](element);
    }
  }
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepareAutoStyle
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage$1(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent,
      _ref$params = _ref.params,
      params = _ref$params === undefined ? {} : _ref$params;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util.createElement(html.trim());
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage$1;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent,
      _ref3$params = _ref3.params,
      params = _ref3$params === undefined ? {} : _ref3$params;

  var element = util.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function BaseAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, BaseAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration || 0;
    this.delay = options.delay || 0;
  }

  createClass(BaseAnimator, null, [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;
      return newAnimator;
    }
  }]);
  return BaseAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {};

ons$1._util = util;
ons$1.animit = Animit;
ons$1._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
ons$1._internal = internal$1;
ons$1.GestureDetector = GestureDetector;
ons$1.platform = platform;
ons$1.softwareKeyboard = softwareKeyboard;
ons$1.pageAttributeExpression = pageAttributeExpression;
ons$1.orientation = orientation;
ons$1.notification = notification;
ons$1._animationOptionsParser = parse;
ons$1._autoStyle = autoStyle;
ons$1._DoorLock = DoorLock;
ons$1._contentReady = contentReady;
ons$1.defaultPageLoader = defaultPageLoader;
ons$1.PageLoader = PageLoader;
ons$1._BaseAnimator = BaseAnimator;

ons$1._readyLock = new DoorLock();

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja]初期化されているかどうかを返します。[/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
 *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed.[/en]
 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  ons$1._deviceBackButtonDispatcher.enable();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above.[/en]
 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  ons$1._internal.config.autoStatusBarFill = false;
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
 */
ons$1.disableAnimations = function () {
  ons$1._internal.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja]アニメーションを有効にします。[/ja]
 */
ons$1.enableAnimations = function () {
  ons$1._internal.config.animationsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = ons$1._autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = ons$1._autoStyle.enable;

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      ons$1._autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createPopoverOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var popover = div.querySelector('ons-popover');
    document.body.appendChild(popover);

    if (options.link instanceof Function) {
      options.link(popover);
    }

    return popover;
  });
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
 */
ons$1.createPopover = ons$1._createPopoverOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var dialog = div.querySelector('ons-dialog');
    document.body.appendChild(dialog);

    if (options.link instanceof Function) {
      options.link(dialog);
    }

    return dialog;
  });
};

/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createDialog = ons$1._createDialogOriginal;

/**
 * @param {String} page
 * @param {Object} [options]
 * @param {Function} [options.link]
 * @return {Promise}
 */
ons$1._createAlertDialogOriginal = function (page) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  if (!page) {
    throw new Error('Page url must be defined.');
  }

  return ons$1._internal.getPageHTMLAsync(page).then(function (html) {
    html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
    var div = ons$1._util.createElement('<div>' + html + '</div>');

    var alertDialog = div.querySelector('ons-alert-dialog');
    document.body.appendChild(alertDialog);

    if (options.link instanceof Function) {
      options.link(alertDialog);
    }

    return alertDialog;
  });
};

/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createAlertDialog = ons$1._createAlertDialogOriginal;

/**
 * @param {String} page
 * @param {Function} link
 */
ons$1._resolveLoadingPlaceholderOriginal = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

  if (elements.length > 0) {
    elements.filter(function (element) {
      return !element.getAttribute('page');
    }).forEach(function (element) {
      element.setAttribute('ons-loading-placeholder', page);
      ons$1._resolveLoadingPlaceholder(element, page, link);
    });
  } else {
    throw new Error('No ons-loading-placeholder exists.');
  }
};

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
 */
ons$1.resolveLoadingPlaceholder = ons$1._resolveLoadingPlaceholderOriginal;

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (element, page, link) {
  link = link || function (element, done) {
    done();
  };
  ons$1._internal.getPageHTMLAsync(page).then(function (html) {

    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }

    var contentElement = ons$1._util.createElement('<div>' + html + '</div>');
    contentElement.style.display = 'none';

    element.appendChild(contentElement);

    link(contentElement, function () {
      contentElement.style.display = '';
    });
  }).catch(function (error) {
    throw new Error('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  window.addEventListener('DOMContentLoaded', function () {
    if (ons$1.isWebView()) {
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  }, false);
}

window._superSecretOns = ons$1;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement(self) {
    var _this, _ret;

    classCallCheck(this, BaseElement);

    self = (_this = possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this, self)), _this);
    self.init();
    return _ret = self, possibleConstructorReturn(_this, _ret);
  }

  createClass(BaseElement, [{
    key: 'init',
    value: function init() {}
  }]);
  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template.
 *
 *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
 *   [/en]
 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html">
 * </ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  function TemplateElement() {
    classCallCheck(this, TemplateElement);
    return possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).apply(this, arguments));
  }

  createClass(TemplateElement, [{
    key: 'init',


    /**
     * @property template
     * @type {String}
     * @description
     *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      this.template = this.innerHTML;

      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  function IfElement() {
    classCallCheck(this, IfElement);
    return possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).apply(this, arguments));
  }

  createClass(IfElement, [{
    key: 'init',


    /**
     * @attribute platform
     * @initonly
     * @type {string}
     * @description
     *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute orientation
     * @type {string}
     * @description
     *  [en]Either `"portrait"` or `"landscape"`.[/en]
     *  [ja]portraitもしくはlandscapeを指定します[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        if (platform._renderPlatform !== null) {
          _this2._platformUpdate();
        } else if (!_this2._isAllowedPlatform()) {
          while (_this2.childNodes[0]) {
            _this2.childNodes[0].remove();
          }
          _this2._platformUpdate();
        }
      });

      this._onOrientationChange();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function (_BaseAnimator) {
  inherits(AlertDialogAnimator, _BaseAnimator);

  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);
    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
 *   [/en]
 *   [ja][/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @modifier rowfooter
 *   [en]Horizontally aligns the footer buttons.[/en]
 *   [ja][/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseElement) {
  inherits(AlertDialogElement, _BaseElement);

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);
    return possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).apply(this, arguments));
  }

  createClass(AlertDialogElement, [{
    key: 'init',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the alert dialog is displayed.[/en]
     *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from showing.[/en]
     *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the alert dialog is displayed.[/en]
     *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the alert dialog is hidden.[/en]
     *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute to stop the dialog from hiding.[/en]
     *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the alert dialog is hidden.[/en]
     * [ja]アラートダイアログが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.alertDialog
     *   [en]Alert dialog object.[/en]
     *   [ja]アラートダイアログのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja]ダイアログの見た目を指定します。[/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = function () {
        return _this2._cancel();
      };

      this._updateAnimatorFactory();
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      if (this.getAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクトです。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja]ダイアログを表示します。[/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var _ret = function () {
          var tryShow = function tryShow() {
            var unlock = _this3._doorLock.lock();
            var animator = _this3._animatorFactory.newAnimator(options);

            _this3.style.display = 'block';
            _this3._mask.style.opacity = '1';

            return new Promise(function (resolve) {
              contentReady(_this3, function () {
                animator.show(_this3, function () {
                  _this3._visible = true;
                  unlock();

                  util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                  callback();
                  resolve(_this3);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this3._doorLock.waitUnlock(function () {
                return resolve(tryShow());
              });
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        alertDialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var _ret2 = function () {
          var tryHide = function tryHide() {
            var unlock = _this4._doorLock.lock();
            var animator = _this4._animatorFactory.newAnimator(options);

            return new Promise(function (resolve) {
              contentReady(_this4, function () {
                animator.hide(_this4, function () {
                  _this4.style.display = 'none';
                  _this4._visible = false;
                  unlock();

                  util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                  callback();
                  resolve(_this4);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this4._doorLock.waitUnlock(function () {
                return resolve(tryHide());
              });
            })
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this5 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this5._running = false;
          util.triggerElementEvent(_this5, 'dialog-cancel');
        }, function () {
          return _this5._running = false;
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }
  }, {
    key: '_mask',
    get: function get() {
      return util.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict;
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseElement);

customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName = 'back-button';

var scheme$1 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/navigator
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigatorコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);
    return possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).apply(this, arguments));
  }

  createClass(BackButtonElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the back button.[/en]
     *  [ja]バックボタンの見た目を指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._options = {};
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName);

      if (!util.findChild(this, '.back-button__label')) {
        var label = util.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util.findChild(this, '.back-button__icon')) {
        var icon = util.create('span.back-button__icon');

        this.insertBefore(icon, this.children[0]);
      }

      ModifierUtil.initModifier(this, scheme$1);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @property options.refresh
     * @description
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName)) {
            this.className = defaultClassName + ' ' + current;
          }
          break;

        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$1);
          break;
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$1 = 'bottom-bar';
var scheme$2 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);
    return possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).apply(this, arguments));
  }

  createClass(BottomToolbarElement, [{
    key: 'init',

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja]ツールバーの見た目の表現を指定します。[/ja]
     */

    value: function init() {
      this.classList.add(defaultClassName$1);
      ModifierUtil.initModifier(this, scheme$2);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (util.match(this.parentNode, 'ons-page')) {
        this.parentNode.classList.add('page-with-bottom-toolbar');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$1)) {
            this.className = defaultClassName$1 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$2);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$3 = { '': 'button--*' };

var defaultClassName$2 = 'button';

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja]目立たないボタンを表示します。[/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja]目立つボタンを表示します。[/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja]マテリアルデザインのボタン[/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja]マテリアルデザインのフラットボタン[/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseElement) {
  inherits(ButtonElement, _BaseElement);

  function ButtonElement() {
    classCallCheck(this, ButtonElement);
    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
  }

  createClass(ButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$2)) {
            this.className = defaultClassName$2 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$2);

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$3);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return ButtonElement;
}(BaseElement);

customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$4 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>コンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);
    return possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).apply(this, arguments));
  }

  createClass(CarouselItemElement, [{
    key: 'init',
    value: function init() {
      this.style.width = '100%';
      ModifierUtil.initModifier(this, scheme$4);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

customElements.define('ons-carousel-item', CarouselItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var VerticalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaY;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityY;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().height;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(0px, ' + -scroll + 'px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
      this._offset = -(height - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.height = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

var HorizontalModeTrait = {

  _getScrollDelta: function _getScrollDelta(event) {
    return event.gesture.deltaX;
  },

  _getScrollVelocity: function _getScrollVelocity(event) {
    return event.gesture.velocityX;
  },

  _getElementSize: function _getElementSize() {
    if (!this._currentElementSize) {
      this._currentElementSize = this.getBoundingClientRect().width;
    }

    return this._currentElementSize;
  },

  _generateScrollTransform: function _generateScrollTransform(scroll) {
    return 'translate3d(' + -scroll + 'px, 0px, 0px)';
  },

  _updateDimensionData: function _updateDimensionData() {
    this._style = window.getComputedStyle(this);
    this._dimensions = this.getBoundingClientRect();
  },

  _updateOffset: function _updateOffset() {
    if (this.centered) {
      var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
      this._offset = -(width - this._getCarouselItemSize()) / 2;
    }
  },

  _layoutCarouselItems: function _layoutCarouselItems() {
    var children = this._getCarouselItemElements();

    var sizeAttr = this._getCarouselItemSizeAttr();
    var sizeInfo = this._decomposeSizeString(sizeAttr);

    for (var i = 0; i < children.length; i++) {
      children[i].style.position = 'absolute';
      children[i].style.width = sizeAttr;
      children[i].style.visibility = 'visible';
      children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
    }
  },

  _setup: function _setup() {
    this._updateDimensionData();
    this._updateOffset();
    this._layoutCarouselItems();
  }
};

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-itemコンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  function CarouselElement() {
    classCallCheck(this, CarouselElement);
    return possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).apply(this, arguments));
  }

  createClass(CarouselElement, [{
    key: 'init',


    /**
     * @event postchange
     * @description
     *   [en]Fired just after the current carousel item has changed.[/en]
     *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
     * @param {Number} event.lastActiveIndex
     *   [en]Previous active index.[/en]
     *   [ja]以前アクティブだった要素のインデックス。[/ja]
     */

    /**
     * @event refresh
     * @description
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja]カルーセルが更新された時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Carousel object.[/en]
     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
     */

    /**
     * @event overscroll
     * @description
     *   [en]Fired when the carousel has been overscrolled.[/en]
     *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.carousel
     *   [en]Fired when the carousel has been refreshed.[/en]
     *   [ja]カルーセルが更新された時に発火します。[/ja]
     * @param {Number} event.activeIndex
     *   [en]Current active index.[/en]
     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
     * @param {String} event.direction
     *   [en]Can be one of either "up", "down", "left" or "right".[/en]
     *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
     * @param {Function} event.waitToReturn
     *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
     *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
     *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
     */

    /**
     * @attribute fullscreen
     * @description
     *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
     *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
     */

    /**
     * @attribute overscrollable
     * @description
     *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
     *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
     */

    /**
     * @attribute centered
     * @description
     *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
     *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
     */

    /**
     * @attribute item-width
     * @type {String}
     * @description
     *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
     *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
     */

    /**
     * @attribute item-height
     * @type {String}
     * @description
     *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
     *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
     */

    /**
     * @attribute auto-scroll
     * @description
     *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
     *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
     */

    /**
     * @attribute auto-scroll-ratio
     * @type {Number}
     * @description
     *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
     *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @description
     *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
     *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the carousel is disabled.[/en]
     *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
     */

    /**
     * @attribute initial-index
     * @initonly
     * @type {Number}
     * @description
     *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
     *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
     */

    /**
     * @attribute auto-refresh
     * @description
     *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
     *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    value: function init() {
      this._doorLock = new DoorLock();
      this._scroll = 0;
      this._offset = 0;
      this._lastActiveIndex = 0;

      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnResize = this._onResize.bind(this);

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
    }
  }, {
    key: '_onResize',
    value: function _onResize() {
      var i = this._scroll / this._currentElementSize;
      delete this._currentElementSize;
      this.setActiveIndex(i);
    }
  }, {
    key: '_onDirectionChange',
    value: function _onDirectionChange() {
      if (this._isVertical()) {
        this.style.overflowX = 'auto';
        this.style.overflowY = '';
      } else {
        this.style.overflowX = '';
        this.style.overflowY = 'auto';
      }

      this.refresh();
    }
  }, {
    key: '_saveLastState',
    value: function _saveLastState() {
      this._lastState = {
        elementSize: this._getCarouselItemSize(),
        carouselElementCount: this.itemCount,
        width: this._getCarouselItemSize() * this.itemCount
      };
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getCarouselItemSize',
    value: function _getCarouselItemSize() {
      var sizeAttr = this._getCarouselItemSizeAttr();
      var sizeInfo = this._decomposeSizeString(sizeAttr);
      var elementSize = this._getElementSize();

      if (sizeInfo.unit === '%') {
        return Math.round(sizeInfo.number / 100 * elementSize);
      } else if (sizeInfo.unit === 'px') {
        return sizeInfo.number;
      } else {
        throw new Error('Invalid state');
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: '_getInitialIndex',
    value: function _getInitialIndex() {
      var index = parseInt(this.getAttribute('initial-index'), 10);

      if (typeof index === 'number' && !isNaN(index)) {
        return Math.max(Math.min(index, this.itemCount - 1), 0);
      } else {
        return 0;
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: '_getCarouselItemSizeAttr',
    value: function _getCarouselItemSizeAttr() {
      var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
      var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_decomposeSizeString',
    value: function _decomposeSizeString(size) {
      var matches = size.match(/^(\d+)(px|%)/);

      return {
        number: parseInt(matches[1], 10),
        unit: matches[2]
      };
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
      this._lastActiveIndex = this._getInitialIndex();
      this._scrollTo(this._scroll);
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel要素のインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
      var max = this._calculateMaxScroll();

      this._scroll = Math.max(0, Math.min(max, scroll));
      return this._scrollTo(this._scroll, options).then(function () {
        _this2._tryFirePostChangeEvent();
        return _this2;
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = this._scroll - (this._offset || 0);
      var count = this.itemCount;
      var size = this._getCarouselItemSize();

      if (scroll < 0) {
        return 0;
      }

      var i = void 0;
      for (i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      // max carousel index
      return i;
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]次のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]前のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isEnabledChangeEvent',
    value: function _isEnabledChangeEvent() {
      var elementSize = this._getElementSize();
      var carouselItemSize = this._getCarouselItemSize();

      return this.autoScroll && Math.abs(elementSize - carouselItemSize) < 0.5;
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_isVertical',
    value: function _isVertical() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: '_prepareEventListeners',
    value: function _prepareEventListeners() {
      var _this3 = this;

      this._gestureDetector = new GestureDetector(this, {
        dragMinDistance: 1,
        dragLockToAxis: true
      });
      this._mutationObserver = new MutationObserver(function () {
        return _this3.refresh();
      });

      this._updateSwipeable();
      this._updateAutoRefresh();

      window.addEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._gestureDetector.dispose();
      this._gestureDetector = null;

      this._mutationObserver.disconnect();
      this._mutationObserver = null;

      window.removeEventListener('resize', this._boundOnResize, true);
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      if (this._gestureDetector) {
        if (this.swipeable) {
          this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.on('dragend', this._boundOnDragEnd);
        } else {
          this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
          this._gestureDetector.off('dragend', this._boundOnDragEnd);
        }
      }
    }
  }, {
    key: '_updateAutoRefresh',
    value: function _updateAutoRefresh() {
      if (this._mutationObserver) {
        if (this.hasAttribute('auto-refresh')) {
          this._mutationObserver.observe(this, { childList: true });
        } else {
          this._mutationObserver.disconnect();
        }
      }
    }
  }, {
    key: '_tryFirePostChangeEvent',
    value: function _tryFirePostChangeEvent() {
      var currentIndex = this.getActiveIndex();

      if (this._lastActiveIndex !== currentIndex) {
        var lastActiveIndex = this._lastActiveIndex;
        this._lastActiveIndex = currentIndex;

        util.triggerElementEvent(this, 'postchange', {
          carousel: this,
          activeIndex: currentIndex,
          lastActiveIndex: lastActiveIndex
        });
      }
    }
  }, {
    key: '_isWrongDirection',
    value: function _isWrongDirection(d) {
      // this._lastDragDirection = d;
      return this._isVertical() ? d === 'left' || d === 'right' : d === 'up' || d === 'down';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      if (this._isWrongDirection(event.gesture.direction)) {
        return;
      }

      event.stopPropagation();

      this._lastDragEvent = event;

      var scroll = this._scroll - this._getScrollDelta(event);
      this._scrollTo(scroll);
      event.gesture.preventDefault();

      this._tryFirePostChangeEvent();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var _this4 = this;

      if (!this._lastDragEvent) {
        return;
      }
      this._currentElementSize = undefined;
      this._scroll = this._scroll - this._getScrollDelta(event);

      // if (!this._isWrongDirection(this._lastDragDirection) && this._getScrollDelta(event) !== 0) {
      //   event.stopPropagation();
      // }

      if (this._isOverScroll(this._scroll)) {
        var waitForAction = false;
        util.triggerElementEvent(this, 'overscroll', {
          carousel: this,
          activeIndex: this.getActiveIndex(),
          direction: this._getOverScrollDirection(),
          waitToReturn: function waitToReturn(promise) {
            waitForAction = true;
            promise.then(function () {
              return _this4._scrollToKillOverScroll();
            });
          }
        });

        if (!waitForAction) {
          this._scrollToKillOverScroll();
        }
      } else {
        this._startMomentumScroll();
      }
      this._lastDragEvent = null;

      event.gesture.preventDefault();
    }

    /**
     * @param {Object} trait
     */

  }, {
    key: '_mixin',
    value: function _mixin(trait) {
      Object.keys(trait).forEach(function (key) {
        this[key] = trait[key];
      }.bind(this));
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll() {
      if (this._lastDragEvent) {
        var velocity = this._getScrollVelocity(this._lastDragEvent);
        var duration = 0.3;
        var scrollDelta = duration * 100 * velocity;
        var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

        this._scroll = scroll;

        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(this._scroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
      }
    }
  }, {
    key: '_normalizeScrollPosition',
    value: function _normalizeScrollPosition(scroll) {
      var max = this._calculateMaxScroll();

      if (!this.autoScroll) {
        return Math.max(0, Math.min(max, scroll));
      }
      var arr = [];
      var size = this._getCarouselItemSize();
      var nbrOfItems = this.itemCount;

      for (var i = 0; i < nbrOfItems; i++) {
        if (i * size + this._offset < max) {
          arr.push(i * size + this._offset);
        }
      }
      arr.push(max);

      arr.sort(function (left, right) {
        left = Math.abs(left - scroll);
        right = Math.abs(right - scroll);

        return left - right;
      });

      arr = arr.filter(function (item, pos) {
        return !pos || item != arr[pos - 1];
      });

      var lastScroll = this._lastActiveIndex * size + this._offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;
      var result = arr[0];

      if (scrollRatio <= this.autoScrollRatio) {
        result = lastScroll;
      } else if (scrollRatio < 1.0) {
        if (arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }

      return Math.max(0, Math.min(max, result));
    }

    /**
     * @return {Array}
     */

  }, {
    key: '_getCarouselItemElements',
    value: function _getCarouselItemElements() {
      return util.arrayFrom(this.children).filter(function (child) {
        return child.nodeName.toLowerCase() === 'ons-carousel-item';
      });
    }

    /**
     * @param {Number} scroll
     * @param {Object} [options]
     * @return {Promise} Resolves to the carousel element
     */

  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isOverscrollable = this.overscrollable;

      var normalizeScroll = function normalizeScroll(scroll) {
        var ratio = 0.35;

        if (scroll < 0) {
          return isOverscrollable ? Math.round(scroll * ratio) : 0;
        }

        var maxScroll = _this5._calculateMaxScroll();
        if (maxScroll < scroll) {
          return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
        }

        return scroll;
      };

      return new Promise(function (resolve) {
        Animit(_this5._getCarouselItemElements()).queue({
          transform: _this5._generateScrollTransform(normalizeScroll(scroll))
        }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
          if (options.callback instanceof Function) {
            options.callback();
          }
          resolve();
        });
      });
    }
  }, {
    key: '_calculateMaxScroll',
    value: function _calculateMaxScroll() {
      var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: '_isOverScroll',
    value: function _isOverScroll(scroll) {
      if (scroll < 0 || scroll > this._calculateMaxScroll()) {
        return true;
      }
      return false;
    }
  }, {
    key: '_getOverScrollDirection',
    value: function _getOverScrollDirection() {
      if (this._isVertical()) {
        return this._scroll <= 0 ? 'up' : 'down';
      } else {
        return this._scroll <= 0 ? 'left' : 'right';
      }
    }
  }, {
    key: '_scrollToKillOverScroll',
    value: function _scrollToKillOverScroll() {
      var duration = 0.4;

      if (this._scroll < 0) {
        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(0)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = 0;
        return;
      }

      var maxScroll = this._calculateMaxScroll();

      if (maxScroll < this._scroll) {
        Animit(this._getCarouselItemElements()).queue({
          transform: this._generateScrollTransform(maxScroll)
        }, {
          duration: duration,
          timing: 'cubic-bezier(.1, .4, .1, 1)'
        }).queue(function (done) {
          done();
          this._tryFirePostChangeEvent();
        }.bind(this)).play();
        this._scroll = maxScroll;
        return;
      }

      return;
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja]カルーセル要素の数です。[/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
     */
    value: function refresh() {
      // Bug fix
      if (this._getCarouselItemSize() === 0) {
        return;
      }

      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
      this._setup();

      if (this._lastState && this._lastState.width > 0) {
        var scroll = this._scroll; // - this._offset;

        if (this._isOverScroll(scroll)) {
          this._scrollToKillOverScroll();
        } else {
          if (this.autoScroll) {
            scroll = this._normalizeScrollPosition(scroll);
          }

          this._scrollTo(scroll);
        }
      }

      this._saveLastState();

      util.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]最初のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]最後のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this._prepareEventListeners();

      this._setup();
      this._setupInitialIndex();

      this._saveLastState();

      // Fix rendering glitch on Android 4.1
      if (this.offsetHeight === 0) {
        setImmediate(function () {
          return _this6.refresh();
        });
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._updateSwipeable();
          break;
        case 'auto-refresh':
          this._updateAutoRefresh();
          break;
        case 'direction':
          this._onDirectionChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._removeEventListeners();
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]現在のオートスクロールのratio値。[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get() {
      return this._getCarouselItemElements().length;
    }
  }, {
    key: 'autoScrollRatio',
    get: function get() {
      var attr = this.getAttribute('auto-scroll-ratio');

      if (!attr) {
        return 0.5;
      }

      var scrollRatio = parseFloat(attr);
      if (scrollRatio < 0.0 || scrollRatio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      return isNaN(scrollRatio) ? 0.5 : scrollRatio;
    },
    set: function set(ratio) {
      if (ratio < 0.0 || ratio > 1.0) {
        throw new Error('Invalid ratio.');
      }

      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get() {
      return this.hasAttribute('swipeable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'auto-scroll', value);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this.hasAttribute('disabled');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrollできればtrueを返します。[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get() {
      return this.hasAttribute('overscrollable');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centered状態になっていればtrueを返します。[/ja]
     */

  }, {
    key: 'centered',
    get: function get() {
      return this.hasAttribute('centered');
    },
    set: function set(value) {
      return util.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['swipeable', 'auto-refresh', 'direction'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['postchange', 'refresh', 'overscroll'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
 * @codepen GgujC {wide}
 * @guide layouting [en]Layouting guide[/en][ja]レイアウト機能[/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-rowコンポーネント[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);
    return possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).apply(this, arguments));
  }

  createClass(ColElement, [{
    key: 'init',
    value: function init() {
      if (this.getAttribute('width')) {
        this._updateWidth();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (typeof width === 'string') {
        width = ('' + width).trim();
        width = width.match(/^\d+$/) ? width + '%' : width;

        this.style.webkitBoxFlex = '0';
        this.style.webkitFlex = '0 0 ' + width;
        this.style.mozBoxFlex = '0';
        this.style.mozFlex = '0 0 ' + width;
        this.style.msFlex = '0 0 ' + width;
        this.style.flex = '0 0 ' + width;
        this.style.maxWidth = width;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function (_BaseAnimator) {
  inherits(DialogAnimator, _BaseAnimator);

  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);
    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);
    return possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, 300%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, 300%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);
    return possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -350%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -350%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$5 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$1 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseElement) {
  inherits(DialogElement, _BaseElement);

  function DialogElement() {
    classCallCheck(this, DialogElement);
    return possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).apply(this, arguments));
  }

  createClass(DialogElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._visible = false;
      this._doorLock = new DoorLock();
      this._boundCancel = function () {
        return _this2._cancel();
      };

      this._updateAnimatorFactory();
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        container.classList.add('dialog-container');

        dialog.appendChild(container);

        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, scheme$5);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this3 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this3._running = false;
          util.triggerElementEvent(_this3, 'dialog-cancel');
        }, function () {
          return _this3._running = false;
        });
      }
    }

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

  }, {
    key: 'show',
    value: function show() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel2 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'preshow', {
        dialog: this,
        cancel: function cancel() {
          _cancel2 = true;
        }
      });

      if (!_cancel2) {
        var _ret = function () {
          var tryShow = function tryShow() {
            var unlock = _this4._doorLock.lock();
            var animator = _this4._animatorFactory.newAnimator(options);

            _this4.style.display = 'block';
            _this4._mask.style.opacity = '1';

            return new Promise(function (resolve) {
              contentReady(_this4, function () {
                animator.show(_this4, function () {
                  _this4._visible = true;
                  unlock();

                  util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                  callback();
                  resolve(_this4);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this4._doorLock.waitUnlock(function () {
                return resolve(tryShow());
              });
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      } else {
        return Promise.reject('Canceled in preshow event.');
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _cancel3 = false;
      var callback = options.callback || function () {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      util.triggerElementEvent(this, 'prehide', {
        dialog: this,
        cancel: function cancel() {
          _cancel3 = true;
        }
      });

      if (!_cancel3) {
        var _ret2 = function () {
          var tryHide = function tryHide() {
            var unlock = _this5._doorLock.lock();
            var animator = _this5._animatorFactory.newAnimator(options);

            return new Promise(function (resolve) {
              contentReady(_this5, function () {
                animator.hide(_this5, function () {
                  _this5.style.display = 'none';
                  _this5._visible = false;
                  unlock();

                  util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                  callback();
                  resolve(_this5);
                });
              });
            });
          };

          return {
            v: new Promise(function (resolve) {
              _this5._doorLock.waitUnlock(function () {
                return resolve(tryHide());
              });
            })
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      } else {
        return Promise.reject('Canceled in prehide event.');
      }
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this6 = this;

      this.onDeviceBackButton = function (e) {
        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
      };

      contentReady(this, function () {
        _this6._mask.addEventListener('click', _this6._boundCancel, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
      } else if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }
  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     * [en]Fired just before the dialog is displayed.[/en]
     * [ja]ダイアログが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being shown.[/en]
     *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
     */

    /**
     * @event postshow
     * @description
     * [en]Fired just after the dialog is displayed.[/en]
     * [ja]ダイアログが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     * [en]Fired just before the dialog is hidden.[/en]
     * [ja]ダイアログが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Execute this function to stop the dialog from being hidden.[/en]
     *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
     */

    /**
     * @event posthide
     * @description
     * [en]Fired just after the dialog is hidden.[/en]
     * [ja]ダイアログが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.dialog
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the dialog.[/en]
     *  [ja]ダイアログの表現を指定します。[/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *  [en]If this attribute is set the dialog is disabled.[/en]
     *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
     *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @attribute mask-color
     * @type {String}
     * @default rgba(0, 0, 0, 0.2)
     * @description
     *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
     */

    get: function get() {
      return util.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get() {
      return util.findChild(this, '.dialog');
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'animation'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$1;
    }
  }, {
    key: 'DialogAnimator',
    get: function get() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseElement);

customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$3 = 'fab';

var scheme$6 = {
  '': 'fab--*'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  function FabElement() {
    classCallCheck(this, FabElement);
    return possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).apply(this, arguments));
  }

  createClass(FabElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      // The following statements can be executed before contentReady
      // since these do not access the children
      this.show();
      this.classList.add(defaultClassName$3);

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this3 = this;

      autoStyle.prepare(this);

      if (!util.findChild(this, '.fab__icon')) {
        (function () {
          var content = document.createElement('span');
          content.classList.add('fab__icon');

          util.arrayFrom(_this3.childNodes).forEach(function (element) {
            if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
              content.appendChild(element);
            }
          });
          _this3.appendChild(content);
        })();
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$6);

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$3)) {
            this.className = defaultClassName$3 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$6);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.hide();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(1)';
      this.style.webkitTransform = 'scale(1)';
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.style.transform = 'scale(0)';
      this.style.webkitTransform = 'scale(0)';
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'toggle',


    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */
    value: function toggle() {
      this.visible ? this.hide() : this.show();
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this.style.transform === 'scale(1)' && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'position', 'class'];
    }
  }]);
  return FabElement;
}(BaseElement);

customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
 * @guide gesture-detector
 *   [en]Detecting finger gestures[/en]
 *   [ja]ジェスチャー操作の検知[/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);
    return possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).apply(this, arguments));
  }

  createClass(GestureDetectorElement, [{
    key: 'init',
    value: function init() {
      this._gestureDetector = new GestureDetector(this);
    }
  }]);
  return GestureDetectorElement;
}(BaseElement);

customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  function IconElement() {
    classCallCheck(this, IconElement);
    return possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).apply(this, arguments));
  }

  createClass(IconElement, [{
    key: 'init',


    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
     *
     *     See all available icons on their respective sites:
     *
     *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
     *     * [Ionicons](http://ionicons.com)
     *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
     *
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit, material:md-edit">
     *     </ons-icon>
     *     ```
     *
     *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute size
     * @type {String}
     * @description
     *   [en]
     *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
     *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
     *
     *     The code:
     *
     *     ```
     *     <ons-icon
     *       icon="ion-edit"
     *       size="32px, material:24px">
     *     </ons-icon>
     *     ```
     *
     *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute rotate
     * @type {Number}
     * @description
     *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
     *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
     */

    /**
     * @attribute fixed-width
     * @type {Boolean}
     * @default false
     * @description
     *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute spin
     * @description
     *   [en]Specify whether the icon should be spinning.[/en]
     *   [ja]アイコンを回転するかどうかを指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
        this._update();
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._update();
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this2 = this;

      this._cleanClassAttribute();

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util.extend(this.style, style);

      classList.forEach(function (className) {
        return _this2.classList.add(className);
      });
    }
  }, {
    key: '_getAttribute',
    value: function _getAttribute(attr) {
      var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);
      return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute() {
      var _this3 = this;

      util.arrayFrom(this.classList).filter(function (className) {
        return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
        );
      }).forEach(function (className) {
        return _this3.classList.remove(className);
      });

      this.classList.remove('zmdi');
      this.classList.remove('ons-icon--ion');
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
      } else {
        classList.push('fa');
        classList.push('fa-' + iconName);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('fa-' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['icon', 'size', 'modifier'];
    }
  }]);
  return IconElement;
}(BaseElement);

customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      util.updateParentPosition(this);

      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     この関数は`HTMLElement`を返してください。
     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja]リスト内のアイテム数を返してください。[/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
     *     この関数はオプショナルです。もしこの関数が無い場合には、
     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
     *     アイテムのインデックス値とDOM要素が引数として渡されます。
     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get() {
      throw new Error('This property can only be used to set the delegate object.');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$4 = 'list__header';
var scheme$7 = { '': 'list__header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @guide lists [en]Using lists[/en][ja]リストを使う[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);
    return possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).apply(this, arguments));
  }

  createClass(ListHeaderElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list header.[/en]
     *   [ja]ヘッダーの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$4);
      ModifierUtil.initModifier(this, scheme$7);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$4)) {
            this.className = defaultClassName$4 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$5 = 'list__item';
var scheme$8 = {
  '.list__item': 'list__item--*',
  '.list__item__left': 'list__item--*__left',
  '.list__item__center': 'list__item--*__center',
  '.list__item__right': 'list__item--*__right',
  '.list__item__label': 'list__item--*__label',
  '.list__item__title': 'list__item--*__title',
  '.list__item__subtitle': 'list__item--*__subtitle',
  '.list__item__thumbnail': 'list__item--*__thumbnail',
  '.list__item__icon': 'list__item--*__icon'
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
 *
 *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *     </ons-list-item>
 *     ```
 *
 *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja]リストを使う[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list__item__title">Title</div>
 *     <div class="list__item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  function ListItemElement() {
    classCallCheck(this, ListItemElement);
    return possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).apply(this, arguments));
  }

  createClass(ListItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list item.[/en]
     *   [ja]各要素の表現を指定します。[/ja]
     */

    /**
     * @attribute lock-on-drag
     * @type {String}
     * @description
     *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
     *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
     */

    /**
     * @attribute tappable
     * @type {Boolean}
     * @description
     *   [en]Makes the element react to taps.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute tap-background-color
     * @type {Color}
     * @description
     *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$5);

      var left = void 0,
          center = void 0,
          right = void 0;

      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('left')) {
          el.classList.add('list__item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list__item__right');
          right = el;
        }
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right) {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        this.insertBefore(center, right || null);
      }

      center.classList.add('center');
      center.classList.add('list__item__center');

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$8);

      autoStyle.prepare(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$5)) {
            this.className = defaultClassName$5 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
          break;
        case 'ripple':
          this._updateRipple();
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('drag', this._onDrag);
      this.addEventListener('touchstart', this._onTouch);
      this.addEventListener('mousedown', this._onTouch);
      this.addEventListener('touchend', this._onRelease);
      this.addEventListener('touchmove', this._onRelease);
      this.addEventListener('touchcancel', this._onRelease);
      this.addEventListener('mouseup', this._onRelease);
      this.addEventListener('mouseout', this._onRelease);
      this.addEventListener('touchleave', this._onRelease);

      this._originalBackgroundColor = this.style.backgroundColor;

      this.tapped = false;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('drag', this._onDrag);
      this.removeEventListener('touchstart', this._onTouch);
      this.removeEventListener('mousedown', this._onTouch);
      this.removeEventListener('touchend', this._onRelease);
      this.removeEventListener('touchmove', this._onRelease);
      this.removeEventListener('touchcancel', this._onRelease);
      this.removeEventListener('mouseup', this._onRelease);
      this.removeEventListener('mouseout', this._onRelease);
      this.removeEventListener('touchleave', this._onRelease);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch() {
      if (this.tapped) {
        return;
      }

      this.tapped = true;

      this.style.transition = this._transition;
      this.style.webkitTransition = this._transition;
      this.style.MozTransition = this._transition;

      if (this._tappable) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        this.style.backgroundColor = this._tapBackgroundColor;
        this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;

      this.style.transition = '';
      this.style.webkitTransition = '';
      this.style.MozTransition = '';

      this.style.backgroundColor = this._originalBackgroundColor || '';
      this.style.boxShadow = '';
    }
  }, {
    key: '_shouldLockOnDrag',
    value: function _shouldLockOnDrag() {
      return this.hasAttribute('lock-on-drag');
    }
  }, {
    key: '_transition',
    get: function get() {
      return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
    }
  }, {
    key: '_tappable',
    get: function get() {
      return this.hasAttribute('tappable');
    }
  }, {
    key: '_tapBackgroundColor',
    get: function get() {
      return this.getAttribute('tap-background-color') || '#d9d9d9';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class', 'ripple'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$6 = 'list';
var scheme$9 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeatコンポーネント[/ja]
 * @guide lists
 *   [en]Using lists[/en]
 *   [ja]リストを使う[/ja]
 * @guide infinite-scroll
 *   [en]Loading more items on infinite scroll[/en]
 *   [ja]Loading more items on infinite scroll[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  function ListElement() {
    classCallCheck(this, ListElement);
    return possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).apply(this, arguments));
  }

  createClass(ListElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the list.[/en]
     *   [ja]リストの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$6);
      ModifierUtil.initModifier(this, scheme$9);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$6)) {
            this.className = defaultClassName$6 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$9);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ListElement;
}(BaseElement);

customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultCheckboxClass = 'checkbox';
var defaultRadioButtonClass = 'radio-button';

var scheme$10 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label',
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark',
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @codepen ojQxLj
 * @tutorial vanilla/Reference/input
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja]フォームを使う[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 * <ons-input type="checkbox" checked></ons-input>
 */

var InputElement = function (_BaseElement) {
  inherits(InputElement, _BaseElement);

  function InputElement() {
    classCallCheck(this, InputElement);
    return possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).apply(this, arguments));
  }

  createClass(InputElement, [{
    key: 'init',


    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using <label for="..."> elements.[/en]
     *  [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
      });

      this._boundOnInput = this._onInput.bind(this);
      this._boundOnFocusin = this._onFocusin.bind(this);
      this._boundDelegateEvent = this._delegateEvent.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this.children.length !== 0) {
        return;
      }

      var helper = document.createElement('span');
      helper.classList.add('_helper');

      var container = document.createElement('label');
      container.appendChild(document.createElement('input'));
      container.appendChild(helper);

      var label = document.createElement('span');
      label.classList.add('input-label');

      util.arrayFrom(this.childNodes).forEach(function (element) {
        return label.appendChild(element);
      });
      this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

      this.appendChild(container);

      switch (this.getAttribute('type')) {
        case 'checkbox':
          this.classList.add(defaultCheckboxClass);
          this._input.classList.add('checkbox__input');
          this._helper.classList.add('checkbox__checkmark');
          this._updateBoundAttributes();
          break;

        case 'radio':
          this.classList.add(defaultRadioButtonClass);
          this._input.classList.add('radio-button__input');
          this._helper.classList.add('radio-button__checkmark');
          this._updateBoundAttributes();
          break;

        default:
          this._input.classList.add('text-input');
          this._helper.classList.add('text-input__label');
          this._input.parentElement.classList.add('text-input__container');

          this._updateLabel();
          this._updateBoundAttributes();
          this._updateLabelClass();
          break;
      }

      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }

      ModifierUtil.initModifier(this, scheme$10);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
          });
          break;
        case 'placeholder':
          return contentReady(this, function () {
            return _this3._updateLabel();
          });
        case 'input-id':
          contentReady(this, function () {
            return _this3._input.id = current;
          });
          break;
        case 'checked':
          this.checked = current !== null;
          break;
        case 'class':
          switch (this.getAttribute('type')) {
            case 'checkbox':
              if (!this.classList.contains(defaultCheckboxClass)) {
                this.className = defaultCheckboxClass + ' ' + current;
              }
              break;
            case 'radio':
              if (!this.classList.contains(defaultRadioButtonClass)) {
                this.className = defaultRadioButtonClass + ' ' + current;
              }
              break;
          }
          break;
      }

      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this3._updateBoundAttributes();
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
          _this4._input.addEventListener('input', _this4._boundOnInput);
          _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
          _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
        }

        _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.removeEventListener('input', _this5._boundOnInput);
        _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
        _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
        _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
      });
    }
  }, {
    key: '_setLabel',
    value: function _setLabel(value) {
      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = value;
      } else {
        this._helper.innerText = value;
      }
    }
  }, {
    key: '_updateLabel',
    value: function _updateLabel() {
      this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this6 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this6.hasAttribute(attr)) {
          _this6._input.setAttribute(attr, _this6.getAttribute(attr));
        } else {
          _this6._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_onInput',
    value: function _onInput(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_onFocusin',
    value: function _onFocusin(event) {
      this._updateLabelClass();
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input');
    }
  }, {
    key: '_helper',
    get: function get() {
      return this.querySelector('._helper');
    }

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this7 = this;

      contentReady(this, function () {
        _this7._input.value = val;
        _this7._onInput();
      });
    }

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'checked',
    get: function get() {
      return this._input.checked;
    },
    set: function set(val) {
      var _this8 = this;

      contentReady(this, function () {
        _this8._input.checked = val;
      });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: '_isTextInput',
    get: function get() {
      return this.type !== 'radio' && this.type !== 'checkbox';
    }
  }, {
    key: 'type',
    get: function get() {
      return this.getAttribute('type');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['class', 'modifier', 'placeholder', 'input-id', 'checked'].concat(INPUT_ATTRIBUTES);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change', 'input', 'focus', 'focusin', 'focusout', 'blur'];
    }
  }]);
  return InputElement;
}(BaseElement);

customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function (_BaseAnimator) {
  inherits(ModalAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ModalAnimator);
    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeModalAnimator);
    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 1
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$11 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var defaultClassName$7 = 'modal';

var _animatorDict$2 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
 *     モーダルが表示されている間はイベント通知が行われません。
 *   [/ja]
 * @guide dialogs
 *   [en]Dialog components[/en]
 *   [ja]Dialog components[/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseElement) {
  inherits(ModalElement, _BaseElement);

  function ModalElement() {
    classCallCheck(this, ModalElement);
    return possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).apply(this, arguments));
  }

  createClass(ModalElement, [{
    key: 'init',


    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
     *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade"を指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._doorLock = new DoorLock();

      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add(defaultClassName$7);

      if (!util.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = function () {
        return undefined;
      };
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'show',


    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja]モーダルを表示します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */
    value: function show() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryShow = function tryShow() {
        var unlock = _this3._doorLock.lock();
        var animator = _this3._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this3, function () {
            _this3.style.display = 'table';
            animator.show(_this3, function () {
              unlock();

              util.propagateAction(_this3, '_show');
              callback();
              resolve(_this3);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          return resolve(tryShow());
        });
      });
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja]モーダルの表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      if (this.visible) {
        return this.hide.apply(this, arguments);
      } else {
        return this.show.apply(this, arguments);
      }
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja]モーダルを非表示にします。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var callback = options.callback || function () {};

      var tryHide = function tryHide() {
        var unlock = _this4._doorLock.lock();
        var animator = _this4._animatorFactory.newAnimator(options);

        return new Promise(function (resolve) {
          contentReady(_this4, function () {
            animator.hide(_this4, function () {
              _this4.style.display = 'none';
              unlock();

              util.propagateAction(_this4, '_hide');
              callback();
              resolve(_this4);
            });
          });
        });
      };

      return new Promise(function (resolve) {
        _this4._doorLock.waitUnlock(function () {
          return resolve(tryHide());
        });
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'class') {
        if (!this.classList.contains(defaultClassName$7)) {
          this.className = defaultClassName$7 + ' ' + current;
        }
      } else if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(handler) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this.style.display !== 'none';
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$2;
    }
  }, {
    key: 'ModalAnimator',
    get: function get() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseElement);

customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorTransitionAnimator = function (_BaseAnimator) {
  inherits(NavigatorTransitionAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorTransitionAnimator(options) {
    classCallCheck(this, NavigatorTransitionAnimator);

    options = util.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (NavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(NavigatorTransitionAnimator)).call(this, options));
  }

  createClass(NavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'block',
    value: function block(page) {
      var blocker = util.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
      page.parentNode.appendChild(blocker);
      return function () {
        return blocker.remove();
      };
    }
  }]);
  return NavigatorTransitionAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSSlideNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');

    return _this;
  }

  createClass(IOSSlideNavigatorTransitionAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

      var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

      return bothPageHasToolbar && noMaterialToolbar;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get$1(IOSSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      contentReady(enterPage, function () {
        var enterPageDecomposition = _this2._decompose(enterPage);
        var leavePageDecomposition = _this2._decompose(leavePage);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var maskClear = Animit(_this2.backgroundMask).saveStyle().queue({
          opacity: 0,
          transform: 'translate3d(0, 0, 0)'
        }).wait(_this2.delay).queue({
          opacity: 0.05
        }, {
          duration: _this2.duration,
          timing: _this2.timing
        }).restoreStyle().queue(function (done) {
          _this2.backgroundMask.remove();
          done();
        });

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPage, leavePage);

        if (shouldAnimateToolbar) {
          // TODO: Remove this fix
          var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
          _this2.backgroundMask.style.top = enterPageToolbarHeight;

          Animit.runAll(maskClear, Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.toolbar).saveStyle().queue({
            css: {
              opacity: 0
            },
            duration: 0
          }).queue({
            css: {
              opacity: 1
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.background).queue({
            css: {
              top: enterPageToolbarHeight
            },
            duration: 0
          }), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(125%, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
            css: { opacity: 0 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 1 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            unblock();
            callback();
            done();
          }), Animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.label + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePageDecomposition.other).saveStyle().queue({
            css: { opacity: 1 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 0 },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle());
        } else {

          Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePage).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            unblock();
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get$1(IOSSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var enterPageDecomposition = this._decompose(enterPage);
      var leavePageDecomposition = this._decompose(leavePage);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var maskClear = Animit(this.backgroundMask).saveStyle().queue({
        opacity: 0.1,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        done();
      });

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

      if (shouldAnimateToolbar) {
        var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
        this.backgroundMask.style.top = enterPageToolbarHeight;

        Animit.runAll(maskClear, Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.label + 'px, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
          css: { opacity: 0 },
          duration: 0
        }).wait(this.delay).queue({
          css: { opacity: 1 },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(leavePageDecomposition.background).queue({
          css: {
            top: enterPageToolbarHeight
          },
          duration: 0
        }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).wait(0).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }), Animit(leavePageDecomposition.toolbar).queue({
          css: {
            opacity: 1
          },
          duration: 0
        }).queue({
          css: {
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.toolbarCenter).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(125%, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.backButtonLabel).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }));
      } else {
        Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(leavePage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }));
      }
    }
  }]);
  return IOSSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSLiftNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get$1(IOSLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get$1(IOSLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function IOSFadeNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSFadeNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (IOSFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get$1(IOSFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(enterPage._getToolbarElement()).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get$1(IOSFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage._getToolbarElement()).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDSlideNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, MDSlideNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
    _this.blackMaskOpacity = 0.4;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get$1(MDSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: 0,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: this.blackMaskOpacity
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(100%, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get$1(MDSlideNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: this.blackMaskOpacity,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(100%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDSlideNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDLiftNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, MDLiftNavigatorTransitionAnimator);

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get$1(MDLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).queue({
        css: {
          opacity: 0.4
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get$1(MDLiftNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0.4
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDLiftNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

  function MDFadeNavigatorTransitionAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease-out' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.25 : _ref$duration;

    classCallCheck(this, MDFadeNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (MDFadeNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get$1(MDFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 42px, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get$1(MDFadeNavigatorTransitionAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(0.15).queue({
        css: {
          transform: 'translate3D(0, 38px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          opacity: 1
        },
        duration: 0
      }).wait(0.04).queue({
        css: {
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDFadeNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
  inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

  function NoneNavigatorTransitionAnimator(options) {
    classCallCheck(this, NoneNavigatorTransitionAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorTransitionAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorTransitionAnimator)).call(this, options));
  }

  createClass(NoneNavigatorTransitionAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorTransitionAnimator;
}(NavigatorTransitionAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$3 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
  },
  'slide-ios': IOSSlideNavigatorTransitionAnimator,
  'slide-md': MDSlideNavigatorTransitionAnimator,
  'lift-ios': IOSLiftNavigatorTransitionAnimator,
  'lift-md': MDLiftNavigatorTransitionAnimator,
  'fade-ios': IOSFadeNavigatorTransitionAnimator,
  'fade-md': MDFadeNavigatorTransitionAnimator,
  'none': NoneNavigatorTransitionAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide multiple-page-navigation
 *   [en]Guide for page navigation[/en]
 *   [ja]ページナビゲーションの概要[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <ons-template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </ons-template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);
    return possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).apply(this, arguments));
  }

  createClass(NavigatorElement, [{
    key: 'init',
    value: function init() {
      this._isRunning = false;
      this._initialized = false;
      this._pageLoader = defaultPageLoader;
      this._pageMap = new WeakMap();

      this._updateAnimatorFactory();
    }

    /**
     * @property pageLoader
     * @type {PageLoader}
     * @description
     *   [en][/en]
     *   [ja]PageLoaderインスタンスを格納しています。[/ja]
     */

  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en][/en]
     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      rewritables.ready(this, function () {
        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
            }
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: NavigatorTransitionAnimator,
        baseClassName: 'NavigatorTransitionAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'animation') {
        this._updateAnimatorFactory();
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Boolean} [options.refresh]
     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      if (!options.refresh) {
        return this._popPage(options, popUpdate);
      } else {
        return this._popPageAndRefresh(options, popUpdate);
      }
    }
  }, {
    key: '_popPageAndRefresh',
    value: function _popPageAndRefresh(options, popUpdate) {
      var _this4 = this;

      var index = this.pages.length - 2;
      var oldPage = this.pages[index];

      if (!this._pageMap.has(oldPage)) {
        throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
      }

      var page = this._pageMap.get(oldPage);

      return new Promise(function (resolve) {
        var options = {
          page: page,
          parent: _this4,
          params: oldPage.pushedOptions ? oldPage.pushedOptions.data : {}
        };

        _this4._pageLoader.load(options, function (pageElement) {
          _this4._pageMap.set(pageElement, page);

          pageElement = util.extend(pageElement, {
            data: oldPage.data,
            pushedOptions: oldPage.pushedOptions || {}
          });

          _this4.insertBefore(pageElement, oldPage ? oldPage : null);
          _this4._pageLoader.unload(oldPage);
          resolve();
        });
      }).then(function () {
        return _this4._popPage(options, popUpdate);
      });
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this5 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this5.pages[length - 1];
        var enterPage = _this5.pages[length - 2];

        options.animation = options.animation || (leavePage.pushedOptions ? leavePage.pushedOptions.animation : undefined);
        options.animationOptions = util.extend({}, leavePage.pushedOptions ? leavePage.pushedOptions.animationOptions : {}, options.animationOptions || {});

        if (options.data) {
          enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        }

        var callback = function callback() {
          update().then(function () {
            _this5._isRunning = false;

            enterPage._show();
            util.triggerElementEvent(_this5, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this5 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          });
        };

        leavePage._hide();
        var animator = _this5._animatorFactory.newAnimator(options);
        animator.pop(_this5.pages[length - 2], _this5.pages[length - 1], callback);
      }).catch(function () {
        return _this5._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
     *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]追加したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        _this6._verifyPageElement(pageElement);
        _this6._pageMap.set(pageElement, page);
        pageElement = util.extend(pageElement, {
          data: options.data
        });
        pageElement.style.visibility = 'hidden';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this6, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this6._pageLoader.load({ page: page, parent: _this6, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this7.pages.length;

        var enterPage = _this7.pages[pageLength - 1];
        var leavePage = options.leavePage || _this7.pages[pageLength - 2];

        if (enterPage.nodeName !== 'ONS-PAGE') {
          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
        }

        enterPage.updateBackButton(pageLength - 1);

        enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this7._isRunning = false;

            setImmediate(function () {
              return enterPage._show();
            });
            util.triggerElementEvent(_this7, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this7 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          };

          enterPage.style.visibility = '';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this7._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]新しいページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this8.pages.length > 1) {
          _this8._pageLoader.unload(_this8.pages[_this8.pages.length - 2]);
        }
        _this8._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]指定したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this9 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this9 }, function (pageElement) {
          _this9._verifyPageElement(pageElement);
          _this9._pageMap.set(pageElement, page);
          pageElement = util.extend(pageElement, {
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this9.getAttribute('animation-options')), options.animationOptions || {});

          _this9.insertBefore(pageElement, _this9.pages[index]);
          _this9.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this9.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation) {
        options.animation = 'none';
      }

      var callback = options.callback;

      options.callback = function () {
        while (_this10.pages.length > 1) {
          _this10._pageLoader.unload(_this10.pages[0]);
        }

        _this10.pages[0].updateBackButton(false);
        callback && callback();
      };

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        throw new Error('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      page.style.visibility = 'hidden';
      page.setAttribute('_skipinit', '');
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (!this._pageMap.has(this.pages[index])) {
          throw Error('This is bug.');
        }

        if (pageName === this._pageMap.get(this.pages[index])) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util.triggerElementEvent(this, 'pre' + name, util.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 書き直す

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util.createElement(internal$1.normalizePageHTML(templateHTML));
      this._verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @param {Element} element
     */

  }, {
    key: '_verifyPageElement',
    value: function _verifyPageElement(element) {
      if (element.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('You must supply an "ons-page" element to "ons-navigator".');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      if (this.topPage) {
        this.topPage._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this.topPage) {
        this.topPage._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pageがpushされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pageがpopされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushされたpageオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]以前のpageオブジェクト。[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]popされて表示されるページのオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]popされて消えるページのオブジェクト。[/ja]
     */

    get: function get() {
      return this._animatorFactory;
    }
  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
     */

  }, {
    key: 'topPage',
    get: function get() {
      return this.pages[this.pages.length - 1] || null;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this.children).filter(function (element) {
        return element.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @property options.refresh
     * @default  false
     * @type {Boolean}
     * @description
     *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
     */

  }, {
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
        throw new Error('"Animator" param must inherit NavigatorElement.NavigatorTransitionAnimator');
      }

      _animatorDict$3[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['animation'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$3;
    }
  }, {
    key: 'NavigatorTransitionAnimator',
    get: function get() {
      return NavigatorTransitionAnimator;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['prepush', 'postpush', 'prepop', 'postpop'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$9 = 'navigation-bar';

var scheme$13 = {
  '': 'navigation-bar--*',
  '.navigation-bar__left': 'navigation-bar--*__left',
  '.navigation-bar__center': 'navigation-bar--*__center',
  '.navigation-bar__right': 'navigation-bar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar[/en]
 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow[/en]
 *   [ja]ツールバーに影を付けずに表示します。[/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);
    return possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).apply(this, arguments));
  }

  createClass(ToolbarElement, [{
    key: 'init',


    /**
     * @attribute inline
     * @initonly
     * @description
     *   [en]Display the toolbar as an inline element.[/en]
     *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
     */

    /**
     * @attribute modifier
     * @description
     *   [en]The appearance of the toolbar.[/en]
     *   [ja]ツールバーの表現を指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$9)) {
            this.className = defaultClassName$9 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$13);
          break;
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$9);
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$13);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('navigation-bar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util.findChild(this, '.navigation-bar__' + name)) {
        var _element = util.findChild(this, '.navigation-bar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util.findChild(this, '.' + name) || util.create('.' + name);
      element.classList.add('navigation-bar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$8 = 'page';
var scheme$12 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

var nullToolbarElement = document.createElement('ons-toolbar'); // requires that 'ons-toolbar' element is registered

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
 * @tutorial vanilla/Reference/page
 * @guide creating-a-page
 *   [en]Setting up a page in its `init` event[/en]
 *   [ja]Setting up a page in its `init` event[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages[/en]
 *   [ja]複数のページを管理する[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  function PageElement() {
    classCallCheck(this, PageElement);
    return possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).apply(this, arguments));
  }

  createClass(PageElement, [{
    key: 'init',


    /**
     * @event init
     * @description
     *   [en]Fired right after the page is attached.[/en]
     *   [ja]ページがアタッチされた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event show
     * @description
     *   [en]Fired right after the page is shown.[/en]
     *   [ja]ページが表示された後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event hide
     * @description
     *   [en]Fired right after the page is hidden.[/en]
     *   [ja]ページが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @event destroy
     * @description
     *   [en]Fired right before the page is destroyed.[/en]
     *   [ja]ページが破棄される前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Specify modifier name to specify custom styles.[/en]
     *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
     */

    /**
     * @attribute on-infinite-scroll
     * @type {String}
     * @description
     *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this.classList.add(defaultClassName$8);
      this._initialized = false;

      contentReady(this, function () {
        _this2._compile();

        _this2._isShown = false;
        _this2._contentElement = _this2._getContentElement();
        _this2._isMuted = _this2.hasAttribute('_muted');
        _this2._skipInit = _this2.hasAttribute('_skipinit');
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      contentReady(this, function () {
        if (!_this3._isMuted) {
          if (_this3._skipInit) {
            _this3.removeAttribute('_skipinit');
          } else {
            setImmediate(function () {
              return util.triggerElementEvent(_this3, 'init');
            });
          }
        }

        if (!util.hasAnyComponentAsParent(_this3)) {
          setImmediate(function () {
            return _this3._show();
          });
        }

        _this3._tryToFillStatusBar();

        if (_this3.hasAttribute('on-infinite-scroll')) {
          _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this4 = this;

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
      });
    }
  }, {
    key: '_hasAPageControlChild',
    value: function _hasAPageControlChild() {
      return util.findChild(this._contentElement, function (e) {
        return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
      });
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_getContentElement',


    /**
     * @return {HTMLElement}
     */
    value: function _getContentElement() {
      var result = util.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__content" element.');
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      if (util.findChild(this, 'ons-toolbar')) {
        return true;
      }
      return !!util.findChild(this._contentElement, function (el) {
        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__background" element.');
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$8)) {
            this.className = defaultClassName$8 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$12);
          break;
        case '_muted':
          this._isMuted = this.hasAttribute('_muted');
          break;
        case '_skipinit':
          this._skipInit = this.hasAttribute('_skipinit');
          break;
        case 'on-infinite-scroll':
          if (current === null) {
            this.onInfiniteScroll = null;
          } else {
            this.onInfiniteScroll = function (done) {
              var f = util.findFromPath(current);
              _this6.onInfiniteScroll = f;
              f(done);
            };
          }
          break;
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this7 = this;

      autoStyle.prepare(this);

      if (util.findChild(this, '.content')) {
        util.findChild(this, '.content').classList.add('page__content');
      }

      if (util.findChild(this, '.background')) {
        util.findChild(this, '.background').classList.add('page__background');
      }

      if (!util.findChild(this, '.page__content')) {
        (function () {
          var content = util.create('.page__content');

          util.arrayFrom(_this7.childNodes).forEach(function (node) {
            if (node.nodeType !== 1 || _this7._elementShouldBeMoved(node)) {
              content.appendChild(node);
            }
          });

          var prevNode = util.findChild(_this7, '.page__background') || util.findChild(_this7, 'ons-toolbar');

          _this7.insertBefore(content, prevNode && prevNode.nextSibling);
        })();
      }

      if (!util.findChild(this, '.page__background')) {
        var background = util.create('.page__background');
        this.insertBefore(background, util.findChild(this, '.page__content'));
      }

      ModifierUtil.initModifier(this, scheme$12);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util.isAttached(this)) {
        this._isShown = true;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'show');
        }

        util.propagateAction(this._contentElement, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;

        if (!this._isMuted) {
          util.triggerElementEvent(this, 'hide');
        }

        util.propagateAction(this._contentElement, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      if (!this._isMuted) {
        util.triggerElementEvent(this, 'destroy');
      }

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util.propagateAction(this._contentElement, '_destroy');

      this.remove();
    }
  }, {
    key: 'name',
    set: function set(str) {
      this.setAttribute('name', str);
    },
    get: function get() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get() {
      return this.querySelector('ons-back-button');
    }
  }, {
    key: 'onInfiniteScroll',
    set: function set(value) {
      var _this8 = this;

      if (value === null) {
        this._onInfiniteScroll = null;
        this._contentElement.removeEventListener('scroll', this._boundOnScroll);
        return;
      }
      if (!(value instanceof Function)) {
        throw new Error('onInfiniteScroll must be a function or null');
      }
      if (!this._onInfiniteScroll) {
        this._infiniteScrollLimit = 0.9;
        this._boundOnScroll = this._onScroll.bind(this);
        setImmediate(function () {
          return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
        });
      }
      this._onInfiniteScroll = value;
    },
    get: function get() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', '_muted', '_skipinit', 'on-infinite-scroll', 'class'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['init', 'show', 'hide', 'destroy'];
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }]);
  return PageElement;
}(BaseElement);

customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function (_BaseAnimator) {
  inherits(PopoverAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, PopoverAnimator);
    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref2) {
      var from = _ref2.from,
          to = _ref2.to,
          options = _ref2.options,
          callback = _ref2.callback,
          _ref2$restore = _ref2.restore,
          restore = _ref2$restore === undefined ? false : _ref2$restore,
          animation = _ref2.animation;

      options = util.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = Animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(this.delay).queue({
        css: to,
        duration: this.duration,
        timing: this.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this2 = this;

      Object.keys(animations).forEach(function (key) {
        return _this2._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}(BaseAnimator);

var fade$1 = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: { animation: fade$1.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.out,
        _popover: { animation: fade$1.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade$1.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$14 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__container': 'popover__container--*',
  '.popover__content': 'popover__content--*',
  '.popover__arrow': 'popover__arrow--*'
};

var defaultClassName$10 = 'popover';

var _animatorDict$4 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide dialogs
 *  [en]Dialog components[/en]
 *  [ja]Dialog components[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseElement) {
  inherits(PopoverElement, _BaseElement);

  function PopoverElement() {
    classCallCheck(this, PopoverElement);
    return possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).apply(this, arguments));
  }

  createClass(PopoverElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._initAnimatorFactory();
      });

      this._doorLock = new DoorLock();
      this._boundOnChange = this._onChange.bind(this);
      this._boundCancel = function () {
        return _this2._cancel();
      };
    }
  }, {
    key: '_initAnimatorFactory',
    value: function _initAnimatorFactory() {
      var factory = new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
      this._animator = function (options) {
        return factory.newAnimator(options);
      };
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          el = this._content,
          margin = this._margin;

      var pos = target.getBoundingClientRect();
      var isMD = util.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');

      var distance = {
        top: pos.top - margin,
        left: pos.left - margin,
        right: window.innerWidth - pos.right - margin,
        bottom: window.innerHeight - pos.bottom - margin
      };

      var _calculateDirections2 = this._calculateDirections(distance),
          vertical = _calculateDirections2.vertical,
          primary = _calculateDirections2.primary,
          secondary = _calculateDirections2.secondary;

      this._popover.classList.add('popover--' + primary);

      var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
      this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
      el.style[primary] = 0;

      var l = vertical ? 'width' : 'height';
      var sizes = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width')),
          height: parseInt(style.getPropertyValue('height'))
        };
      }(window.getComputedStyle(el));

      el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
      this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

      this._setTransformOrigin(distance, sizes, pos, primary);

      // Prevent animit from restoring the style.
      el.removeAttribute('data-animit-orig-style');
    }
  }, {
    key: '_setTransformOrigin',
    value: function _setTransformOrigin(distance, sizes, pos, primary) {
      var calc = function calc(a, o, l) {
        return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
      };
      var x = calc('left', 'right', 'width') + 'px',
          y = calc('top', 'bottom', 'height') + 'px';

      util.extend(this._popover.style, {
        transformOrigin: x + ' ' + y,
        webkitTransformOriginX: x,
        webkitTransformOriginY: y
      });
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this3 = this;

      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
        _this3._popover.classList.remove('popover--' + e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this4 = this;

      setImmediate(function () {
        if (_this4._currentTarget) {
          _this4._positionPopover(_this4._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this.classList.contains('popover')) {
        return;
      }

      this.classList.add(defaultClassName$10);

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = templateSource.cloneNode(true);
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      if (this.hasAttribute('mask-color')) {
        this._mask.style.backgroundColor = this.getAttribute('mask-color');
      }

      ModifierUtil.initModifier(this, scheme$14);
    }
  }, {
    key: '_prepareAnimationOptions',
    value: function _prepareAnimationOptions(options) {
      if (options.animation && !(options.animation in _animatorDict$4)) {
        throw new Error('Animator ' + options.animation + ' is not registered.');
      }

      options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
    }
  }, {
    key: '_executeAction',
    value: function _executeAction(actions) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var callback = options.callback;
      var action = actions.action,
          before = actions.before,
          after = actions.after;


      this._prepareAnimationOptions(options);

      var canceled = false;
      util.triggerElementEvent(this, 'pre' + action, { // synchronous
        popover: this,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this5._doorLock.waitUnlock(function () {
          var unlock = _this5._doorLock.lock();

          before && before();

          contentReady(_this5, function () {
            _this5._animator(options)[action](_this5, function () {
              after && after();

              unlock();

              util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

              callback && callback();
              resolve(_this5);
            });
          });
        });
      });
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Accepts options.target
      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
        options = target;
        target = options.target;
      }

      if (typeof target === 'string') {
        target = document.querySelector(target);
      } else if (target instanceof Event) {
        target = target.target;
      }

      if (typeof target === 'undefined') {
        throw new Error('A target argument must be defined for the popover.');
      }

      if (!(target instanceof HTMLElement)) {
        throw new Error('Invalid target');
      }

      return this._executeAction({
        action: 'show',
        before: function before() {
          _this6.style.display = 'block';
          _this6._currentTarget = target;
          _this6._positionPopover(target);
        }
      }, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja]ポップオーバーを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._executeAction({
        action: 'hide',
        after: function after() {
          _this7.style.display = 'none';
          _this7._clearStyles();
        }
      }, options);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: '_resetBackButtonHandler',
    value: function _resetBackButtonHandler() {
      var _this8 = this;

      // do we need this twice?
      this.onDeviceBackButton = function (e) {
        return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
      };
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this9 = this;

      this._resetBackButtonHandler();

      contentReady(this, function () {
        _this9._margin = _this9._margin || parseInt(window.getComputedStyle(_this9).getPropertyValue('top'));

        // Fix for iframes
        if (!_this9._margin) {
          _this9._margin = 6;
        }

        _this9._radius = parseInt(window.getComputedStyle(_this9._content).getPropertyValue('border-top-left-radius'));

        _this9._mask.addEventListener('click', _this9._boundCancel, false);

        _this9._resetBackButtonHandler();

        window.addEventListener('resize', _this9._boundOnChange, false);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this10 = this;

      contentReady(this, function () {
        _this10._mask.removeEventListener('click', _this10._boundCancel, false);

        _this10._backButtonHandler.destroy();
        _this10._backButtonHandler = null;

        window.removeEventListener('resize', _this10._boundOnChange, false);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$10)) {
            this.className = defaultClassName$10 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$14);
          break;
        case 'direction':
          this._boundOnChange();
          break;
        case 'animation':
          this._initAnimatorFactory();
          break;
      }
    }
  }, {
    key: '_cancel',
    value: function _cancel() {
      var _this11 = this;

      if (this.cancelable) {
        this.hide({
          callback: function callback() {
            util.triggerElementEvent(_this11, 'dialog-cancel');
          }
        });
      }
    }
  }, {
    key: '_mask',


    /**
     * @event preshow
     * @description
     *   [en]Fired just before the popover is displayed.[/en]
     *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being shown.[/en]
     *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
     */

    /**
     * @event postshow
     * @description
     *   [en]Fired just after the popover is displayed.[/en]
     *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event prehide
     * @description
     *   [en]Fired just before the popover is hidden.[/en]
     *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to stop the popover from being hidden.[/en]
     *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
     */

    /**
     * @event posthide
     * @description
     *   [en]Fired just after the popover is hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.popover
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the popover.[/en]
     *  [ja]ポップオーバーの表現を指定します。[/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *  [en]
     *    A space separated list of directions. If more than one direction is specified,
     *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
     *  [/en]
     *  [ja]
     *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
     *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
     *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
     *  [/ja]
     */

    /**
     * @attribute cancelable
     * @description
     *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
     *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
     */

    /**
     * @attribute cover-target
     * @description
     *   [en]If set the popover will cover the target on the screen.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @description
     *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
     *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute mask-color
     * @type {Color}
     * @description
     *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
     *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
     */

    get: function get() {
      return util.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get() {
      return util.findChild(this, '.popover__container');
    }
  }, {
    key: '_content',
    get: function get() {
      return util.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get() {
      return util.findChild(this._popover, '.popover__arrow');
    }
  }, {
    key: 'visible',
    get: function get() {
      return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
    }

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

  }, {
    key: 'cancelable',
    set: function set(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get() {
      return this.hasAttribute('cancelable');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        throw new Error('"Animator" param must inherit PopoverAnimator');
      }
      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'direction', 'animation', 'class'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preshow', 'postshow', 'prehide', 'posthide'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$4;
    }
  }, {
    key: 'PopoverAnimator',
    get: function get() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseElement);

customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$15 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar__primary--*',
  '.progress-bar__secondary': 'progress-bar__secondary--*'
};

var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

/**
 * @element ons-progress-bar
 * @category visual
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);
    return possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).apply(this, arguments));
  }

  createClass(ProgressBarElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util.findChild(this, '.progress-bar');
      }

      this._primary = util.findChild(this._template, '.progress-bar__primary');
      this._secondary = util.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$15);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util.findChild(this, '.progress-bar');

      if (!util.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--indeterminate');
          _this3._template.classList.remove('progress-bar--determinate');
        });
      } else {
        contentReady(this, function () {
          _this3._template.classList.add('progress-bar--determinate');
          _this3._template.classList.remove('progress-bar--indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._primary.style.width = _this4.hasAttribute('value') ? _this4.getAttribute('value') + '%' : '0%';
        _this4._secondary.style.width = _this4.hasAttribute('secondary-value') ? _this4.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$16 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__primary': 'progress-circular__primary--*',
  '.progress-circular__secondary': 'progress-circular__secondary--*'
};

var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);
    return possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).apply(this, arguments));
  }

  createClass(ProgressCircularElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]Change the appearance of the progress indicator.[/en]
     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
     */

    /**
     * @attribute value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute secondary-value
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

    /**
     * @attribute indeterminate
     * @description
     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === 'indeterminate') {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this3 = this;

      if (this.hasAttribute('indeterminate')) {
        contentReady(this, function () {
          _this3._template.classList.add('progress-circular--indeterminate');
          _this3._template.classList.remove('progress-circular--determinate');
        });
      } else {
        contentReady(this, function () {
          _this3._template.classList.add('progress-circular--determinate');
          _this3._template.classList.remove('progress-circular--indeterminate');
        });
      }
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this4 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('value') * 251.32 * 0.01);
          _this4._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this4.getAttribute('secondary-value') * 251.32 * 0.01);
          _this4._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util.findChild(this._template, '.progress-circular__primary');
      this._secondary = util.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      ModifierUtil.initModifier(this, scheme$16);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util.findChild(this, '.progress-circular');

      if (!util.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    },
    get: function get() {
      return this.hasAttribute('indeterminate');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'value', 'secondary-value', 'indeterminate'];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

var removeTransform = function removeTransform(el) {
  el.style.transform = '';
  el.style.WebkitTransform = '';
  el.style.transition = '';
  el.style.WebkitTransition = '';
};

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  function PullHookElement() {
    classCallCheck(this, PullHookElement);
    return possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).apply(this, arguments));
  }

  createClass(PullHookElement, [{
    key: 'init',


    /**
     * @event changestate
     * @description
     *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
     *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.pullHook
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {String} event.state
     *   [en]Current state.[/en]
     *   [ja]現在の状態名を参照できます。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
     *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
     */

    /**
     * @attribute height
     * @type {String}
     * @description
     *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
     *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
     */

    /**
     * @attribute threshold-height
     * @type {String}
     * @description
     *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
     *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
     */

    /**
     * @attribute fixed-content
     * @description
     *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
     *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
     */

    value: function init() {
      this._boundOnDrag = this._onDrag.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnDragEnd = this._onDragEnd.bind(this);
      this._boundOnScroll = this._onScroll.bind(this);

      this._setState(STATE_INITIAL, true);
    }
  }, {
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height;

      this.style.height = height + 'px';
      this.style.lineHeight = height + 'px';
      this.style.marginTop = '-1px';
      this._pageElement.style.marginTop = '-' + height + 'px';
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_generateTranslationTransform',
    value: function _generateTranslationTransform(scroll) {
      return 'translate3d(0px, ' + scroll + 'px, 0px)';
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this2 = this;

      if (this.disabled) {
        return;
      }

      // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
      // there will be no inertial scroll when scrolling down. Allowing default scrolling will
      // kill all 'touchmove' events.
      if (platform.isAndroid()) {
        var element = this._pageElement;
        element.scrollTop = this._startScroll - event.gesture.deltaY;
        if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
          event.gesture.preventDefault();
        }
      }

      if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
        this._transitionDragLength = event.gesture.deltaY;

        var direction = event.gesture.interimDirection;
        if (direction === 'down') {
          this._transitionDragLength -= 1;
        } else {
          this._transitionDragLength += 1;
        }
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

      if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
        event.gesture.stopDetect();

        setImmediate(function () {
          return _this2._finish();
        });
      } else if (scroll >= this.height) {
        this._setState(STATE_PREACTION);
      } else {
        this._setState(STATE_INITIAL);
      }

      // By stopping propagation only of `dragup` and `dragdown`,
      // allowing ancestor elements to detect `dragleft` and `dragright`.
      // If we comment out the following `if` block, `ons-splitter` with `ons-pull-hook` will be broken.
      if (event.gesture.direction === 'up' || event.gesture.direction === 'down') {
        event.stopPropagation();
      }
      this._translateTo(scroll);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      if (this.disabled) {
        return;
      }

      this._startScroll = this._getCurrentScroll();
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      if (this.disabled) {
        return;
      }

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this3 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this3._translateTo(0, { animate: true });
        _this3._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_thresholdHeightEnabled',
    value: function _thresholdHeightEnabled() {
      var th = this.thresholdHeight;
      return th > 0 && th >= this.height;
    }
  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this._getState();

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this._getState()) {
        util.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }
  }, {
    key: '_getState',
    value: function _getState() {
      return this.getAttribute('state');
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_getCurrentScroll',
    value: function _getCurrentScroll() {
      return this._pageElement.scrollTop;
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
     */

  }, {
    key: '_isContentFixed',
    value: function _isContentFixed() {
      return this.hasAttribute('fixed-content');
    }
  }, {
    key: '_getScrollableElement',
    value: function _getScrollableElement() {
      if (this._isContentFixed()) {
        return this;
      } else {
        return this._pageElement;
      }
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      var done = function done() {
        if (scroll === 0) {
          var el = _this4._getScrollableElement();
          removeTransform(el);
        }

        if (options.callback) {
          options.callback();
        }
      };

      this._currentTranslation = scroll;

      if (options.animate) {
        Animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }, {
          duration: 0.3,
          timing: 'cubic-bezier(.1, .7, .1, 1)'
        }).play(done);
      } else {
        Animit(this._getScrollableElement()).queue({
          transform: this._generateTranslationTransform(scroll)
        }).play(done);
      }
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._destroyEventListeners();
      this._createEventListeners();
    }
  }, {
    key: '_createEventListeners',
    value: function _createEventListeners() {
      this._gestureDetector = new GestureDetector(this._pageElement, {
        dragMinDistance: 1,
        dragDistanceCorrection: false,
        dragLockToAxis: !this._dragLockDisabled
      });

      // Bind listeners
      //
      // Note:
      // If we swipe up/down a screen too fast,
      // the gesture detector occasionally dispatches a `dragleft` or `dragright`,
      // so we need to have the pull hook listen to `dragleft` and `dragright` as well as `dragup` and `dragdown`.
      this._gestureDetector.on('dragup dragdown dragleft dragright', this._boundOnDrag);
      this._gestureDetector.on('dragstart', this._boundOnDragStart);
      this._gestureDetector.on('dragend', this._boundOnDragEnd);

      this._pageElement.addEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: '_destroyEventListeners',
    value: function _destroyEventListeners() {
      if (this._gestureDetector) {
        this._gestureDetector.off('dragup dragdown dragleft dragright', this._boundOnDrag);
        this._gestureDetector.off('dragstart', this._boundOnDragStart);
        this._gestureDetector.off('dragend', this._boundOnDragEnd);

        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }

      this._pageElement.removeEventListener('scroll', this._boundOnScroll, false);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._createEventListeners();
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._pageElement.style.marginTop = '';

      this._destroyEventListeners();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height') {
        this._setStyle();
      }
    }
  }, {
    key: 'onAction',
    get: function get() {
      return this._onAction;
    },
    set: function set(value) {
      if (!(value instanceof Function)) {
        throw new Error('Action must be a function.');
      }
      this._onAction = value;
    }
  }, {
    key: 'height',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The height must be an integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set(value) {
      if (!util.isInteger(value)) {
        throw new Error('The threshold height must be an integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get() {
      return this._getState();
    }
  }, {
    key: 'pullDistance',
    get: function get() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['height'];
    }
  }, {
    key: 'STATE_INITIAL',
    get: function get() {
      return STATE_INITIAL;
    }
  }, {
    key: 'STATE_PREACTION',
    get: function get() {
      return STATE_PREACTION;
    }
  }, {
    key: 'STATE_ACTION',
    get: function get() {
      return STATE_ACTION;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['changestate'];
    }
  }]);
  return PullHookElement;
}(BaseElement);

customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            (function () {
              timeout && clearTimeout(timeout);

              var passed = new Date().getTime() - start;
              var k = passed / duration;
              var remaining = newDuration * (1 - k);

              properties.forEach(function (i) {
                el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
              });

              updateStyles();

              start = el.speedUpTime;
              duration = remaining;

              el.style.transitionDuration = duration / 1000 + 's';

              properties.forEach(function (i) {
                el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
              });

              timeout = setTimeout(result.stop, remaining);
            })();
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$11 = 'ripple';

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @guide cross-platform-styling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  function RippleElement() {
    classCallCheck(this, RippleElement);
    return possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).apply(this, arguments));
  }

  createClass(RippleElement, [{
    key: 'init',


    /**
     * @attribute color
     * @type {String}
     * @description
     *   [en]Color of the ripple effect.[/en]
     *   [ja]リップルエフェクトの色を指定します。[/ja]
     */

    /**
     * @attribute background
     * @type {String}
     * @description
     *   [en]Color of the background.[/en]
     *   [ja]背景の色を設定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
     *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        return _this2._compile();
      });

      this._animator = new AnimatorCSS();

      ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
        _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$11);

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util.create('.ripple__wave');
        this._background = util.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x, y, h, w, r;
      var b = this.getBoundingClientRect();
      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;
        r = Math.sqrt(x * x + y * y);
      } else {
        x = (e.clientX || e.changedTouches[0].clientX) - b.left;
        y = (e.clientY || e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);
        r = Math.sqrt(h * h + w * w);
      }
      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR,
          _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this3 = this;

      if (!this.disabled) {
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this4 = this;

      if (this._holding) {
        this._holding.speed(300).then(function () {
          _this4._animator.stopAll({ stopNext: true });
          _this4._animator.fade(_this4._wave);
          _this4._animator.fade(_this4._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;
      this._boundOnTap = this._onTap.bind(this);
      this._boundOnHold = this._onHold.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnRelease = this._onRelease.bind(this);

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._boundOnTap);
        this._parentNode.addEventListener('hold', this._boundOnHold);
        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._boundOnTap);
      pn.removeEventListener('hold', this._boundOnHold);
      pn.removeEventListener('dragstart', this._boundOnDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {

        case 'class':
          if (!this.classList.contains(defaultClassName$11)) {
            this.className = defaultClassName$11 + ' ' + current;
          }
          break;

        case 'start-radius':
          this._minR = Math.max(0, parseFloat(current) || 0);
          break;

        case 'color':
          if (current) {
            contentReady(this, function () {
              _this5._wave.style.background = current;
              if (!_this5.hasAttribute('background')) {
                _this5._background.style.background = current;
              }
            });
          }
          break;

        case 'background':
          if (current || last) {
            if (current === 'none') {
              contentReady(this, function () {
                _this5._background.setAttribute('disabled', 'disabled');
                _this5._background.style.background = 'transparent';
              });
            } else {
              contentReady(this, function () {
                if (_this5._background.hasAttribute('disabled')) {
                  _this5._background.removeAttribute('disabled');
                }
                _this5._background.style.background = current;
              });
            }
          }
          break;

        case 'center':
          if (name === 'center') {
            this._center = current != null && current != 'false';
          }
          break;

      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['start-radius', 'color', 'background', 'center', 'class'];
    }
  }]);
  return RippleElement;
}(BaseElement);

customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
 * @codepen GgujC {wide}
 * @guide layouting
 *   [en]Layouting guide[/en]
 *   [ja]レイアウト調整[/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-colコンポーネント[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$17 = {
  '': 'select-*',
  '.select-input': 'select-input--*'
};

var defaultClassName$12 = 'select';

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];

/**
 * @element ons-select
 * @category form
 * @modifier material
 *  [en]Displays a Material Design select input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a select input.[/en]
 *  [ja][/ja]
 * @description
 *   [en]
 *     Select component. If you want to place a select on a page, use `<ons-select>`.
 *
 *     The component will automatically display as a Material Design select on Android.
 *
 *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、コンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/select
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-select>
 *   <option value="1">1</option>
 *   <option value="2">2nd</option>
 *   <option value="3">3rd option</option>
 * </ons-select>
 */

var SelectElement = function (_BaseElement) {
  inherits(SelectElement, _BaseElement);

  function SelectElement() {
    classCallCheck(this, SelectElement);
    return possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).apply(this, arguments));
  }

  createClass(SelectElement, [{
    key: 'init',


    /**
     * @attribute autofocus
     * @type {Boolean}
     * @default false
     * @description
     *  [en]Element automatically gains focus on page load.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @type {Boolean}
     * @default false
     * @description
     *   [en]Specify if select input should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @attribute form
     * @type {String}
     * @description
     *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @attribute multiple
     * @type {Boolean}
     * @default false
     * @description
     *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute name
     * @type {String}
     * @description
     *   [en]Name the select element, useful for instance if it is part of a form.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @attribute required
     * @type {Boolean}
     * @description
     *   [en]Make the select input required for submitting the form it is part of.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @attribute size
     * @type {Number}
     * @default 1
     * @description
     *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$12)) {
            this.className = defaultClassName$12 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
          break;
      }

      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this3._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this4 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this4.hasAttribute(attr)) {
          _this4._select.setAttribute(attr, _this4.getAttribute(attr));
        } else {
          _this4._select.removeAttribute(attr);
        }
      });
    }

    /**
     * @property length
     * @description
     *   [en]Number of options in the select box.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options
     * @description
     *   [en]Several options for handling the select DOM object.[/en]
     *   [ja][/ja]
     */

    /**
     * @property selectedIndex
     * @description
     *   [en]Index of the currently selected option.[/en]
     *   [ja][/ja]
     */

    /**
     * @property value
     * @description
     *   [en]Value of the currently selected option.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$12);
      var sel = document.createElement('select');
      sel.classList.add('select-input');
      util.arrayFrom(this.childNodes).forEach(function (element) {
        return sel.appendChild(element);
      });
      this.appendChild(sel);

      ModifierUtil.initModifier(this, scheme$17);

      var self = this;
      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value'].forEach(function (key, index, arr) {
        self.__defineGetter__(key, function () {
          return self._select[key];
        });
        self.__defineSetter__(key, function (value) {
          self._select[key] = value;
        });
      });
      this.__defineGetter__('form', function () {
        return self._select['form'];
      });
      this.__defineGetter__('type', function () {
        return self._select['type'];
      });
      this.add = function (option) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        self._select.add(option, index);
      };
      this.remove = function (index) {
        self._select.remove(index);
      };
    }
  }, {
    key: '_select',
    get: function get() {
      return this.querySelector('select');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change'];
    }
  }]);
  return SelectElement;
}(BaseElement);

customElements.define('ons-select', SelectElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$13 = 'fab fab--mini speed-dial__item';

var scheme$18 = {
  '': 'speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignのSpeed dialの子要素を表現する要素です。
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dialコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);
    return possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).apply(this, arguments));
  }

  createClass(SpeedDialItemElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja]このコンポーネントの表現を指定します。[/ja]
     */

    value: function init() {
      this._compile();
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          this._updateClassName(current);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: '_updateClassName',
    value: function _updateClassName(className) {
      var _this2 = this;

      if (!defaultClassName$13.split(/\s+/).every(function (token) {
        return _this2.classList.contains(token);
      })) {
        this.className = defaultClassName$13 + ' ' + className;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this3 = this;

      autoStyle.prepare(this);

      defaultClassName$13.split(/\s+/).forEach(function (token) {
        _this3.classList.add(token);
      });

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$18);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal utility library for manipulating element's style.
 */
var styler = function styler(element, style) {
  return styler.css.apply(styler, arguments);
};

/**
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
styler.css = function (element, styles) {
  var keys = Object.keys(styles);
  keys.forEach(function (key) {
    if (key in element.style) {
      element.style[key] = styles[key];
    } else if (styler._prefix(key) in element.style) {
      element.style[styler._prefix(key)] = styles[key];
    } else {
      console.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
styler._prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
  };
}();

/**
 * @param {Element} element
 */
styler.clear = function (element) {
  styler._clear(element);
};

/**
 * @param {Element} element
 */
styler._clear = function (element) {
  var len = element.style.length;
  var style = element.style;
  var keys = [];
  for (var i = 0; i < len; i++) {
    keys.push(style[i]);
  }

  keys.forEach(function (key) {
    style[key] = '';
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$14 = 'speed-dial';
var scheme$19 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);
    return possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).apply(this, arguments));
  }

  createClass(SpeedDialElement, [{
    key: 'init',


    /**
     * @event open
     * @description
     *   [en]Fired when the menu items are shown.[/en]
     *   [ja][/ja]
     */

    /**
     * @event close
     * @description
     *   [en]Fired when the menu items are hidden.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the component.[/en]
     *   [ja]このコンポーネントの表現を指定します。[/ja]
     */

    /**
     * @attribute position
     * @type {String}
     * @description
     *   [en]
     *     Specify the vertical and horizontal position of the component.
     *     I.e. to display it in the top right corner specify "right top".
     *     Choose from "right", "left", "top" and "bottom".
     *   [/en]
     *   [ja]
     *     この要素を表示する左右と上下の位置を指定します。
     *     例えば、右上に表示する場合には"right top"を指定します。
     *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
     *   [/ja]
     */

    /**
     * @attribute direction
     * @type {String}
     * @description
     *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
     *   [ja]
     *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
     *   [/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]無効化する場合に指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
      });

      this._itemShown = false;
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$14);
      autoStyle.prepare(this);
      this._updateRipple();
      ModifierUtil.initModifier(this, scheme$19);

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$14)) {
            this.className = defaultClassName$14 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$19);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this3._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this3._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this3._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (this.onClick) {
        this.onClick.apply(this);
        return Promise.resolve();
      } else if (!this.disabled && this.visible) {
        return this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        return this.show();
      }
      return Promise.resolve();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (!this.inline) {
        return this.hide();
      }
      return Promise.resolve();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      if (this._fab) {
        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          throw new Error('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dialを表示します。[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this._fab.show();
      return Promise.resolve();
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dialを非表示にします。[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      return this.hideItems().then(function () {
        return _this4._fab.hide();
      });
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dialの子要素を表示します。[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {
      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      var totalDelay = 0;
      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * i;
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = true;
        util.triggerElementEvent(this, 'open');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dialの子要素を非表示にします。[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      var totalDelay = 0;
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * (children.length - i);
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = false;
        util.triggerElementEvent(this, 'close');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      return this.isOpen() ? this.hideItems() : this.showItems();
    }
  }, {
    key: 'items',
    get: function get() {
      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: '_fab',
    get: function get() {
      return util.findChild(this, 'ons-fab');
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      if (value) {
        this.hideItems();
      }
      util.arrayFrom(this.children).forEach(function (e) {
        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
      });

      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]インライン要素の場合に`true`。[/ja]
     */

  }, {
    key: 'inline',
    get: function get() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get() {
      return this._fab.visible && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['class', 'modifier', 'ripple', 'direction', 'position'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['open', 'close'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);
    return possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).apply(this, arguments));
  }

  createClass(SplitterContentElement, [{
    key: 'init',


    /**
     * @attribute page
     * @type {String}
     * @description
     *   [en]
     *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
     *
     *     It is also possible to put `<ons-page>` element as a child of the element.
     *   [/en]
     *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;

      contentReady(this, function () {
        var page = _this2._getPageTarget();

        if (page) {
          _this2.load(page);
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
     */
    value: function load(page) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this3._content || null;

        _this3._pageLoader.load({ page: page, parent: _this3 }, function (pageElement) {
          if (oldContent) {
            _this3._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this3._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._pageLoader.unload(this._content);
      this.remove();
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader');
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);
    return possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).apply(this, arguments));
  }

  createClass(SplitterMaskElement, [{
    key: 'init',
    value: function init() {
      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else if (util.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator = function (_BaseAnimator) {
  inherits(SplitterAnimator, _BaseAnimator);

  function SplitterAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, SplitterAnimator);
    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util.extend(this, {
        timing: this.timing, duration: this.duration, delay: this.delay
      }, options);
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this2 = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this2._side = sideElement;
        _this2._content = splitter.content;
        _this2._mask = splitter.mask;
      });
    }
  }, {
    key: 'inactivate',
    value: function inactivate() {
      this._content = this._side = this._mask = null;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      Animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this.duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        _this3._side.style.webkitTransition = '';
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        opacity: '0'
      }, {
        duration: this.duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }, {
    key: 'minus',
    get: function get() {
      return this._side._side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$5 = {
  default: SplitterAnimator,
  overlay: SplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);
    return possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).apply(this, arguments));
  }

  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util.findChild(this, function (e) {
        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        _this3.content.style[side.side] = side.mode === 'split' ? side._width : 0;
      });
    }
  }, {
    key: 'init',
    value: function init() {
      var _this4 = this;

      this._boundOnModeChange = this._onModeChange.bind(this);

      contentReady(this, function () {
        _this4._compile();
        _this4._layout();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (!this.mask) {
        this.appendChild(document.createElement('ons-splitter-mask'));
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._boundOnModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util.propagateAction(this, '_destroy');
      this.remove();
    }
  }, {
    key: 'left',
    get: function get() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get() {
      return this._getSide('right');
    }

    /**
     * @property side
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'side',
    get: function get() {
      return util.findChild(this, 'ons-splitter-side');
    }
  }, {
    key: '_sides',
    get: function get() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get() {
      return util.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'mask',
    get: function get() {
      return util.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get() {
      return this._backButtonHandler;
    },
    set: function set(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        throw new Error('Animator parameter must be an instance of SplitterAnimator.');
      }
      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$5;
    }
  }]);
  return SplitterElement;
}(BaseElement);

customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var WATCHED_ATTRIBUTES = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold'];

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._boundOnChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._boundOnChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._boundOnChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._boundOnChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._boundOnChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

var widthToPx = function widthToPx(width, parent) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(parent.offsetWidth * value / 100);
};

var CollapseMode = function () {
  createClass(CollapseMode, [{
    key: '_animator',
    get: function get() {
      return this._element._animator;
    }
  }]);

  function CollapseMode(element) {
    classCallCheck(this, CollapseMode);

    this._active = false;
    this._state = CLOSED_STATE;
    this._element = element;
    this._lock = new DoorLock();
  }

  createClass(CollapseMode, [{
    key: 'isOpen',
    value: function isOpen() {
      return this._active && this._state !== CLOSED_STATE;
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
        return;
      }
      if (e.type === 'dragstart') {
        this._onDragStart(e);
      } else if (!this._ignoreDrag) {
        e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var scrolling = !/left|right/.test(event.gesture.direction);
      var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      var area = this._element._swipeTargetWidth;
      var isOpen = this.isOpen();
      this._ignoreDrag = scrolling || area && distance > area && !isOpen;

      this._width = widthToPx(this._element._width, this._element.parentNode);
      this._startDistance = this._distance = isOpen ? this._width : 0;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      event.gesture.preventDefault();
      var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._animator.translate(distance);
        this._distance = distance;
        this._state = CHANGING_STATE;
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      var distance = this._distance,
          width = this._width,
          el = this._element;

      var direction = event.gesture.interimDirection;
      var shouldOpen = el._side !== direction && distance > width * el._threshold;
      this.executeAction(shouldOpen ? 'open' : 'close');
      this._ignoreDrag = true;
    }
  }, {
    key: 'layout',
    value: function layout() {
      if (this._active && this._state === OPEN_STATE) {
        this._animator.open();
      }
    }

    // enter collapse mode

  }, {
    key: 'enterMode',
    value: function enterMode() {
      if (!this._active) {
        this._active = true;
        this.layout();
      }
    }

    // exit collapse mode

  }, {
    key: 'exitMode',
    value: function exitMode() {
      this._active = false;
    }
  }, {
    key: '_isOpenOtherSideMenu',
    value: function _isOpenOtherSideMenu() {
      var _this = this;

      return util.arrayFrom(this._element.parentElement.children).some(function (e) {
        return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
      });
    }

    /**
     * @param {String} name - 'open' or 'close'
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @param {Boolean} [options.withoutAnimation]
     * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
     */

  }, {
    key: 'executeAction',
    value: function executeAction(name) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

      if (!this._active) {
        return Promise.resolve(false);
      }

      if (this._state === FINAL_STATE) {
        return Promise.resolve(this._element);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Splitter side is locked.');
      }
      if (name === 'open' && this._isOpenOtherSideMenu()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._element._emitEvent('pre' + name)) {
        return Promise.reject('Canceled in pre' + name + ' event.');
      }

      var callback = options.callback;
      var unlock = this._lock.lock();
      var done = function done() {
        _this2._state = FINAL_STATE;
        _this2.layout();
        unlock();
        _this2._element._emitEvent('post' + name);
        callback && callback();
      };

      if (options.withoutAnimation) {
        done();
        return Promise.resolve(this._element);
      }
      this._state = CHANGING_STATE;
      return new Promise(function (resolve) {
        _this2._animator[name](function () {
          done();
          resolve(_this2._element);
        });
      });
    }
  }]);
  return CollapseMode;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */


var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);
    return possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).apply(this, arguments));
  }

  createClass(SplitterSideElement, [{
    key: 'init',


    /**
     * @event modechange
     * @description
     *   [en]Fired just after the component's mode changes.[/en]
     *   [ja]この要素のモードが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {String} event.mode
     *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
     *   [ja]現在のモードを返します。[/ja]
     */

    /**
     * @event preopen
     * @description
     *   [en]Fired just before the sliding menu is opened.[/en]
     *   [ja]スライディングメニューが開く前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding menu.[/en]
     *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event postopen
     * @description
     *   [en]Fired just after the sliding menu is opened.[/en]
     *   [ja]スライディングメニューが開いた後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @event preclose
     * @description
     *   [en]Fired just before the sliding menu is closed.[/en]
     *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call to cancel opening sliding-menu.[/en]
     *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
     */

    /**
     * @event postclose
     * @description
     *   [en]Fired just after the sliding menu is closed.[/en]
     *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Object} event.side
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default  default
     * @description
     *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
     *  [ja]アニメーションを指定します。"overlay", "default"のいずれかを指定できます。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute open-threshold
     * @type {Number}
     * @default  0.3
     * @description
     *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
     *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
     */

    /**
     * @attribute collapse
     * @type {String}
     * @description
     *   [en]
     *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
     *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
     *     If the value is a media query, the view will collapse when the media query resolves to `true`.
     *     If the value is not defined, the view always be in `"collapse"` mode.
     *   [/en]
     *   [ja]
     *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
     *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
     *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
     *     値に何も指定しない場合には、常にcollapseモードになります。
     *   [/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
     */

    /**
     * @attribute width
     * @type {String}
     * @description
     *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
     *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
     */

    /**
     * @attribute side
     * @type {String}
     * @default left
     * @description
     *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
     *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
     */

    /**
     * @attribute mode
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
     *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
     */

    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The URL of the menu page.[/en]
     *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Whether to enable swipe interaction on collapse mode.[/en]
     *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
     */

    value: function init() {
      var _this4 = this;

      this._page = null;
      this._pageLoader = defaultPageLoader;
      this._collapseMode = new CollapseMode(this);
      this._collapseDetection = new CollapseDetection(this);

      this._animatorFactory = new AnimatorFactory({
        animators: SplitterElement.animators,
        baseClass: SplitterAnimator,
        baseClassName: 'SplitterAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
      this._boundHandleGesture = function (e) {
        return _this4._collapseMode.handleGesture(e);
      };
      this._watchedAttributes = WATCHED_ATTRIBUTES;
      contentReady(this, function () {
        rewritables$2.ready(_this4, function () {
          var page = _this4._getPageTarget();

          if (page) {
            _this4.load(page);
          }
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('Parent must be an ons-splitter element.');
      }

      this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

      contentReady(this, function () {
        _this5._watchedAttributes.forEach(function (e) {
          return _this5._update(e);
        });
      });

      if (!this.hasAttribute('side')) {
        this.setAttribute('side', 'left');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._collapseDetection.disable();
      this._gestureDetector.dispose();
      this._gestureDetector = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._update(name, current);
    }
  }, {
    key: '_update',
    value: function _update(name, value) {
      name = '_update' + name.split('-').map(function (e) {
        return e[0].toUpperCase() + e.slice(1);
      }).join('');
      return this[name](value);
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }

    // readonly attribute for the users

  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
        this.setAttribute('mode', mode);

        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateOpenThreshold',
    value: function _updateOpenThreshold() {
      var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('open-threshold');

      this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
    }
  }, {
    key: '_updateSwipeable',
    value: function _updateSwipeable() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipeable');

      var action = swipeable === null ? 'off' : 'on';

      if (this._gestureDetector) {
        this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
      }
    }
  }, {
    key: '_updateSwipeTargetWidth',
    value: function _updateSwipeTargetWidth() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('swipe-target-width');

      this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      this.style.width = this._width;
    }
  }, {
    key: '_updateSide',
    value: function _updateSide() {
      var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('side');

      this._side = side === 'right' ? side : 'left';
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      this._animator = this._animatorFactory.newAnimator({ animation: animation });
      this._animator.activate(this);
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('open', options);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._collapseMode.executeAction('close', options);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.isOpen ? this.close(options) : this.open(options);
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this6._content || null;

        _this6._pageLoader.load({ page: page, parent: _this6 }, function (pageElement) {
          if (oldContent) {
            _this6._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this6._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._pageLoader.unload(this._content);
      this.remove();
    }
  }, {
    key: 'side',
    get: function get() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: '_width',
    get: function get() {
      var width = this.getAttribute('width');
      return (/^\d+(px|%)$/.test(width) ? width : '80%'
      );
    },
    set: function set(value) {
      this.setAttribute('width', value);
    }
  }, {
    key: 'page',
    get: function get() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get() {
      return this._pageLoader;
    },
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get() {
      return this._mode;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open..[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get() {
      return this._collapseMode.isOpen();
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return WATCHED_ATTRIBUTES;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$15 = 'switch';

var scheme$20 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja]スイッチを表示するコンポーネントです。[/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide adding-page-content
 *   [en]Using form components[/en]
 *   [ja]フォームを使う[/ja]
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseElement) {
  inherits(SwitchElement, _BaseElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);
    return possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).apply(this, arguments));
  }

  createClass(SwitchElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this._checked = false;
      this._disabled = false;

      this._boundOnChange = this._onChange.bind(this);

      contentReady(this, function () {
        _this2._compile();
        ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
          _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
        });
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$15);

      if (!(util.findChild(this, '.switch__input') && util.findChild(this, '.switch__toggle'))) {
        this.appendChild(template$2.cloneNode(true));
      }

      ModifierUtil.initModifier(this, scheme$20);

      this._checkbox = this.querySelector('.switch__input');
      this._handle = this.querySelector('.switch__handle');

      this._checkbox.checked = this._checked;
      this._checkbox.disabled = this._disabled;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._checkbox.removeEventListener('change', _this3._boundOnChange);
        _this3.removeEventListener('dragstart', _this3._onDragStart);
        _this3.removeEventListener('hold', _this3._onHold);
        _this3.removeEventListener('tap', _this3.click);
        _this3.removeEventListener('click', _this3._onClick);
        if (_this3._gestureDetector) {
          _this3._gestureDetector.dispose();
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._checkbox.addEventListener('change', _this4._boundOnChange);
        _this4.addEventListener('dragstart', _this4._onDragStart);
        _this4.addEventListener('hold', _this4._onHold);
        _this4.addEventListener('tap', _this4.click);
        _this4.addEventListener('click', _this4._onClick);
        _this4._gestureDetector = new GestureDetector(_this4, { dragMinDistance: 1, holdTimeout: 251 });
        _this4._boundOnRelease = _this4._onRelease.bind(_this4);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }
      this.click();
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains('switch__touch')) {
        ev.preventDefault();
      }
    }
  }, {
    key: 'click',
    value: function click() {
      if (!this._disabled) {
        this.checked = !this.checked;

        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }
    }
  }, {
    key: '_getPosition',
    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this.classList.add('switch--active');
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        this.classList.remove('switch--active');
        return;
      }

      e.stopPropagation();

      this.classList.add('switch--active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.gesture.srcEvent.preventDefault();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        util.triggerElementEvent(this, 'change', {
          value: this.checked,
          switch: this,
          isInteractive: true
        });
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._boundOnRelease);

      this._handle.style.left = '';
      this.classList.remove('switch--active');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      contentReady(this, function () {
        switch (name) {
          case 'class':
            if (!_this5.classList.contains(defaultClassName$15)) {
              _this5.className = defaultClassName$15 + ' ' + current;
            }
            break;

          case 'modifier':
            _this5._isMaterial = (current || '').indexOf('material') !== -1;
            _this5._locations = locations[_this5._isMaterial ? 'material' : 'ios'];
            ModifierUtil.onModifierChanged(last, current, _this5, scheme$20);
            break;

          case 'input-id':
            _this5._checkbox.id = current;
            break;

          case 'checked':
            _this5._checked = current !== null;
            _this5._checkbox.checked = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
            break;

          case 'disabled':
            _this5._disabled = current !== null;
            _this5._checkbox.disabled = current !== null;
            util.toggleAttribute(_this5._checkbox, name, current !== null);
        }
      });
    }
  }, {
    key: 'checked',


    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFFが変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja]現在の値を返します。[/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja]スイッチの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]スイッチがONの場合に`true`。[/ja]
     */

    get: function get() {
      return this._checked;
    },
    set: function set(value) {
      this._checked = !!value;
      util.toggleAttribute(this, 'checked', this._checked);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get() {
      return this._disabled;
    },
    set: function set(value) {
      this._disabled = !!value;
      util.toggleAttribute(this, 'disabled', this._disabled);
      this._checkbox.disabled = this._disabled;
    }

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
     */

  }, {
    key: 'checkbox',
    get: function get() {
      return this._checkbox;
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'input-id', 'checked', 'disabled', 'class'];
    }
  }, {
    key: 'events',
    get: function get() {
      return ['change'];
    }
  }]);
  return SwitchElement;
}(BaseElement);

customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var TabbarAnimator = function (_BaseAnimator) {
  inherits(TabbarAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function TabbarAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, TabbarAnimator);
    return possibleConstructorReturn(this, (TabbarAnimator.__proto__ || Object.getPrototypeOf(TabbarAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  /**
   * @param {Element} enterPage ons-page element
   * @param {Element} leavePage ons-page element
   * @param {Number} enterPageIndex
   * @param {Number} leavePageIndex
   * @param {Function} done
   */


  createClass(TabbarAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      throw new Error('This method must be implemented.');
    }
  }]);
  return TabbarAnimator;
}(BaseAnimator);

var TabbarNoneAnimator = function (_TabbarAnimator) {
  inherits(TabbarNoneAnimator, _TabbarAnimator);

  function TabbarNoneAnimator() {
    classCallCheck(this, TabbarNoneAnimator);
    return possibleConstructorReturn(this, (TabbarNoneAnimator.__proto__ || Object.getPrototypeOf(TabbarNoneAnimator)).apply(this, arguments));
  }

  createClass(TabbarNoneAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      setTimeout(done, 1000 / 60);
    }
  }]);
  return TabbarNoneAnimator;
}(TabbarAnimator);

var TabbarFadeAnimator = function (_TabbarAnimator2) {
  inherits(TabbarFadeAnimator, _TabbarAnimator2);

  function TabbarFadeAnimator() {
    classCallCheck(this, TabbarFadeAnimator);
    return possibleConstructorReturn(this, (TabbarFadeAnimator.__proto__ || Object.getPrototypeOf(TabbarFadeAnimator)).apply(this, arguments));
  }

  createClass(TabbarFadeAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
      Animit.runAll(Animit(enterPage).saveStyle().queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), Animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 1
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)',
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarFadeAnimator;
}(TabbarAnimator);

var TabbarSlideAnimator = function (_TabbarAnimator3) {
  inherits(TabbarSlideAnimator, _TabbarAnimator3);

  function TabbarSlideAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.15 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, TabbarSlideAnimator);
    return possibleConstructorReturn(this, (TabbarSlideAnimator.__proto__ || Object.getPrototypeOf(TabbarSlideAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  /**
   * @param {jqLite} enterPage
   * @param {jqLite} leavePage
   */


  createClass(TabbarSlideAnimator, [{
    key: 'apply',
    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
      var sgn = enterIndex > leaveIndex;

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(0, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (callback) {
        done();
        callback();
      }), Animit(leavePage).queue({
        transform: 'translate3D(0, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return TabbarSlideAnimator;
}(TabbarAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$22 = {
  '.tab-bar__content': 'tab-bar--*__content',
  '.tab-bar': 'tab-bar--*'
};

var _animatorDict$6 = {
  'default': TabbarNoneAnimator,
  'fade': TabbarFadeAnimator,
  'slide': TabbarSlideAnimator,
  'none': TabbarNoneAnimator
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-tabbar-gen-' + i++;
  };
}();

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *  [en]Managing multiple pages.[/en]
 *  [ja]Managing multiple pages[/ja]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tabコンポーネント[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  function TabbarElement() {
    classCallCheck(this, TabbarElement);
    return possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).apply(this, arguments));
  }

  createClass(TabbarElement, [{
    key: 'init',


    /**
     * @event prechange
     * @description
     *   [en]Fires just before the tab is changed.[/en]
     *   [ja]アクティブなタブが変わる前に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the change event.[/en]
     *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
     */

    /**
     * @event postchange
     * @description
     *   [en]Fires just after the tab is changed.[/en]
     *   [ja]アクティブなタブが変わった後に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     */

    /**
     * @event reactive
     * @description
     *   [en]Fires if the already open tab is tapped again.[/en]
     *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Number} event.index
     *   [en]Current index.[/en]
     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
     * @param {Object} event.tabItem
     *   [en]Tab item object.[/en]
     *   [ja]tabItemオブジェクト。[/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default none
     * @description
     *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
     *   [ja]ページ読み込み時のアニメーションを指定します。"none"、"fade"、"slide"のいずれかを選択できます。デフォルトは"none"です。[/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
     */

    /**
     * @attribute position
     * @initonly
     * @type {String}
     * @default bottom
     * @description
     *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
     *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
     */

    value: function init() {
      var _this2 = this;

      this._tabbarId = generateId$1();

      contentReady(this, function () {
        _this2._compile();

        var content = _this2._contentElement;
        for (var i = 0; i < content.children.length; i++) {
          content.children[i].style.display = 'none';
        }

        var activeIndex = _this2.getAttribute('activeIndex');

        var tabbar = _this2._tabbarElement;
        if (activeIndex && tabbar.children.length > activeIndex) {
          tabbar.children[activeIndex].setAttribute('active', 'true');
        }

        autoStyle.prepare(_this2);
        ModifierUtil.initModifier(_this2, scheme$22);

        _this2._animatorFactory = new AnimatorFactory({
          animators: _animatorDict$6,
          baseClass: TabbarAnimator,
          baseClassName: 'TabbarAnimator',
          defaultAnimation: _this2.getAttribute('animation')
        });
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        return _this3._updatePosition();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      if (this._contentElement && this._tabbarElement) {
        var content = util.findChild(this, '.tab-bar__content');
        var bar = util.findChild(this, '.tab-bar');

        content.classList.add('ons-tab-bar__content');
        bar.classList.add('ons-tab-bar__footer');
      } else {

        var _content = util.create('.ons-tab-bar__content.tab-bar__content');
        var tabbar = util.create('.tab-bar.ons-tab-bar__footer');

        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }

        this.appendChild(_content);
        this.appendChild(tabbar);
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this4 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
      var action = top ? util.addModifier : util.removeModifier;

      action(this, 'top');

      var page = util.findParent(this, 'ons-page');
      if (page) {
        this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

        if (util.match(page.firstChild, 'ons-toolbar')) {
          action(page.firstChild, 'noshadow');
        }
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this4, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this4, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: '_getTabbarElement',
    value: function _getTabbarElement() {
      return util.findChild(this, '.tab-bar');
    }

    /**
     * @method loadPage
     * @deprecated
     * @signature loadPage(url, [options])
     * @param {String} url
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageのURLか、もしくはons-templateで宣言したid属性の値を利用できます。[/ja]
     * @description
     *   [en]Displays a new page without changing the active index.[/en]
     *   [ja]現在のアクティブなインデックスを変更せずに、新しいページを表示します。[/ja]
     * @param {Object} [options]
     *   [en][/en]
     *   [ja][/ja]
     * @param {Object} [options.animation]
     *   [en][/en]
     *   [ja][/ja]
     * @param {Object} [options.callback]
     *   [en][/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'loadPage',
    value: function loadPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      console.warn('The loadPage method has been deprecated and will be removed in the next minor version.');

      return new Promise(function (resolve) {
        var tab = _this5._tabbarElement.children[0] || new TabElement();
        tab._loadPage(page, _this5._contentElement, function (pageElement) {
          resolve(_this5._loadPageDOMAsync(pageElement, options));
        });
      });
    }

    /**
     * @param {Element} pageElement
     * @param {Object} [options]
     * @param {Object} [options.animation]
     * @param {Object} [options.callback]
     * @return {Promise} Resolves to the new page element.
     */

  }, {
    key: '_loadPageDOMAsync',
    value: function _loadPageDOMAsync(pageElement) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return new Promise(function (resolve) {
        _this6._contentElement.appendChild(pageElement);

        if (_this6.getActiveTabIndex() !== -1) {
          resolve(_this6._switchPage(pageElement, options));
        } else {
          if (options.callback instanceof Function) {
            options.callback();
          }

          _this6._oldPageElement = pageElement;
          resolve(pageElement);
        }
      });
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getTabbarId',
    value: function getTabbarId() {
      return this._tabbarId;
    }

    /**
     * @return {Element/null}
     */

  }, {
    key: '_getCurrentPageElement',
    value: function _getCurrentPageElement() {
      var pages = this._contentElement.children;
      var page = null;
      for (var i = 0; i < pages.length; i++) {
        if (pages[i].style.display !== 'none') {
          page = pages[i];
          break;
        }
      }

      if (page && page.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('Invalid state: page element must be a "ons-page" element.');
      }

      return page;
    }
  }, {
    key: '_switchPage',


    /**
     * @param {Element} element
     * @param {Object} options
     * @param {String} [options.animation]
     * @param {Function} [options.callback]
     * @param {Object} [options.animationOptions]
     * @param {Number} options.selectedTabIndex
     * @param {Number} options.previousTabIndex
     * @return {Promise} Resolves to the new page element.
     */
    value: function _switchPage(element, options) {
      var oldPageElement = this._oldPageElement || internal$1.nullElement;
      this._oldPageElement = element;
      var animator = this._animatorFactory.newAnimator(options);

      return new Promise(function (resolve) {
        if (oldPageElement !== internal$1.nullElement) {
          oldPageElement._hide();
        }

        animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
          if (oldPageElement !== internal$1.nullElement) {
            oldPageElement.style.display = 'none';
          }

          element.style.display = 'block';
          element._show();

          if (options.callback instanceof Function) {
            options.callback();
          }

          resolve(element);
        });
      });
    }

    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja]タブのインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Boolean} [options.keepPage]
     *   [en]If true the page will not be changed.[/en]
     *   [ja]タブバーが現在表示しているpageを変えない場合にはtrueを指定します。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。`"fade"`、`"slide"`、`"none"`のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveTab',
    value: function setActiveTab(index) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      if (!options.animation && this.hasAttribute('animation')) {
        options.animation = this.getAttribute('animation');
      }

      var previousTab = this._getActiveTabElement(),
          selectedTab = this._getTabElement(index),
          previousTabIndex = this.getActiveTabIndex(),
          selectedTabIndex = index,
          previousPageElement = this._getCurrentPageElement();

      if (!selectedTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (selectedTabIndex === previousTabIndex) {
        util.triggerElementEvent(this, 'reactive', {
          index: selectedTabIndex,
          tabItem: selectedTab
        });

        return Promise.resolve(previousPageElement);
      }

      var canceled = false;

      util.triggerElementEvent(this, 'prechange', {
        index: selectedTabIndex,
        tabItem: selectedTab,
        cancel: function cancel() {
          return canceled = true;
        }
      });

      if (canceled) {
        selectedTab.setInactive();
        if (previousTab) {
          previousTab.setActive();
        }
        return Promise.reject('Canceled in prechange event.');
      }

      selectedTab.setActive();

      var params = _extends({}, options, {
        previousTabIndex: previousTabIndex,
        selectedTabIndex: selectedTabIndex
      });

      if (previousTab) {
        previousTab.setInactive();
      } else {
        params.animation = 'none';
      }

      return new Promise(function (resolve) {
        selectedTab._loadPageElement(_this7._contentElement, function (pageElement) {
          pageElement.removeAttribute('style');

          _this7._switchPage(pageElement, params).then(function (page) {
            util.triggerElementEvent(_this7, 'postchange', {
              index: selectedTabIndex,
              tabItem: selectedTab
            });

            return resolve(page);
          });
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
      this._getTabbarElement().style.display = visible ? '' : 'none';
    }
  }, {
    key: 'show',
    value: function show() {
      this.setTabbarVisibility(true);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setTabbarVisibility(false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the tabbar is visible or not.[/en]
     *   [ja]タブバーが見える場合に`true`。[/ja]
     */

  }, {
    key: 'getActiveTabIndex',


    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
     */
    value: function getActiveTabIndex() {
      var tabs = this._getTabbarElement().children;

      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i] instanceof TabElement && tabs[i].isActive && tabs[i].isActive()) {
          return i;
        }
      }

      return -1;
    }

    /**
     * @return {Number} When active tab is not found, returns -1.
     */

  }, {
    key: '_getActiveTabElement',
    value: function _getActiveTabElement() {
      return this._getTabElement(this.getActiveTabIndex());
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_getTabElement',
    value: function _getTabElement(index) {
      return this._getTabbarElement().children[index];
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: '_show',
    value: function _show() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var currentPageElement = this._getCurrentPageElement();
      if (currentPageElement) {
        currentPageElement._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      var tabs = this._getTabbarElement().children;
      for (var i = tabs.length - 1; i >= 0; i--) {
        tabs[i].remove();
      }
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
      }
    }
  }, {
    key: '_contentElement',
    get: function get() {
      return util.findChild(this, '.tab-bar__content');
    }
  }, {
    key: '_tabbarElement',
    get: function get() {
      return util.findChild(this, '.tab-bar');
    }
  }, {
    key: 'pages',
    get: function get() {
      return util.arrayFrom(this._contentElement.children);
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._getTabbarElement().style.display !== 'none';
    }
  }], [{
    key: 'registerAnimator',


    /**
     * @param {String} name
     * @param {Function} Animator
     */
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof TabbarAnimator)) {
        throw new Error('"Animator" param must inherit TabbarElement.TabbarAnimator');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'];
    }
  }, {
    key: 'rewritables',
    get: function get() {
      return rewritables$3;
    }
  }, {
    key: 'TabbarAnimator',
    get: function get() {
      return TabbarAnimator;
    }
  }, {
    key: 'events',
    get: function get() {
      return ['prechange', 'postchange', 'reactive'];
    }
  }, {
    key: 'animators',
    get: function get() {
      return _animatorDict$6;
    }
  }]);
  return TabbarElement;
}(BaseElement);

customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$16 = 'tab-bar__item';

var scheme$21 = {
  '': 'tab-bar--*__item',
  '.tab-bar__button': 'tab-bar--*__button'
};

var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button"></button>\n  </div>\n');

var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n    <div class="tab-bar__badge notification">1</div>\n  </div>\n');

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide multiple-page-navigation
 *   [en]Managing multiple pages.[/en]
 *   [ja]Managing multiple pages[/ja]]
 * @guide templates
 *   [en]Defining multiple pages in single html[/en]
 *   [ja]複数のページを1つのHTMLに記述する[/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbarコンポーネント[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  function TabElement() {
    classCallCheck(this, TabElement);
    return possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).apply(this, arguments));
  }

  createClass(TabElement, [{
    key: 'init',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]The page that is displayed when the tab is tapped.[/en]
     *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
     */

    /**
     * @attribute icon
     * @type {String}
     * @description
     *   [en]
     *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
     *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
     *   [/en]
     *   [ja]
     *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
     *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
     *   [/ja]
     */

    /**
     * @attribute active-icon
     * @type {String}
     * @description
     *   [en]The name of the icon when the tab is active.[/en]
     *   [ja]アクティブの際のアイコン名を指定します。[/ja]
     */

    /**
     * @attribute label
     * @type {String}
     * @description
     *   [en]The label of the tab item.[/en]
     *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
     */

    /**
     * @attribute badge
     * @type {String}
     * @description
     *   [en]Display a notification badge on top of the tab.[/en]
     *   [ja]バッジに表示する内容を指定します。[/ja]
     */

    /**
     * @attribute active
     * @description
     *   [en]This attribute should be set to the tab that is active by default.[/en]
     *   [ja][/ja]
     */

    value: function init() {
      var _this2 = this;

      this._pageLoader = defaultPageLoader;
      this._page = null;

      if (this.hasAttribute('label') || this.hasAttribute('icon') || this.hasAttribute('badge')) {
        this._compile();
      } else {
        contentReady(this, function () {
          _this2._compile();
        });
      }

      this._boundOnClick = this._onClick.bind(this);
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this.page || this.getAttribute('page');
    }
  }, {
    key: '_templateLoaded',
    value: function _templateLoaded() {
      if (this.children.length == 0) {
        return false;
      }

      var hasInput = this.children[0].getAttribute('type') === 'radio';
      var hasButton = util.findChild(this, '.tab-bar__button');

      return hasInput && hasButton;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$16);

      if (!this._templateLoaded()) {
        var fragment = document.createDocumentFragment();
        var hasChildren = false;

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          fragment.appendChild(node);

          if (node.nodeType == Node.ELEMENT_NODE) {
            hasChildren = true;
          }
        }

        var template = templateSource$1.cloneNode(true);
        while (template.children[0]) {
          this.appendChild(template.children[0]);
        }

        var button = util.findChild(this, '.tab-bar__button');

        if (hasChildren) {
          button.appendChild(fragment);
          this._hasDefaultTemplate = false;
        } else {
          this._hasDefaultTemplate = true;
          this._updateDefaultTemplate();
        }
      }

      ModifierUtil.initModifier(this, scheme$21);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      // util.updateRipple(this.querySelector('.tab-bar__button'), this);
    }
  }, {
    key: '_updateDefaultTemplate',
    value: function _updateDefaultTemplate() {
      if (!this._hasDefaultTemplate) {
        return;
      }

      var button = util.findChild(this, '.tab-bar__button');
      var template = defaultInnerTemplateSource.cloneNode(true);
      if (button.children.length == 0) {
        while (template.children[0]) {
          button.appendChild(template.children[0]);
        }
      }

      if (!button.querySelector('.tab-bar__icon')) {
        button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
      }

      if (!button.querySelector('.tab-bar__label')) {
        button.appendChild(template.querySelector('.tab-bar__label'));
      }

      if (!button.querySelector('.tab-bar__badge')) {
        button.appendChild(template.querySelector('.tab-bar__badge'));
      }

      var self = this;
      var icon = this.getAttribute('icon');
      var label = this.getAttribute('label');
      var badge = this.getAttribute('badge');

      if (typeof icon === 'string') {
        var iconElement = getIconElement();
        var last = iconElement.getAttribute('icon');
        iconElement.setAttribute('icon', icon);
        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
        getIconElement().attributeChangedCallback('icon', last, icon);
      } else {
        var wrapper = button.querySelector('.tab-bar__icon');
        if (wrapper) {
          wrapper.remove();
        }
      }

      if (typeof label === 'string') {
        getLabelElement().textContent = label;
      } else {
        var _label = getLabelElement();
        if (_label) {
          _label.remove();
        }
      }

      if (typeof badge === 'string') {
        getBadgeElement().textContent = badge;
      } else {
        var _badge = getBadgeElement();
        if (_badge) {
          _badge.remove();
        }
      }

      function getLabelElement() {
        return self.querySelector('.tab-bar__label');
      }

      function getIconElement() {
        return self.querySelector('ons-icon');
      }

      function getBadgeElement() {
        return self.querySelector('.tab-bar__badge');
      }
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else {
        var tabbar = this._findTabbarElement();
        if (tabbar) {
          tabbar.setActiveTab(this._findTabIndex());
        }
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      var radio = util.findChild(this, 'input');
      radio.checked = true;
      this.classList.add('active');

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'none';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
    }
  }, {
    key: 'setInactive',
    value: function setInactive() {
      var radio = util.findChild(this, 'input');
      radio.checked = false;
      this.classList.remove('active');

      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
        return element.style.display = 'inherit';
      });
      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
        return element.style.display = 'none';
      });
    }

    /**
     * @param {Element} parent
     * @param {Function} callback
     */

  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, callback) {
      var _this3 = this;

      if (!this._loadedPage && !this._getPageTarget()) {
        var pages = this._findTabbarElement().pages;
        var index = this._findTabIndex();
        if (!pages[index]) {
          throw Error('Page was not provided to <ons-tab> index ' + index);
        }
        callback(pages[index]);
      } else if (this._loadingPage) {
        this._loadingPage.then(function (pageElement) {
          callback(pageElement);
        });
      } else if (!this._loadedPage) {
        (function () {
          var deferred = util.defer();
          _this3._loadingPage = deferred.promise;

          _this3._pageLoader.load({ page: _this3._getPageTarget(), parent: parent }, function (pageElement) {
            _this3._loadedPage = pageElement;
            deferred.resolve(pageElement);
            delete _this3._loadingPage;

            callback(pageElement);
          });
        })();
      } else {
        callback(this._loadedPage);
      }
    }
  }, {
    key: '_loadPage',
    value: function _loadPage(page, parent, callback) {
      this._pageLoader.load({ page: page, parent: parent }, function (pageElement) {
        callback(pageElement);
      });
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._ensureElementPosition();

        var tabbar = _this4._findTabbarElement();

        if (tabbar.hasAttribute('modifier')) {
          var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
          _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
        }

        var onReady = function onReady() {
          if (_this4._getPageTarget() && !_this4.hasLoaded) {
            _this4.hasLoaded = true;
            _this4._loadPageElement(tabbar._contentElement, function (pageElement) {
              pageElement.style.display = 'none';
              tabbar._contentElement.appendChild(pageElement);

              if (_this4.hasAttribute('active')) {
                tabbar.setActiveTab(_this4._findTabIndex());
              }
            });
          }
        };

        TabbarElement.rewritables.ready(tabbar, onReady);

        _this4.addEventListener('click', _this4._boundOnClick, false);
      });
    }
  }, {
    key: '_findTabbarElement',
    value: function _findTabbarElement() {
      if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode;
      }

      if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
        return this.parentNode.parentNode;
      }

      return null;
    }
  }, {
    key: '_findTabIndex',
    value: function _findTabIndex() {
      var elements = this.parentNode.children;
      for (var i = 0; i < elements.length; i++) {
        if (this === elements[i]) {
          return i;
        }
      }
    }
  }, {
    key: '_ensureElementPosition',
    value: function _ensureElementPosition() {
      if (!this._findTabbarElement()) {
        throw new Error('This ons-tab element is must be child of ons-tabbar element.');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$16)) {
            this.className = defaultClassName$16 + ' ' + current;
          }
          break;
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$21);
          });
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateDefaultTemplate();
          });
          break;
        case 'page':
          if (typeof current === 'string') {
            this._page = current;
          }
          break;
      }
    }
  }, {
    key: 'page',
    set: function set(page) {
      this._page = page;
    },
    get: function get() {
      return this._page;
    }
  }, {
    key: 'pageLoader',
    set: function set(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    },
    get: function get() {
      return this._pageLoader;
    }
  }, {
    key: 'pageElement',
    get: function get() {
      if (this._loadedPage) {
        return this._loadedPage;
      }

      var tabbar = this._findTabbarElement();
      var index = this._findTabIndex();

      return tabbar._contentElement.children[index];
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
    }
  }]);
  return TabElement;
}(BaseElement);

customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$17 = 'toolbar-button';

var scheme$23 = { '': 'toolbar-button--*' };

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja]アウトラインをもったボタンを表示します。[/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide adding-a-toolbar
 *   [en]Adding a toolbar[/en]
 *   [ja]ツールバーの追加[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseElement) {
  inherits(ToolbarButtonElement, _BaseElement);

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);
    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
  }

  createClass(ToolbarButtonElement, [{
    key: 'init',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    value: function init() {
      this._compile();
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$17);

      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          if (!this.classList.contains(defaultClassName$17)) {
            this.className = defaultClassName$17 + ' ' + current;
          }
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$23);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarButtonElement;
}(BaseElement);

customElements.define('ons-toolbar-button', ToolbarButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$24 = {
  '.range': 'range--*',
  '.range__left': 'range--*__left'
};

var templateSource$2 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

var INPUT_ATTRIBUTES$2 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

var RangeElement = function (_BaseElement) {
  inherits(RangeElement, _BaseElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);
    return possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).apply(this, arguments));
  }

  createClass(RangeElement, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._compile();
        _this2._updateBoundAttributes();
        _this2._onChange();
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
        var template = templateSource$2.cloneNode(true);
        while (template.children[0]) {
          this.appendChild(template.children[0]);
        }
      }

      ModifierUtil.initModifier(this, scheme$24);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._left.style.width = 100 * this._ratio + '%';
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.stopPropagation();
      e.gesture.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this3 = this;

      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$24);
      } else if (INPUT_ATTRIBUTES$2.indexOf(name) >= 0) {
        contentReady(this, function () {
          _this3._updateBoundAttributes();

          if (name === 'min' || name === 'max') {
            _this3._onChange();
          }
        });
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('dragstart', this._onDragstart);
      this.addEventListener('input', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('dragstart', this._onDragstart);
      this.removeEventListener('input', this._onChange);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this4 = this;

      INPUT_ATTRIBUTES$2.forEach(function (attr) {
        if (_this4.hasAttribute(attr)) {
          _this4._input.setAttribute(attr, _this4.getAttribute(attr));
        } else {
          _this4._input.removeAttribute(attr);
        }
      });
    }
  }, {
    key: '_ratio',
    get: function get() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }, {
    key: '_input',
    get: function get() {
      return this.querySelector('input');
    }
  }, {
    key: '_left',
    get: function get() {
      return this.querySelector('.range__left');
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'value',
    get: function get() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set(val) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._input.value = val;
        _this5._onChange();
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get() {
      return ['modifier'].concat(INPUT_ATTRIBUTES$2);
    }
  }, {
    key: 'events',
    get: function get() {
      return ['input', 'change'];
    }
  }]);
  return RangeElement;
}(BaseElement);

customElements.define('ons-range', RangeElement);

ons$1.TemplateElement = TemplateElement;
ons$1.IfElement = IfElement;
ons$1.AlertDialogElement = AlertDialogElement;
ons$1.BackButtonElement = BackButtonElement;
ons$1.BottomToolbarElement = BottomToolbarElement;
ons$1.ButtonElement = ButtonElement;
ons$1.CarouselItemElement = CarouselItemElement;
ons$1.CarouselElement = CarouselElement;
ons$1.ColElement = ColElement;
ons$1.DialogElement = DialogElement;
ons$1.FabElement = FabElement;
ons$1.GestureDetectorElement = GestureDetectorElement;
ons$1.IconElement = IconElement;
ons$1.LazyRepeatElement = LazyRepeatElement;
ons$1.ListHeaderElement = ListHeaderElement;
ons$1.ListItemElement = ListItemElement;
ons$1.ListElement = ListElement;
ons$1.InputElement = InputElement;
ons$1.ModalElement = ModalElement;
ons$1.NavigatorElement = NavigatorElement;
ons$1.PageElement = PageElement;
ons$1.PopoverElement = PopoverElement;
ons$1.ProgressBarElement = ProgressBarElement;
ons$1.ProgressCircularElement = ProgressCircularElement;
ons$1.PullHookElement = PullHookElement;
ons$1.RippleElement = RippleElement;
ons$1.RowElement = RowElement;
ons$1.SelectElement = SelectElement;
ons$1.SpeedDialItemElement = SpeedDialItemElement;
ons$1.SpeedDialElement = SpeedDialElement;
ons$1.SplitterContentElement = SplitterContentElement;
ons$1.SplitterMaskElement = SplitterMaskElement;
ons$1.SplitterSideElement = SplitterSideElement;
ons$1.SplitterElement = SplitterElement;
ons$1.SwitchElement = SwitchElement;
ons$1.TabElement = TabElement;
ons$1.TabbarElement = TabbarElement;
ons$1.ToolbarButtonElement = ToolbarButtonElement;
ons$1.ToolbarElement = ToolbarElement;
ons$1.RangeElement = RangeElement;

// fastclick
window.addEventListener('load', function () {
  ons$1.fastClick = FastClick.attach(document.body);
}, false);

// ons._defaultDeviceBackButtonHandler
window.addEventListener('DOMContentLoaded', function () {
  ons$1._deviceBackButtonDispatcher.enable();
  ons$1._defaultDeviceBackButtonHandler = ons$1._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
    navigator.app.exitApp();
  });
  document.body._gestureDetector = new ons$1.GestureDetector(document.body);
}, false);

// setup loading placeholder
ons$1.ready(function () {
  ons$1._setupLoadingPlaceHolders();
});

// viewport.js
new Viewport().setup();

return ons$1;

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUV2ZW50LmpzIiwiTXV0YXRpb25PYnNlcnZlci5qcyIsImNoaWxkTm9kZVJlbW92ZS5qcyIsImNsYXNzTGlzdC5qcyIsImRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQubWF4LmpzIiwiZmFzdGNsaWNrLXBhdGNoZWQuanMiLCJpbm5lckhUTUwuanMiLCJtaWNyb2V2ZW50LmpzIiwicHJvbWlzZS5qcyIsInNldEltbWVkaWF0ZS5qcyIsInZpZXdwb3J0LmpzIiwid2luc3RvcmUtanNjb21wYXQuanMiLCJvbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwib25zL3V0aWwuanMiLCJvbnMvYW5pbWl0LmpzIiwib25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCJvbnMvcGxhdGZvcm0uanMiLCJvbnMvY29udGVudC1yZWFkeS5qcyIsIm9ucy9ub3RpZmljYXRpb24uanMiLCJvbnMvcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbi5qcyIsIm9ucy9pbnRlcm5hbC9pbnRlcm5hbC5qcyIsIm9ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5LmpzIiwib25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCJvbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQuanMiLCJvbnMvaW50ZXJuYWwvaW5kZXguanMiLCJvbnMvb3JpZW50YXRpb24uanMiLCJvbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCJvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCJvbnMvYXV0b3N0eWxlLmpzIiwib25zL2Rvb3Jsb2NrLmpzIiwib25zL3BhZ2UtbG9hZGVyLmpzIiwib25zL2Jhc2UtYW5pbWF0b3IuanMiLCJvbnMvb25zLmpzIiwib25zL2Jhc2UtZWxlbWVudC5qcyIsImVsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsImVsZW1lbnRzL29ucy1pZi5qcyIsImVsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiZWxlbWVudHMvb25zLWNvbC5qcyIsImVsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWZhYi5qcyIsImVsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiZWxlbWVudHMvb25zLWljb24uanMiLCJlbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWxpc3QuanMiLCJlbGVtZW50cy9vbnMtaW5wdXQuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1wYWdlLmpzIiwiZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCJlbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCJlbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXJvdy5qcyIsImVsZW1lbnRzL29ucy1zZWxlY3QuanMiLCJlbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtLmpzIiwibGliL3N0eWxlci5qcyIsImVsZW1lbnRzL29ucy1zcGVlZC1kaWFsLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzay5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlLmpzIiwiZWxlbWVudHMvb25zLXN3aXRjaC5qcyIsImVsZW1lbnRzL29ucy10YWJiYXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtdGFiYmFyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXRhYi5qcyIsImVsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1yYW5nZS5qcyIsInNldHVwLmpzIl0sIm5hbWVzIjpbInVud3JhcCIsInN0cmluZyIsInNsaWNlIiwiaXNPYmplY3RTdHJpbmciLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpc0FycmF5U3RyaW5nIiwiaXNRdW90ZWRTdHJpbmciLCJlcnJvciIsInRva2VuIiwib3JpZ2luYWxTdHJpbmciLCJFcnJvciIsImxlbmd0aCIsInByb2Nlc3NUb2tlbiIsImlzTmFOIiwicGFyc2VPYmplY3QiLCJwYXJzZUFycmF5IiwibmV4dFRva2VuIiwidHJpbUxlZnQiLCJsaW1pdCIsImMiLCJjaGFyQ29kZUF0IiwibmVzdGVkT2JqZWN0IiwiaSIsImluZGV4T2YiLCJpc1ZhbGlkS2V5IiwidGVzdCIsImtleSIsInRyaW0iLCJvYmplY3QiLCJyZWFkaW5nS2V5IiwicHJldmlvdXNUb2tlbiIsImFycmF5IiwicHVzaCIsInBhcnNlIiwidXRpbCIsInByZXBhcmVRdWVyeSIsInF1ZXJ5IiwiRnVuY3Rpb24iLCJlbGVtZW50IiwibWF0Y2giLCJlIiwicyIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJmaW5kQ2hpbGQiLCJjaGlsZHJlbiIsIm5vZGUiLCJmaW5kUGFyZW50IiwicGFyZW50IiwicGFyZW50Tm9kZSIsImRvY3VtZW50IiwiaXNBdHRhY2hlZCIsImRvY3VtZW50RWxlbWVudCIsImhhc0FueUNvbXBvbmVudEFzUGFyZW50Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInByb3BhZ2F0ZUFjdGlvbiIsImFjdGlvbiIsImNoaWxkTm9kZXMiLCJjaGlsZCIsImNyZWF0ZSIsInNlbGVjdG9yIiwic3R5bGUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImNyZWF0ZUVsZW1lbnQiLCJzaGlmdCIsImNsYXNzTmFtZSIsImpvaW4iLCJleHRlbmQiLCJodG1sIiwid3JhcHBlciIsImNyZWF0ZUZyYWdtZW50IiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZmlyc3RDaGlsZCIsImFwcGVuZENoaWxkIiwiZHN0IiwiYXJncyIsImtleXMiLCJPYmplY3QiLCJqIiwiYXJyYXlGcm9tIiwiYXJyYXlMaWtlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInBhcnNlSlNPTk9iamVjdFNhZmVseSIsImpzb25TdHJpbmciLCJmYWlsU2FmZSIsInJlc3VsdCIsIkpTT04iLCJmaW5kRnJvbVBhdGgiLCJwYXRoIiwiZWwiLCJ3aW5kb3ciLCJ0cmlnZ2VyRWxlbWVudEV2ZW50IiwidGFyZ2V0IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImZvckVhY2giLCJkaXNwYXRjaEV2ZW50IiwiaGFzTW9kaWZpZXIiLCJtb2RpZmllck5hbWUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJzb21lIiwiYWRkTW9kaWZpZXIiLCJtb2RpZmllckF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZU1vZGlmaWVyIiwibW9kaWZpZXJzIiwibmV3TW9kaWZpZXJzIiwiZmlsdGVyIiwiaXRlbSIsInVwZGF0ZVBhcmVudFBvc2l0aW9uIiwiX3BhcmVudFVwZGF0ZWQiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbiIsInRvZ2dsZUF0dHJpYnV0ZSIsIm5hbWUiLCJ2YWx1ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImJpbmRMaXN0ZW5lcnMiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwiYmluZCIsImVhY2giLCJvYmoiLCJmIiwidXBkYXRlUmlwcGxlIiwicmlwcGxlRWxlbWVudCIsImluc2VydEJlZm9yZSIsInJlbW92ZSIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsImlzSW50ZWdlciIsImlzRmluaXRlIiwiTWF0aCIsImZsb29yIiwiZGVmZXIiLCJkZWZlcnJlZCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIlRJTUVPVVRfUkFUSU8iLCJjYXBpdGFsaXplIiwic3RyIiwiY2hhckF0IiwiYnVpbGRUcmFuc2l0aW9uVmFsdWUiLCJwYXJhbXMiLCJwcm9wZXJ0eSIsImR1cmF0aW9uIiwidGltaW5nIiwicHJvcHMiLCJtYXAiLCJwcm9wIiwib25jZU9uVHJhbnNpdGlvbkVuZCIsImNhbGxiYWNrIiwiZm4iLCJzdG9wUHJvcGFnYXRpb24iLCJyZW1vdmVMaXN0ZW5lcnMiLCJfdHJhbnNpdGlvbkVuZEV2ZW50cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwidmVuZG9yUHJlZml4IiwiX2Nzc1Byb3BlcnR5RGljdCIsInN0eWxlcyIsImRpY3QiLCJhIiwieiIsInVwcGVyIiwic3Vic3RyIiwiaGFzQ3NzUHJvcGVydHkiLCJwcmUiLCJPTGluayIsImZvcmNlTGF5b3V0QXRPbmNlIiwiZWxlbWVudHMiLCJiYXRjaEltbWVkaWF0ZSIsIm9mZnNldEhlaWdodCIsImNhbGxiYWNrcyIsImNvbmNyZWF0ZUNhbGxiYWNrcyIsImJhdGNoQW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0cmFuc2l0aW9uUHJvcGVydHlOYW1lIiwiQW5pbWl0IiwiSFRNTEVsZW1lbnQiLCJ0b1N0cmluZyIsInRyYW5zaXRpb25RdWV1ZSIsImxhc3RTdHlsZUF0dHJpYnV0ZURpY3QiLCJ1bmRlZmluZWQiLCJkb25lIiwic3RhcnRBbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwib3B0aW9ucyIsInF1ZXVlIiwiY3NzIiwiVHJhbnNpdGlvbiIsImJ1aWxkIiwic2Vjb25kcyIsImluZGV4Iiwic2VsZiIsInRyYW5zaXRpb25OYW1lIiwidHJhbnNpdGlvblZhbHVlIiwidGltZW91dElkIiwiY2xlYXJUcmFuc2l0aW9uIiwic2V0VGltZW91dCIsImxlbiIsInJlc2V0IiwiX2RlcXVldWVUcmFuc2l0aW9uIiwiX2N1cnJlbnRUcmFuc2l0aW9uIiwiY2FsbGVkIiwicnVuQWxsIiwiYXJndW1lbnRzIiwicGxheSIsImNyZWF0ZUFjdHVhbENzc1Byb3BzIiwidGltZW91dCIsInByZWZpeGVkIiwiRXZlbnQiLCJVdGlscyIsIkRldGVjdGlvbiIsIlBvaW50ZXJFdmVudCIsIkdlc3R1cmVEZXRlY3RvciIsIkluc3RhbmNlIiwiZGVmYXVsdHMiLCJET0NVTUVOVCIsIkhBU19QT0lOVEVSRVZFTlRTIiwibmF2aWdhdG9yIiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwiSEFTX1RPVUNIRVZFTlRTIiwiSVNfTU9CSUxFIiwidXNlckFnZW50IiwiTk9fTU9VU0VFVkVOVFMiLCJDQUxDVUxBVEVfSU5URVJWQUwiLCJFVkVOVF9UWVBFUyIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fUklHSFQiLCJQT0lOVEVSX01PVVNFIiwiUE9JTlRFUl9UT1VDSCIsIlBPSU5URVJfUEVOIiwiRVZFTlRfU1RBUlQiLCJFVkVOVF9NT1ZFIiwiRVZFTlRfRU5EIiwiRVZFTlRfUkVMRUFTRSIsIkVWRU5UX1RPVUNIIiwiUkVBRFkiLCJwbHVnaW5zIiwiZ2VzdHVyZXMiLCJzZXR1cCIsImRldGVybWluZUV2ZW50VHlwZXMiLCJnZXN0dXJlIiwicmVnaXN0ZXIiLCJvblRvdWNoIiwiZGV0ZWN0IiwidXRpbHMiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJoYXNPd25Qcm9wZXJ0eSIsIm9uIiwidHlwZSIsImhhbmRsZXIiLCJvZmYiLCJpdGVyYXRvciIsImNvbnRleHQiLCJpblN0ciIsImZpbmQiLCJpbkFycmF5IiwidG9BcnJheSIsImhhc1BhcmVudCIsImdldENlbnRlciIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJtaW4iLCJtYXgiLCJ0b3VjaCIsImdldFZlbG9jaXR5IiwiZGVsdGFUaW1lIiwiZGVsdGFYIiwiZGVsdGFZIiwiYWJzIiwiZ2V0QW5nbGUiLCJ0b3VjaDEiLCJ0b3VjaDIiLCJ4IiwieSIsImF0YW4yIiwiUEkiLCJnZXREaXJlY3Rpb24iLCJnZXREaXN0YW5jZSIsInNxcnQiLCJnZXRTY2FsZSIsInN0YXJ0IiwiZW5kIiwiZ2V0Um90YXRpb24iLCJpc1ZlcnRpY2FsIiwiZGlyZWN0aW9uIiwic2V0UHJlZml4ZWRDc3MiLCJ0b2dnbGUiLCJwcmVmaXhlcyIsInRvQ2FtZWxDYXNlIiwicCIsInRvZ2dsZUJlaGF2aW9yIiwiZmFsc2VGbiIsInVzZXJTZWxlY3QiLCJvbnNlbGVjdHN0YXJ0IiwidXNlckRyYWciLCJvbmRyYWdzdGFydCIsImhvb2siLCJ0eXBlcyIsImV2ZW50VHlwZSIsIm9uVG91Y2hIYW5kbGVyIiwiZXYiLCJzcmNUeXBlIiwiaXNQb2ludGVyIiwiaXNNb3VzZSIsInRyaWdnZXJUeXBlIiwicHJldmVudE1vdXNlRXZlbnRzIiwiYnV0dG9uIiwic2hvdWxkRGV0ZWN0IiwiYnV0dG9ucyIsIm1hdGNoVHlwZSIsInVwZGF0ZVBvaW50ZXIiLCJkb0RldGVjdCIsInRvdWNoTGlzdCIsImdldFRvdWNoTGlzdCIsInRvdWNoTGlzdExlbmd0aCIsInRyaWdnZXJDaGFuZ2UiLCJ0cmlnZ2VyIiwiY2hhbmdlZExlbmd0aCIsImNoYW5nZWRUb3VjaGVzIiwic3RhcnRlZCIsImV2RGF0YSIsImNvbGxlY3RFdmVudERhdGEiLCJpZGVudGlmaWVycyIsImNvbmNhdCIsImlkZW50aWZpZXIiLCJwb2ludGVyVHlwZSIsIkRhdGUiLCJub3ciLCJzcmNFdmVudCIsInByZXZlbnRNYW5pcHVsYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BEZXRlY3QiLCJ0b3VjaGxpc3QiLCJwb2ludGVycyIsInBvaW50ZXIiLCJwb2ludGVyRXZlbnQiLCJwb2ludGVySWQiLCJwdCIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJNU1BPSU5URVJfVFlQRV9QRU4iLCJyZXNldExpc3QiLCJkZXRlY3Rpb24iLCJzdGFydERldGVjdCIsImluc3QiLCJldmVudERhdGEiLCJjdXJyZW50Iiwic3RvcHBlZCIsImV4dGVuZEV2ZW50RGF0YSIsImluc3RPcHRpb25zIiwidHJpZ2dlckdlc3R1cmUiLCJlbmFibGVkIiwibGFzdEV2ZW50IiwicHJldmlvdXMiLCJnZXRDYWxjdWxhdGVkRGF0YSIsImNlbnRlciIsImN1ciIsInJlY2FsYyIsImNhbGNFdiIsImxhc3RDYWxjRXZlbnQiLCJjYWxjRGF0YSIsImxhc3RDYWxjRGF0YSIsInRpbWVTdGFtcCIsImZ1dHVyZUNhbGNFdmVudCIsInZlbG9jaXR5IiwiYW5nbGUiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJpbnRlcmltQW5nbGUiLCJpbnRlcmltRGlyZWN0aW9uIiwic3RhcnRFdiIsInN0YXJ0RXZlbnQiLCJsYXN0RXYiLCJzb3J0IiwiYiIsImJlaGF2aW9yIiwiZXZlbnRTdGFydEhhbmRsZXIiLCJldmVudEhhbmRsZXJzIiwib25FdmVudCIsIm9mZkV2ZW50Iiwic3BsaWNlIiwidHJpZ2dlckV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJlbmFibGUiLCJzdGF0ZSIsImRpc3Bvc2UiLCJlaCIsInRyaWdnZXJlZCIsImRyYWdHZXN0dXJlIiwiZHJhZ01heFRvdWNoZXMiLCJkaXN0YW5jZSIsImRyYWdNaW5EaXN0YW5jZSIsInN0YXJ0Q2VudGVyIiwiZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiIsImZhY3RvciIsImRyYWdMb2NrVG9BeGlzIiwiZHJhZ0xvY2tNaW5EaXN0YW5jZSIsImxhc3REaXJlY3Rpb24iLCJkcmFnQmxvY2tWZXJ0aWNhbCIsImRyYWdCbG9ja0hvcml6b250YWwiLCJEcmFnIiwiR2VzdHVyZSIsInJlbGVhc2VHZXN0dXJlIiwidGltZXIiLCJob2xkR2VzdHVyZSIsImhvbGRUaW1lb3V0IiwiaG9sZFRocmVzaG9sZCIsIkhvbGQiLCJSZWxlYXNlIiwiSW5maW5pdHkiLCJTd2lwZSIsInN3aXBlR2VzdHVyZSIsInN3aXBlTWluVG91Y2hlcyIsInN3aXBlTWF4VG91Y2hlcyIsInN3aXBlVmVsb2NpdHlYIiwic3dpcGVWZWxvY2l0eVkiLCJoYXNNb3ZlZCIsInRhcEdlc3R1cmUiLCJwcmV2Iiwic2luY2VQcmV2IiwiZGlkRG91YmxlVGFwIiwidGFwTWF4RGlzdGFuY2UiLCJ0YXBNYXhUaW1lIiwiZG91YmxlVGFwSW50ZXJ2YWwiLCJkb3VibGVUYXBEaXN0YW5jZSIsInRhcEFsd2F5cyIsIlRhcCIsIlRvdWNoIiwidG91Y2hHZXN0dXJlIiwicHJldmVudE1vdXNlIiwidHJhbnNmb3JtR2VzdHVyZSIsInNjYWxlVGhyZXNob2xkIiwic2NhbGUiLCJyb3RhdGlvblRocmVzaG9sZCIsInJvdGF0aW9uIiwidHJhbnNmb3JtTWluU2NhbGUiLCJ0cmFuc2Zvcm1NaW5Sb3RhdGlvbiIsIlRyYW5zZm9ybSIsIlBsYXRmb3JtIiwiX3JlbmRlclBsYXRmb3JtIiwicGxhdGZvcm0iLCJyZWFkeVN0YXRlIiwiY29yZG92YSIsInBob25lZ2FwIiwiUGhvbmVHYXAiLCJkZXZpY2UiLCJvcGVyYSIsIkluc3RhbGxUcmlnZ2VyIiwiY2hyb21lIiwiZG9jdW1lbnRNb2RlIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwidmVyIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc1dQIiwiaXNJUGhvbmUiLCJpc0lQYWQiLCJpc0lQb2QiLCJyZWFkeU1hcCIsIldlYWtNYXAiLCJxdWV1ZU1hcCIsImlzQ29udGVudFJlYWR5IiwiaGFzIiwic2V0Q29udGVudFJlYWR5Iiwic2V0IiwiYWRkQ2FsbGJhY2siLCJnZXQiLCJjb25zdW1lUXVldWUiLCJkZWxldGUiLCJjb250ZW50UmVhZHkiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIm5vdGlmaWNhdGlvbiIsIl9jcmVhdGVBbGVydERpYWxvZyIsImlucHV0U3RyaW5nIiwiaXNQcm9tcHQiLCJpbnB1dFR5cGUiLCJwbGFjZWhvbGRlciIsImRlZmF1bHRWYWx1ZSIsImJ1dHRvbkxhYmVscyIsImxhYmVsIiwicHJpbWFyeUJ1dHRvbkluZGV4IiwiX2Rlc3Ryb3lEaWFsb2ciLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsImRlc3Ryb3kiLCJ0aXRsZSIsIm1lc3NhZ2UiLCJtZXNzYWdlSFRNTCIsIm1vZGlmaWVyIiwic3VibWl0T25FbnRlciIsImlucHV0IiwicXVlcnlTZWxlY3RvciIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwiaGlkZSIsInRoZW4iLCJyZXNvbHZlVmFsdWUiLCJmb290ZXIiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYnV0dG9uRWxlbWVudCIsIm9uY2xpY2siLCJjYW5jZWxhYmxlIiwiYm9keSIsImNvbXBpbGUiLCJzaG93IiwiYXV0b2ZvY3VzIiwiZm9jdXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwiYnV0dG9uTGFiZWwiLCJpc0FycmF5IiwicGFyYW0iLCJhbGVydCIsImNvbmZpcm0iLCJwcm9tcHQiLCJwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiIsIm92ZXJ3cml0ZSIsIl92YXJpYWJsZXMiLCJwYXJ0IiwiaW5JbnRlcnBvbGF0aW9uIiwiY3VycmVudEluZGV4IiwidG9rZW5zIiwic3Vic3RyaW5nIiwicmUiLCJ2YXJpYWJsZSIsImdldFZhcmlhYmxlIiwicnYiLCJfcmVwbGFjZVRva2VuIiwiZXhwcmVzc2lvbiIsIl9wYXJzZVBhcnQiLCJfcmVwbGFjZVRva2VucyIsIl9wYXJzZUV4cHJlc3Npb24iLCJkZWZpbmVWYXJpYWJsZSIsImdldE1vYmlsZU9TIiwiZ2V0SU9TRGV2aWNlIiwiaXNXZWJWaWV3IiwiaW50ZXJuYWwiLCJjb25maWciLCJudWxsRWxlbWVudCIsImlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsIiwiYXV0b1N0YXR1c0JhckZpbGwiLCJub3JtYWxpemVQYWdlSFRNTCIsIndhaXRET01Db250ZW50TG9hZGVkIiwib25SZWFkeSIsInNob3VsZEZpbGxTdGF0dXNCYXIiLCJpc0lPUzdhYm92ZSIsInRlbXBsYXRlU3RvcmUiLCJfc3RvcmFnZSIsInRlbXBsYXRlIiwidGVtcGxhdGVJZCIsInRlbXBsYXRlcyIsInRleHRDb250ZW50IiwiZ2V0VGVtcGxhdGVIVE1MQXN5bmMiLCJwYWdlIiwiY2FjaGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJvbmxvYWQiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsIm9uZXJyb3IiLCJzZW5kIiwiZ2V0UGFnZUhUTUxBc3luYyIsInBhZ2VzIiwiZXZhbHVhdGUiLCJnZXRQYWdlIiwiQW5pbWF0b3JGYWN0b3J5Iiwib3B0cyIsIl9hbmltYXRvcnMiLCJhbmltYXRvcnMiLCJfYmFzZUNsYXNzIiwiYmFzZUNsYXNzIiwiX2Jhc2VDbGFzc05hbWUiLCJiYXNlQ2xhc3NOYW1lIiwiX2FuaW1hdGlvbiIsImRlZmF1bHRBbmltYXRpb24iLCJfYW5pbWF0aW9uT3B0aW9ucyIsImRlZmF1bHRBbmltYXRpb25PcHRpb25zIiwiZGVmYXVsdEFuaW1hdG9yIiwiYW5pbWF0b3IiLCJhbmltYXRpb24iLCJBbmltYXRvciIsImFuaW1hdGlvbk9wdHMiLCJhbmltYXRpb25PcHRpb25zIiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwiZGVsYXkiLCJNb2RpZmllclV0aWwiLCJsYXN0IiwibWFrZURpY3QiLCJyZW1vdmVkIiwicmVkdWNlIiwiYWRkZWQiLCJkaWZmIiwiYWRkIiwia2xhc3MiLCJzY2hlbWUiLCJ0YXJnZXRFbGVtZW50cyIsImFwcGx5RGlmZlRvQ2xhc3NMaXN0IiwiYXBwbHlEaWZmVG9FbGVtZW50IiwiTGF6eVJlcGVhdERlbGVnYXRlIiwidXNlckRlbGVnYXRlIiwidGVtcGxhdGVFbGVtZW50IiwiX3VzZXJEZWxlZ2F0ZSIsIkVsZW1lbnQiLCJfdGVtcGxhdGVFbGVtZW50IiwiX3JlbmRlciIsIml0ZW1zIiwiaGVpZ2h0IiwibG9hZEl0ZW1FbGVtZW50IiwiY3JlYXRlSXRlbUNvbnRlbnQiLCJjb3VudCIsImNvdW50SXRlbXMiLCJ1cGRhdGVJdGVtQ29udGVudCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJkZXN0cm95SXRlbSIsIml0ZW1IZWlnaHQiLCJMYXp5UmVwZWF0UHJvdmlkZXIiLCJ3cmFwcGVyRWxlbWVudCIsImRlbGVnYXRlIiwiX3dyYXBwZXJFbGVtZW50IiwiX2RlbGVnYXRlIiwidGFnTmFtZSIsIl9wYWdlQ29udGVudCIsIl9maW5kUGFnZUNvbnRlbnRFbGVtZW50IiwiX3RvcFBvc2l0aW9ucyIsIl9yZW5kZXJlZEl0ZW1zIiwiX3Vua25vd25JdGVtSGVpZ2h0IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwiX29uQ2hhbmdlIiwicGFnZUNvbnRlbnQiLCJjb250ZW50IiwicmVtb3ZlQ2hpbGQiLCJfaXRlbUhlaWdodCIsImxhc3RWaXNpYmlsaXR5IiwidmlzaWJpbGl0eSIsInN0YXRpY0l0ZW1IZWlnaHQiLCJfcmVtb3ZlQWxsRWxlbWVudHMiLCJfY2hlY2tJdGVtSGVpZ2h0IiwiX2dldEl0ZW1zSW5WaWV3IiwiaGFzUmVuZGVyRnVuY3Rpb24iLCJfbGlzdEhlaWdodCIsImtlZXAiLCJfcmVuZGVyRWxlbWVudCIsIl9yZW1vdmVFbGVtZW50IiwidG9wIiwidXBkYXRlSXRlbSIsIl9pdGVtQ291bnQiLCJtaWRkbGUiLCJfZ2V0SXRlbUhlaWdodCIsImwiLCJvZmZzZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbm5lckhlaWdodCIsIl9jb3VudEl0ZW1zIiwiX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zIiwiX2NhbGN1bGF0ZVN0YXJ0SW5kZXgiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsImNhbGxOb3ciLCJfZGVib3VuY2UiLCJfYm91bmRPbkNoYW5nZSIsIl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kIiwiX3BhcmVudEVsZW1lbnQiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJfaXNQb3J0cmFpdCIsImlzUG9ydHJhaXQiLCJfb25ET01Db250ZW50TG9hZGVkIiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfb25SZXNpemUiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ3IiwiaCIsIm1peGluIiwiX2luaXQiLCJzb2Z0d2FyZUtleWJvYXJkIiwiTWljcm9FdmVudCIsIl92aXNpYmxlIiwib25TaG93Iiwib25IaWRlIiwiYmluZEV2ZW50cyIsIktleWJvYXJkIiwib25zaG93Iiwib25oaWRlIiwidmlzaWJsZSIsImlzVmlzaWJsZSIsIm5vUGx1Z2luRXJyb3IiLCJ3YXJuIiwiX2RvbUNvbnRlbnRMb2FkZWQiLCJfcmVhZHkiLCJIYW5kbGVyUmVwb3NpdG9yeSIsImRhdGFzZXQiLCJkZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkIiwiaWQiLCJfZ2VuSWQiLCJfc3RvcmUiLCJEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsIl9pc0VuYWJsZWQiLCJfYm91bmRDYWxsYmFjayIsIl9jYWxsYmFjayIsImFkZEJhY2tCdXR0b25MaXN0ZW5lciIsInJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lciIsIl9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCIsIl9lbGVtZW50IiwidHJlZSIsIl9jYXB0dXJlVHJlZSIsIl9maW5kSGFuZGxlckxlYWZFbGVtZW50IiwiY3JlYXRlVHJlZSIsImFycmF5T2YiLCJjaGlsZEVsZW1lbnQiLCJkaXNwbGF5IiwiY2hpbGROb2RlIiwibGVmdCIsInJpZ2h0IiwibGVmdFoiLCJ6SW5kZXgiLCJyaWdodFoiLCJhdXRvU3R5bGVFbmFibGVkIiwibW9kaWZpZXJzTWFwIiwicGxhdGZvcm1zIiwiYW5kcm9pZCIsIm9sZE1vZGlmaWVyIiwibmV3TW9kaWZpZXIiLCJ1bnNoaWZ0IiwiaW9zIiwidW5sb2NrZWQiLCJwcmVwYXJlQXV0b1N0eWxlIiwiZm9yY2UiLCJtb2JpbGVPUyIsIm9uc1BsYXRmb3JtIiwiZ2VuZXJhdGVJZCIsIkRvb3JMb2NrIiwiX2xvY2tMaXN0IiwiX3dhaXRMaXN0IiwiX2xvZyIsImxvZyIsInVubG9jayIsIl91bmxvY2siLCJfdHJ5VG9GcmVlV2FpdExpc3QiLCJpc0xvY2tlZCIsImxvYWRQYWdlIiwicGFnZUVsZW1lbnQiLCJ1bmxvYWRQYWdlIiwiX2Rlc3Ryb3kiLCJQYWdlTG9hZGVyIiwibG9hZGVyIiwidW5sb2FkZXIiLCJfbG9hZGVyIiwiX3VubG9hZGVyIiwiZGVmYXVsdFBhZ2VMb2FkZXIiLCJpbnN0YW50UGFnZUxvYWRlciIsIkJhc2VBbmltYXRvciIsInByb3BlcnRpZXMiLCJleHRlbmRlZEFuaW1hdG9yIiwibmV3QW5pbWF0b3IiLCJvbnMiLCJfdXRpbCIsImFuaW1pdCIsIl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsImRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIiwiX2ludGVybmFsIiwiUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24iLCJfYW5pbWF0aW9uT3B0aW9uc1BhcnNlciIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZXIiLCJfYXV0b1N0eWxlIiwiYXV0b1N0eWxlIiwiX0Rvb3JMb2NrIiwiX2NvbnRlbnRSZWFkeSIsIl9CYXNlQW5pbWF0b3IiLCJfcmVhZHlMb2NrIiwic2VsZWN0IiwibG9jYXRpb24iLCJzZWFyY2giLCJ3YWl0RGV2aWNlUmVhZHkiLCJpc1JlYWR5IiwicmVhZHkiLCJ3YWl0VW5sb2NrIiwic2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciIsImxpc3RlbmVyIiwiX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciIsInNldExpc3RlbmVyIiwiZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyIiwiZGlzYWJsZSIsImVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyIiwiZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQW5pbWF0aW9ucyIsImVuYWJsZUFuaW1hdGlvbnMiLCJkaXNhYmxlQXV0b1N0eWxpbmciLCJlbmFibGVBdXRvU3R5bGluZyIsImZvcmNlUGxhdGZvcm1TdHlsaW5nIiwibmV3UGxhdGZvcm0iLCJfcGxhdGZvcm1VcGRhdGUiLCJwcmVwYXJlIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCIsImRpdiIsInBvcG92ZXIiLCJsaW5rIiwiY3JlYXRlUG9wb3ZlciIsIl9jcmVhdGVEaWFsb2dPcmlnaW5hbCIsImNyZWF0ZURpYWxvZyIsIl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsIiwiYWxlcnREaWFsb2ciLCJjcmVhdGVBbGVydERpYWxvZyIsIl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyT3JpZ2luYWwiLCJfcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciIsInJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzIiwiY29udGVudEVsZW1lbnQiLCJjYXRjaCIsInVubG9ja0RldmljZVJlYWR5IiwibG9jayIsIl9zdXBlclNlY3JldE9ucyIsImdldEVsZW1lbnRDbGFzcyIsIkJhc2VFbGVtZW50IiwiaW5pdCIsIlRlbXBsYXRlRWxlbWVudCIsImlubmVySFRNTCIsImJ1YmJsZXMiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSIsIklmRWxlbWVudCIsIl9pc0FsbG93ZWRQbGF0Zm9ybSIsImNvbmRpdGlvbmFsT3JpZW50YXRpb24iLCJjdXJyZW50T3JpZW50YXRpb24iLCJBbGVydERpYWxvZ0FuaW1hdG9yIiwiQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IiLCJfbWFzayIsIl9kaWFsb2ciLCJzYXZlU3R5bGUiLCJyZXN0b3JlU3R5bGUiLCJJT1NBbGVydERpYWxvZ0FuaW1hdG9yIiwiX2FuaW1hdG9yRGljdCIsIkFsZXJ0RGlhbG9nRWxlbWVudCIsIl9jb21waWxlIiwiX2Rvb3JMb2NrIiwiX2JvdW5kQ2FuY2VsIiwiX2NhbmNlbCIsIl91cGRhdGVBbmltYXRvckZhY3RvcnkiLCJfYW5pbWF0b3JGYWN0b3J5IiwibWFzayIsImNvbnRhaW5lciIsImJhY2tncm91bmRDb2xvciIsImluaXRNb2RpZmllciIsImNhbmNlbCIsInBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyIsInRyeVNob3ciLCJvcGFjaXR5IiwidHJ5SGlkZSIsIl9ydW5uaW5nIiwib25EZXZpY2VCYWNrQnV0dG9uIiwiY2FsbFBhcmVudEhhbmRsZXIiLCJfYmFja0J1dHRvbkhhbmRsZXIiLCJvbk1vZGlmaWVyQ2hhbmdlZCIsImNyZWF0ZUhhbmRsZXIiLCJkZWZhdWx0Q2xhc3NOYW1lIiwiQmFja0J1dHRvbkVsZW1lbnQiLCJfb3B0aW9ucyIsIl9ib3VuZE9uQ2xpY2siLCJfb25DbGljayIsImljb24iLCJvbkNsaWNrIiwicG9wUGFnZSIsImNvbnRhaW5zIiwiQm90dG9tVG9vbGJhckVsZW1lbnQiLCJCdXR0b25FbGVtZW50IiwiX3VwZGF0ZVJpcHBsZSIsIkNhcm91c2VsSXRlbUVsZW1lbnQiLCJ3aWR0aCIsIlZlcnRpY2FsTW9kZVRyYWl0IiwiX2N1cnJlbnRFbGVtZW50U2l6ZSIsInNjcm9sbCIsIl9zdHlsZSIsIl9kaW1lbnNpb25zIiwiY2VudGVyZWQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIl9vZmZzZXQiLCJfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSIsIl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cyIsInNpemVBdHRyIiwiX2dldENhcm91c2VsSXRlbVNpemVBdHRyIiwic2l6ZUluZm8iLCJfZGVjb21wb3NlU2l6ZVN0cmluZyIsIm51bWJlciIsInVuaXQiLCJfdXBkYXRlRGltZW5zaW9uRGF0YSIsIl91cGRhdGVPZmZzZXQiLCJfbGF5b3V0Q2Fyb3VzZWxJdGVtcyIsIkhvcml6b250YWxNb2RlVHJhaXQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIkNhcm91c2VsRWxlbWVudCIsIl9zY3JvbGwiLCJfbGFzdEFjdGl2ZUluZGV4IiwiX2JvdW5kT25EcmFnIiwiX29uRHJhZyIsIl9ib3VuZE9uRHJhZ0VuZCIsIl9vbkRyYWdFbmQiLCJfYm91bmRPblJlc2l6ZSIsIl9taXhpbiIsIl9pc1ZlcnRpY2FsIiwic2V0QWN0aXZlSW5kZXgiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJyZWZyZXNoIiwiX2xhc3RTdGF0ZSIsIml0ZW1Db3VudCIsImVsZW1lbnRTaXplIiwiX2dldEVsZW1lbnRTaXplIiwicm91bmQiLCJhdHRyTmFtZSIsIml0ZW1TaXplQXR0ciIsInNpemUiLCJfZ2V0SW5pdGlhbEluZGV4IiwiX3Njcm9sbFRvIiwiX2NhbGN1bGF0ZU1heFNjcm9sbCIsIl90cnlGaXJlUG9zdENoYW5nZUV2ZW50IiwiZ2V0QWN0aXZlSW5kZXgiLCJjYXJvdXNlbEl0ZW1TaXplIiwiYXV0b1Njcm9sbCIsIl9nZXN0dXJlRGV0ZWN0b3IiLCJfbXV0YXRpb25PYnNlcnZlciIsIl91cGRhdGVTd2lwZWFibGUiLCJfdXBkYXRlQXV0b1JlZnJlc2giLCJkaXNjb25uZWN0Iiwic3dpcGVhYmxlIiwibGFzdEFjdGl2ZUluZGV4IiwiZCIsIl9pc1dyb25nRGlyZWN0aW9uIiwiX2xhc3REcmFnRXZlbnQiLCJfZ2V0U2Nyb2xsRGVsdGEiLCJfaXNPdmVyU2Nyb2xsIiwid2FpdEZvckFjdGlvbiIsIl9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uIiwiX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwiLCJfc3RhcnRNb21lbnR1bVNjcm9sbCIsInRyYWl0IiwiX2dldFNjcm9sbFZlbG9jaXR5Iiwic2Nyb2xsRGVsdGEiLCJfbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24iLCJfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0iLCJhcnIiLCJuYnJPZkl0ZW1zIiwicG9zIiwibGFzdFNjcm9sbCIsInNjcm9sbFJhdGlvIiwiYXV0b1Njcm9sbFJhdGlvIiwiaXNPdmVyc2Nyb2xsYWJsZSIsIm92ZXJzY3JvbGxhYmxlIiwibm9ybWFsaXplU2Nyb2xsIiwicmF0aW8iLCJtYXhTY3JvbGwiLCJjZWlsIiwiX3NldHVwIiwiX3NhdmVMYXN0U3RhdGUiLCJjYXJvdXNlbCIsIl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMiLCJfc2V0dXBJbml0aWFsSW5kZXgiLCJfb25EaXJlY3Rpb25DaGFuZ2UiLCJhdHRyIiwicGFyc2VGbG9hdCIsIkNvbEVsZW1lbnQiLCJfdXBkYXRlV2lkdGgiLCJ3ZWJraXRCb3hGbGV4Iiwid2Via2l0RmxleCIsIm1vekJveEZsZXgiLCJtb3pGbGV4IiwibXNGbGV4IiwiZmxleCIsIm1heFdpZHRoIiwiRGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkRGlhbG9nQW5pbWF0b3IiLCJJT1NEaWFsb2dBbmltYXRvciIsIlNsaWRlRGlhbG9nQW5pbWF0b3IiLCJEaWFsb2dFbGVtZW50IiwiRmFiRWxlbWVudCIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsIkdlc3R1cmVEZXRlY3RvckVsZW1lbnQiLCJJY29uRWxlbWVudCIsIl91cGRhdGUiLCJfY2xlYW5DbGFzc0F0dHJpYnV0ZSIsIl9idWlsZENsYXNzQW5kU3R5bGUiLCJfZ2V0QXR0cmlidXRlIiwicGFydHMiLCJkZWYiLCJtZCIsImljb25OYW1lIiwicmVtb3ZlUHJvcGVydHkiLCJmb250U2l6ZSIsIkxhenlSZXBlYXRFbGVtZW50IiwiX2xhenlSZXBlYXRQcm92aWRlciIsIkxpc3RIZWFkZXJFbGVtZW50IiwiTGlzdEl0ZW1FbGVtZW50IiwiX29uVG91Y2giLCJfb25SZWxlYXNlIiwiX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIiwidGFwcGVkIiwiX3Nob3VsZExvY2tPbkRyYWciLCJfdHJhbnNpdGlvbiIsIndlYmtpdFRyYW5zaXRpb24iLCJNb3pUcmFuc2l0aW9uIiwiX3RhcHBhYmxlIiwiX3RhcEJhY2tncm91bmRDb2xvciIsImJveFNoYWRvdyIsIkxpc3RFbGVtZW50IiwiZGVmYXVsdENoZWNrYm94Q2xhc3MiLCJkZWZhdWx0UmFkaW9CdXR0b25DbGFzcyIsIklOUFVUX0FUVFJJQlVURVMiLCJJbnB1dEVsZW1lbnQiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJfYm91bmRPbklucHV0IiwiX29uSW5wdXQiLCJfYm91bmRPbkZvY3VzaW4iLCJfb25Gb2N1c2luIiwiX2JvdW5kRGVsZWdhdGVFdmVudCIsIl9kZWxlZ2F0ZUV2ZW50IiwiaGVscGVyIiwiX2lucHV0IiwiX2hlbHBlciIsIl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMiLCJfdXBkYXRlTGFiZWwiLCJfdXBkYXRlTGFiZWxDbGFzcyIsImNoZWNrZWQiLCJfYm91bmRPbkZvY3Vzb3V0IiwiaW5uZXJUZXh0IiwiX3NldExhYmVsIiwidmFsIiwiTW9kYWxBbmltYXRvciIsIm1vZGFsIiwiRmFkZU1vZGFsQW5pbWF0b3IiLCJNb2RhbEVsZW1lbnQiLCJOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJlbnRlclBhZ2UiLCJsZWF2ZVBhZ2UiLCJibG9ja2VyIiwiSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJiYWNrZ3JvdW5kTWFzayIsInRvb2xiYXIiLCJfZ2V0VG9vbGJhckVsZW1lbnQiLCJfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQiLCJfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50IiwiZXhjbHVkZUJhY2tCdXR0b24iLCJvdGhlciIsIl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQiLCJfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQiLCJfZ2V0Q29udGVudEVsZW1lbnQiLCJfZ2V0QmFja2dyb3VuZEVsZW1lbnQiLCJfZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQiLCJib3RoUGFnZUhhc1Rvb2xiYXIiLCJfY2FuQW5pbWF0ZVRvb2xiYXIiLCJub01hdGVyaWFsVG9vbGJhciIsImRlY29tcG9zaXRpb24iLCJwYWdlUmVjdCIsImJhY2tCdXR0b25MYWJlbCIsImxhYmVsUmVjdCIsImJhY2tCdXR0b25JY29uIiwibmV4dFNpYmxpbmciLCJ1bmJsb2NrIiwiZW50ZXJQYWdlRGVjb21wb3NpdGlvbiIsIl9kZWNvbXBvc2UiLCJsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uIiwiZGVsdGEiLCJfY2FsY3VsYXRlRGVsdGEiLCJtYXNrQ2xlYXIiLCJzaG91bGRBbmltYXRlVG9vbGJhciIsIl9zaG91bGRBbmltYXRlVG9vbGJhciIsImVudGVyUGFnZVRvb2xiYXJIZWlnaHQiLCJib3R0b21Ub29sYmFyIiwiYmFja2dyb3VuZCIsInRvb2xiYXJDZW50ZXIiLCJJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciIsIk1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IiLCJibGFja01hc2tPcGFjaXR5IiwiTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIiwiTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciIsInJld3JpdGFibGVzIiwibmF2aWdhdG9yRWxlbWVudCIsIk5hdmlnYXRvckVsZW1lbnQiLCJfaXNSdW5uaW5nIiwiX2luaXRpYWxpemVkIiwiX3BhZ2VMb2FkZXIiLCJfcGFnZU1hcCIsIl9wYWdlIiwiX29uRGV2aWNlQmFja0J1dHRvbiIsIl9nZXRQYWdlVGFyZ2V0IiwicHVzaFBhZ2UiLCJ0b3BQYWdlIiwiX3Nob3ciLCJfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uIiwiX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyIsInBvcFVwZGF0ZSIsInVubG9hZCIsIl9wb3BQYWdlIiwiX3BvcFBhZ2VBbmRSZWZyZXNoIiwib2xkUGFnZSIsInB1c2hlZE9wdGlvbnMiLCJkYXRhIiwibG9hZCIsInVwZGF0ZSIsIl9lbWl0UHJlUG9wRXZlbnQiLCJ1cGRhdGVCYWNrQnV0dG9uIiwiX2hpZGUiLCJwb3AiLCJfdmVyaWZ5UGFnZUVsZW1lbnQiLCJwYWdlSFRNTCIsIl9wdXNoUGFnZSIsIl9lbWl0UHJlUHVzaEV2ZW50IiwicGFnZUxlbmd0aCIsInJlc29sdmVkVmFsdWUiLCJfbm9ybWFsaXplSW5kZXgiLCJfbGFzdEluZGV4T2ZQYWdlIiwicGFnZU5hbWUiLCJpc0NhbmNlbGVkIiwiX2VtaXRQcmVFdmVudCIsInRlbXBsYXRlSFRNTCIsInBhZ2VMb2FkZXIiLCJUb29sYmFyRWxlbWVudCIsIl9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzIiwibm9kZVR5cGUiLCJfZW5zdXJlVG9vbGJhckVsZW1lbnQiLCJudWxsVG9vbGJhckVsZW1lbnQiLCJQYWdlRWxlbWVudCIsIl9pc1Nob3duIiwiX2NvbnRlbnRFbGVtZW50IiwiX2lzTXV0ZWQiLCJfc2tpcEluaXQiLCJfdHJ5VG9GaWxsU3RhdHVzQmFyIiwiYmFja0J1dHRvbiIsImZpbGxlZCIsIl9oYXNBUGFnZUNvbnRyb2xDaGlsZCIsIm92ZXJMaW1pdCIsInNjcm9sbFRvcCIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsIl9pbmZpbml0ZVNjcm9sbExpbWl0IiwiX29uSW5maW5pdGVTY3JvbGwiLCJfbG9hZGluZ0NvbnRlbnQiLCJvbkluZmluaXRlU2Nyb2xsIiwiX2VsZW1lbnRTaG91bGRCZU1vdmVkIiwicHJldk5vZGUiLCJmaXhlZEVsZW1lbnRzIiwiX2JvdW5kT25TY3JvbGwiLCJfb25TY3JvbGwiLCJQb3BvdmVyQW5pbWF0b3IiLCJmcm9tIiwidG8iLCJyZXN0b3JlIiwiYW5pbWF0aW9ucyIsIl9hbmltYXRlIiwiZmFkZSIsIk1ERmFkZVBvcG92ZXJBbmltYXRvciIsIl9hbmltYXRlQWxsIiwiaW4iLCJvdXQiLCJJT1NGYWRlUG9wb3ZlckFuaW1hdG9yIiwidGVtcGxhdGVTb3VyY2UiLCJwb3NpdGlvbnMiLCJQb3BvdmVyRWxlbWVudCIsIl9pbml0QW5pbWF0b3JGYWN0b3J5IiwiZmFjdG9yeSIsIl9hbmltYXRvciIsInJhZGl1cyIsIl9yYWRpdXMiLCJfY29udGVudCIsIm1hcmdpbiIsIl9tYXJnaW4iLCJpc01EIiwiY292ZXIiLCJib3R0b20iLCJfY2FsY3VsYXRlRGlyZWN0aW9ucyIsInZlcnRpY2FsIiwicHJpbWFyeSIsInNlY29uZGFyeSIsIl9wb3BvdmVyIiwic2l6ZXMiLCJfYXJyb3ciLCJfc2V0VHJhbnNmb3JtT3JpZ2luIiwiY2FsYyIsIm8iLCJfY3VycmVudFRhcmdldCIsIl9wb3NpdGlvblBvcG92ZXIiLCJoYXNEZWZhdWx0Q29udGFpbmVyIiwiYXJyb3ciLCJjbG9uZU5vZGUiLCJhY3Rpb25zIiwiYmVmb3JlIiwiYWZ0ZXIiLCJfcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMiLCJjYW5jZWxlZCIsIl9leGVjdXRlQWN0aW9uIiwiX2NsZWFyU3R5bGVzIiwiX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIiLCJQcm9ncmVzc0JhckVsZW1lbnQiLCJfaXNDb21waWxlZCIsIl90ZW1wbGF0ZSIsIl9wcmltYXJ5IiwiX3NlY29uZGFyeSIsIl91cGRhdGVEZXRlcm1pbmF0ZSIsIl91cGRhdGVWYWx1ZSIsImJhckVsZW1lbnQiLCJQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCIsInBlciIsInN2ZyIsIlNUQVRFX0lOSVRJQUwiLCJTVEFURV9QUkVBQ1RJT04iLCJTVEFURV9BQ1RJT04iLCJyZW1vdmVUcmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJXZWJraXRUcmFuc2l0aW9uIiwiUHVsbEhvb2tFbGVtZW50IiwiX2JvdW5kT25EcmFnU3RhcnQiLCJfb25EcmFnU3RhcnQiLCJfc2V0U3RhdGUiLCJsaW5lSGVpZ2h0IiwibWFyZ2luVG9wIiwiX3BhZ2VFbGVtZW50IiwiZGlzYWJsZWQiLCJfc3RhcnRTY3JvbGwiLCJfY3VycmVudFRyYW5zbGF0aW9uIiwiX2dldEN1cnJlbnRTY3JvbGwiLCJfdHJhbnNpdGlvbkRyYWdMZW5ndGgiLCJfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCIsInRocmVzaG9sZEhlaWdodCIsIl9maW5pc2giLCJfdHJhbnNsYXRlVG8iLCJhbmltYXRlIiwib25BY3Rpb24iLCJ0aCIsIm5vRXZlbnQiLCJsYXN0U3RhdGUiLCJfZ2V0U3RhdGUiLCJfaXNDb250ZW50Rml4ZWQiLCJfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQiLCJfZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybSIsIl9kcmFnTG9ja0Rpc2FibGVkIiwiX2Rlc3Ryb3lFdmVudExpc3RlbmVycyIsIl9jcmVhdGVFdmVudExpc3RlbmVycyIsIl9zZXRTdHlsZSIsIl9vbkFjdGlvbiIsIkFuaW1hdG9yQ1NTIiwiZmluYWwiLCJnZXRUaW1lIiwiaW5pdGlhbCIsIm5leHQiLCJ1cGRhdGVTdHlsZXMiLCJjbGVhclRpbWVvdXQiLCJrIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic3RvcE5leHQiLCJjYiIsIm5ld0R1cmF0aW9uIiwicGFzc2VkIiwicmVtYWluaW5nIiwic3BlZWRVcFRpbWUiLCJzdG9wIiwibWlsbGlzZWNvbmRzIiwic3BlZWQiLCJ2IiwidHJhbnNpdGlvblByb3BlcnR5IiwiX29uU3RvcEFuaW1hdGlvbnMiLCJfcXVldWUiLCJfaW5kZXgiLCJzdG9wQW5pbWF0aW9ucyIsIlJpcHBsZUVsZW1lbnQiLCJfd2F2ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYmFja2dyb3VuZCIsInIiLCJfY2VudGVyIiwiX21pblIiLCJfY2FsY3VsYXRlQ29vcmRzIiwic3RvcEFsbCIsImNvbXB1dGVkU3R5bGUiLCJfdXBkYXRlUGFyZW50IiwiX3JpcHBsZUFuaW1hdGlvbiIsIl9ob2xkaW5nIiwiX2JvdW5kT25SZWxlYXNlIiwiX29uVGFwIiwiX3BhcmVudE5vZGUiLCJfYm91bmRPblRhcCIsIl9ib3VuZE9uSG9sZCIsIl9vbkhvbGQiLCJwbiIsIlJvd0VsZW1lbnQiLCJTZWxlY3RFbGVtZW50IiwiX3NlbGVjdCIsInNlbCIsIl9fZGVmaW5lR2V0dGVyX18iLCJfX2RlZmluZVNldHRlcl9fIiwib3B0aW9uIiwiU3BlZWREaWFsSXRlbUVsZW1lbnQiLCJfdXBkYXRlQ2xhc3NOYW1lIiwiZXZlcnkiLCJzdHlsZXIiLCJfcHJlZml4IiwicHJlZml4IiwiY2xlYXIiLCJfY2xlYXIiLCJTcGVlZERpYWxFbGVtZW50IiwiX2l0ZW1TaG93biIsIl91cGRhdGVEaXJlY3Rpb24iLCJ0b2dnbGVJdGVtcyIsImlubGluZSIsIl9mYWIiLCJoaWRlSXRlbXMiLCJ0b3RhbERlbGF5IiwiaXNPcGVuIiwic2hvd0l0ZW1zIiwiU3BsaXR0ZXJDb250ZW50RWxlbWVudCIsIm9sZENvbnRlbnQiLCJTcGxpdHRlck1hc2tFbGVtZW50IiwiX3NpZGVzIiwic2lkZSIsImNsb3NlIiwiU3BsaXR0ZXJBbmltYXRvciIsInNpZGVFbGVtZW50Iiwic3BsaXR0ZXIiLCJfc2lkZSIsIm1pbnVzIiwiU3BsaXR0ZXJFbGVtZW50IiwiX2xheW91dCIsIm1vZGUiLCJfd2lkdGgiLCJfYm91bmRPbk1vZGVDaGFuZ2UiLCJfb25Nb2RlQ2hhbmdlIiwiX2dldFNpZGUiLCJTUExJVF9NT0RFIiwiQ09MTEFQU0VfTU9ERSIsIkNMT1NFRF9TVEFURSIsIk9QRU5fU1RBVEUiLCJDSEFOR0lOR19TVEFURSIsIldBVENIRURfQVRUUklCVVRFUyIsInNwbGl0dGVyU2lkZUVsZW1lbnQiLCJDb2xsYXBzZURldGVjdGlvbiIsImNoYW5nZVRhcmdldCIsIl90YXJnZXQiLCJfb3JpZW50YXRpb24iLCJhY3RpdmF0ZSIsIl91cGRhdGVNb2RlIiwiX21hdGNoIiwiX3F1ZXJ5UmVzdWx0IiwibWF0Y2hNZWRpYSIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJ3aWR0aFRvUHgiLCJweCIsIm9mZnNldFdpZHRoIiwiQ29sbGFwc2VNb2RlIiwiX2FjdGl2ZSIsIl9zdGF0ZSIsIl9sb2NrIiwiX2lzT3Blbk90aGVyU2lkZU1lbnUiLCJfaWdub3JlRHJhZyIsInNjcm9sbGluZyIsImFyZWEiLCJfc3dpcGVUYXJnZXRXaWR0aCIsIl9zdGFydERpc3RhbmNlIiwiX2Rpc3RhbmNlIiwidHJhbnNsYXRlIiwic2hvdWxkT3BlbiIsIl90aHJlc2hvbGQiLCJleGVjdXRlQWN0aW9uIiwibGF5b3V0IiwiRklOQUxfU1RBVEUiLCJfZW1pdEV2ZW50Iiwid2l0aG91dEFuaW1hdGlvbiIsIlNwbGl0dGVyU2lkZUVsZW1lbnQiLCJfY29sbGFwc2VNb2RlIiwiX2NvbGxhcHNlRGV0ZWN0aW9uIiwiX2JvdW5kSGFuZGxlR2VzdHVyZSIsImhhbmRsZUdlc3R1cmUiLCJfd2F0Y2hlZEF0dHJpYnV0ZXMiLCJfbW9kZSIsInRocmVzaG9sZCIsInVwZGF0ZU9wdGlvbnMiLCJsb2NhdGlvbnMiLCJTd2l0Y2hFbGVtZW50IiwiX2NoZWNrZWQiLCJfZGlzYWJsZWQiLCJfY2hlY2tib3giLCJfaGFuZGxlIiwiY2xpY2siLCJfbG9jYXRpb25zIiwiX3N0YXJ0WCIsIl9nZXRQb3NpdGlvbiIsInByZXZpb3VzVmFsdWUiLCJfaXNNYXRlcmlhbCIsIlRhYmJhckFuaW1hdG9yIiwiZW50ZXJQYWdlSW5kZXgiLCJsZWF2ZVBhZ2VJbmRleCIsIlRhYmJhck5vbmVBbmltYXRvciIsImVudGVySW5kZXgiLCJsZWF2ZUluZGV4IiwiVGFiYmFyRmFkZUFuaW1hdG9yIiwiVGFiYmFyU2xpZGVBbmltYXRvciIsInNnbiIsInRhYmJhckVsZW1lbnQiLCJUYWJiYXJFbGVtZW50IiwiX3RhYmJhcklkIiwiYWN0aXZlSW5kZXgiLCJ0YWJiYXIiLCJfdGFiYmFyRWxlbWVudCIsImJhciIsIl90b3AiLCJ0YWIiLCJUYWJFbGVtZW50IiwiX2xvYWRQYWdlIiwiX2xvYWRQYWdlRE9NQXN5bmMiLCJnZXRBY3RpdmVUYWJJbmRleCIsIl9zd2l0Y2hQYWdlIiwiX29sZFBhZ2VFbGVtZW50Iiwib2xkUGFnZUVsZW1lbnQiLCJzZWxlY3RlZFRhYkluZGV4IiwicHJldmlvdXNUYWJJbmRleCIsInByZXZpb3VzVGFiIiwiX2dldEFjdGl2ZVRhYkVsZW1lbnQiLCJzZWxlY3RlZFRhYiIsIl9nZXRUYWJFbGVtZW50IiwicHJldmlvdXNQYWdlRWxlbWVudCIsIl9nZXRDdXJyZW50UGFnZUVsZW1lbnQiLCJzZXRJbmFjdGl2ZSIsInNldEFjdGl2ZSIsIl9sb2FkUGFnZUVsZW1lbnQiLCJfZ2V0VGFiYmFyRWxlbWVudCIsInNldFRhYmJhclZpc2liaWxpdHkiLCJ0YWJzIiwiaXNBY3RpdmUiLCJjdXJyZW50UGFnZUVsZW1lbnQiLCJkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSIsImhhc0lucHV0IiwiaGFzQnV0dG9uIiwiX3RlbXBsYXRlTG9hZGVkIiwiaGFzQ2hpbGRyZW4iLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiX2hhc0RlZmF1bHRUZW1wbGF0ZSIsIl91cGRhdGVEZWZhdWx0VGVtcGxhdGUiLCJiYWRnZSIsImljb25FbGVtZW50IiwiZ2V0SWNvbkVsZW1lbnQiLCJnZXRMYWJlbEVsZW1lbnQiLCJnZXRCYWRnZUVsZW1lbnQiLCJfZmluZFRhYmJhckVsZW1lbnQiLCJzZXRBY3RpdmVUYWIiLCJfZmluZFRhYkluZGV4IiwicmFkaW8iLCJfbG9hZGVkUGFnZSIsIl9sb2FkaW5nUGFnZSIsIl9lbnN1cmVFbGVtZW50UG9zaXRpb24iLCJoYXNMb2FkZWQiLCJUb29sYmFyQnV0dG9uRWxlbWVudCIsIlJhbmdlRWxlbWVudCIsIl9sZWZ0IiwiX3JhdGlvIiwiX29uRHJhZ3N0YXJ0IiwiZmFzdENsaWNrIiwiRmFzdENsaWNrIiwiYXR0YWNoIiwiYXBwIiwiZXhpdEFwcCIsIlZpZXdwb3J0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFKLEdBQXNDeEIsTUFBSUcsMkJBQUosQ0FBZ0NpRyxhQUFoQyxDQUE4Q2x5QixPQUFPN0MsUUFBUCxDQUFnQnVlLElBQTlELEVBQW9FLFlBQU07Y0FDcEd5OEIsR0FBVixDQUFjQyxPQUFkO0dBRG9DLENBQXRDO1dBR1MxOEIsSUFBVCxDQUFjMmEsZ0JBQWQsR0FBaUMsSUFBSXZLLE1BQUlwakIsZUFBUixDQUF3QnZMLFNBQVN1ZSxJQUFqQyxDQUFqQztDQUxGLEVBTUcsS0FOSDs7O0FBU0FvUSxNQUFJb0IsS0FBSixDQUFVLFlBQVc7UUFDZmlDLHlCQUFKO0NBREY7OztBQUtBLElBQUlrcEIsUUFBSixHQUFlOXRDLEtBQWYsR0FFQSIsImZpbGUiOiJvbnNlbnVpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKCF3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBDdXN0b21FdmVudDtcblxuICAgIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgdmFyIGV2dDtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgfSkoKTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjIyXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiX19zdFwiICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArIFwiX19cIik7XG4gICAgfTtcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZW50cnlbMF0gPSBlbnRyeVsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuV2Vha01hcCA9IFdlYWtNYXA7XG4gIH0pKCk7XG59XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XG4gIH1cbn0pKHNlbGYpOyIsIi8qXHJcbiAqIGNoaWxkTm9kZS5yZW1vdmUgbWV0aG9kIHBvbHlmaWxsIGZvciBJRS5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NoaWxkTm9kZS9yZW1vdmVcclxuICovXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0aWYgKCEoJ3JlbW92ZScgaW4gRWxlbWVudC5wcm90b3R5cGUpKSB7XHJcblx0ICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHQgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG5cdCAgICBcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHR9XHJcbn0pKCk7XHJcbiIsIi8qXHJcbiAqIGNsYXNzTGlzdC5qczogQ3Jvc3MtYnJvd3NlciBmdWxsIGVsZW1lbnQuY2xhc3NMaXN0IGltcGxlbWVudGF0aW9uLlxyXG4gKiAxLjEuMjAxNTAzMTJcclxuICpcclxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxyXG4gKiBMaWNlbnNlOiBEZWRpY2F0ZWQgdG8gdGhlIHB1YmxpYyBkb21haW4uXHJcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXHJcbiAqL1xyXG5cclxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xyXG5cclxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cclxuXHJcbmlmIChcImRvY3VtZW50XCIgaW4gc2VsZikge1xyXG5cclxuLy8gRnVsbCBwb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aCBubyBjbGFzc0xpc3Qgc3VwcG9ydFxyXG4vLyBJbmNsdWRpbmcgSUUgPCBFZGdlIG1pc3NpbmcgU1ZHRWxlbWVudC5jbGFzc0xpc3RcclxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSlcclxuICB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJnXCIpKSkge1xyXG5cclxuKGZ1bmN0aW9uICh2aWV3KSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xyXG5cclxudmFyXHJcbiAgICBjbGFzc0xpc3RQcm9wID0gXCJjbGFzc0xpc3RcIlxyXG4gICwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxyXG4gICwgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF1cclxuICAsIG9iakN0ciA9IE9iamVjdFxyXG4gICwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XHJcbiAgfVxyXG4gICwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgdmFyXHJcbiAgICAgICAgaSA9IDBcclxuICAgICAgLCBsZW4gPSB0aGlzLmxlbmd0aFxyXG4gICAgO1xyXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuICAvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcclxuICAsIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubmFtZSA9IHR5cGU7XHJcbiAgICB0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gIH1cclxuICAsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XHJcbiAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4KFxyXG4gICAgICAgICAgXCJTWU5UQVhfRVJSXCJcclxuICAgICAgICAsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXHJcbiAgICAgICAgICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXHJcbiAgICAgICAgLCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xyXG4gIH1cclxuICAsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXJcclxuICAgICAgICB0cmltbWVkQ2xhc3NlcyA9IHN0clRyaW0uY2FsbChlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpXHJcbiAgICAgICwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXHJcbiAgICAgICwgaSA9IDBcclxuICAgICAgLCBsZW4gPSBjbGFzc2VzLmxlbmd0aFxyXG4gICAgO1xyXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcclxuICAgIH07XHJcbiAgfVxyXG4gICwgY2xhc3NMaXN0UHJvdG8gPSBDbGFzc0xpc3RbcHJvdG9Qcm9wXSA9IFtdXHJcbiAgLCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcclxuICB9XHJcbjtcclxuLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxyXG4vLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cclxuRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XHJcbmNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xyXG4gIHJldHVybiB0aGlzW2ldIHx8IG51bGw7XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgdG9rZW4gKz0gXCJcIjtcclxuICByZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXJcclxuICAgICAgdG9rZW5zID0gYXJndW1lbnRzXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXHJcbiAgICAsIHRva2VuXHJcbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxyXG4gIDtcclxuICBkbyB7XHJcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XHJcbiAgICBpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5wdXNoKHRva2VuKTtcclxuICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlICgrK2kgPCBsKTtcclxuXHJcbiAgaWYgKHVwZGF0ZWQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhclxyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcclxuICAgICwgaSA9IDBcclxuICAgICwgbCA9IHRva2Vucy5sZW5ndGhcclxuICAgICwgdG9rZW5cclxuICAgICwgdXBkYXRlZCA9IGZhbHNlXHJcbiAgICAsIGluZGV4XHJcbiAgO1xyXG4gIGRvIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcclxuICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcclxuICAgIHdoaWxlIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoKytpIDwgbCk7XHJcblxyXG4gIGlmICh1cGRhdGVkKSB7XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcclxuICB0b2tlbiArPSBcIlwiO1xyXG5cclxuICB2YXJcclxuICAgICAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcclxuICAgICwgbWV0aG9kID0gcmVzdWx0ID9cclxuICAgICAgZm9yY2UgIT09IHRydWUgJiYgXCJyZW1vdmVcIlxyXG4gICAgOlxyXG4gICAgICBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIlxyXG4gIDtcclxuXHJcbiAgaWYgKG1ldGhvZCkge1xyXG4gICAgdGhpc1ttZXRob2RdKHRva2VuKTtcclxuICB9XHJcblxyXG4gIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmb3JjZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICFyZXN1bHQ7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcclxufTtcclxuXHJcbmlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcclxuICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XHJcbiAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyXHJcbiAgICAsIGVudW1lcmFibGU6IHRydWVcclxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfTtcclxuICB0cnkge1xyXG4gICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xyXG4gIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxyXG4gICAgaWYgKGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcclxuICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcclxuICBlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xyXG59XHJcblxyXG59KHNlbGYpKTtcclxuXHJcbn0gZWxzZSB7XHJcbi8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxyXG4vLyB0byBub3JtYWxpemUgdGhlIGFkZC9yZW1vdmUgYW5kIHRvZ2dsZSBBUElzLlxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIik7XHJcblxyXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpO1xyXG5cclxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAvMTEgYW5kIEZpcmVmb3ggPDI2LCB3aGVyZSBjbGFzc0xpc3QuYWRkIGFuZFxyXG4gIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxyXG4gIGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzJcIikpIHtcclxuICAgIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xyXG5cclxuICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICB2YXIgaSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgIG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjcmVhdGVNZXRob2QoJ2FkZCcpO1xyXG4gICAgY3JlYXRlTWV0aG9kKCdyZW1vdmUnKTtcclxuICB9XHJcblxyXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XHJcblxyXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcclxuICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAgaWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMzXCIpKSB7XHJcbiAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xyXG5cclxuICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24odG9rZW4sIGZvcmNlKSB7XHJcbiAgICAgIGlmICgxIGluIGFyZ3VtZW50cyAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xyXG4gICAgICAgIHJldHVybiBmb3JjZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgfVxyXG5cclxuICB0ZXN0RWxlbWVudCA9IG51bGw7XHJcbn0oKSk7XHJcblxyXG59XHJcblxyXG59XHJcblxyXG4iLCIvKiFcblxuQ29weXJpZ2h0IChDKSAyMDE0LTIwMTYgYnkgQW5kcmVhIEdpYW1tYXJjaGkgLSBAV2ViUmVmbGVjdGlvblxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG5cbmlmICgnY3VzdG9tRWxlbWVudHMnIGluIHdpbmRvdykge1xuICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lID0gdW5kZWZpbmVkO1xufVxuXG4oZnVuY3Rpb24od2luZG93KXsndXNlIHN0cmljdCc7XG5cbiAgLy8gRE8gTk9UIFVTRSBUSElTIEZJTEUgRElSRUNUTFksIElUIFdPTidUIFdPUktcbiAgLy8gVEhJUyBJUyBBIFBST0pFQ1QgQkFTRUQgT04gQSBCVUlMRCBTWVNURU1cbiAgLy8gVEhJUyBGSUxFIElTIEpVU1QgV1JBUFBFRCBVUCBSRVNVTFRJTkcgSU5cbiAgLy8gYnVpbGQvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC5qc1xuICAvLyBhbmQgaXRzIC5tYXguanMgY291bnRlciBwYXJ0XG5cbiAgdmFyXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG4gICAgT2JqZWN0ID0gd2luZG93Lk9iamVjdFxuICA7XG5cbiAgdmFyIGh0bWxDbGFzcyA9IChmdW5jdGlvbiAoaW5mbykge1xuICAgIC8vIChDKSBBbmRyZWEgR2lhbW1hcmNoaSAtIEBXZWJSZWZsZWN0aW9uIC0gTUlUIFN0eWxlXG4gICAgdmFyXG4gICAgICBjYXRjaENsYXNzID0gL15bQS1aXStbYS16XS8sXG4gICAgICBmaWx0ZXJCeSA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICB2YXIgYXJyID0gW10sIHRhZztcbiAgICAgICAgZm9yICh0YWcgaW4gcmVnaXN0ZXIpIHtcbiAgICAgICAgICBpZiAocmUudGVzdCh0YWcpKSBhcnIucHVzaCh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9LFxuICAgICAgYWRkID0gZnVuY3Rpb24gKENsYXNzLCB0YWcpIHtcbiAgICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghKHRhZyBpbiByZWdpc3RlcikpIHtcbiAgICAgICAgICByZWdpc3RlcltDbGFzc10gPSAocmVnaXN0ZXJbQ2xhc3NdIHx8IFtdKS5jb25jYXQodGFnKTtcbiAgICAgICAgICByZWdpc3Rlclt0YWddID0gKHJlZ2lzdGVyW3RhZy50b1VwcGVyQ2FzZSgpXSA9IENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyID0gKE9iamVjdC5jcmVhdGUgfHwgT2JqZWN0KShudWxsKSxcbiAgICAgIGh0bWxDbGFzcyA9IHt9LFxuICAgICAgaSwgc2VjdGlvbiwgdGFncywgQ2xhc3NcbiAgICA7XG4gICAgZm9yIChzZWN0aW9uIGluIGluZm8pIHtcbiAgICAgIGZvciAoQ2xhc3MgaW4gaW5mb1tzZWN0aW9uXSkge1xuICAgICAgICB0YWdzID0gaW5mb1tzZWN0aW9uXVtDbGFzc107XG4gICAgICAgIHJlZ2lzdGVyW0NsYXNzXSA9IHRhZ3M7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVnaXN0ZXJbdGFnc1tpXS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgcmVnaXN0ZXJbdGFnc1tpXS50b1VwcGVyQ2FzZSgpXSA9IENsYXNzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGh0bWxDbGFzcy5nZXQgPSBmdW5jdGlvbiBnZXQodGFnT3JDbGFzcykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0YWdPckNsYXNzID09PSAnc3RyaW5nJyA/XG4gICAgICAgIChyZWdpc3Rlclt0YWdPckNsYXNzXSB8fCAoY2F0Y2hDbGFzcy50ZXN0KHRhZ09yQ2xhc3MpID8gW10gOiAnJykpIDpcbiAgICAgICAgZmlsdGVyQnkodGFnT3JDbGFzcyk7XG4gICAgfTtcbiAgICBodG1sQ2xhc3Muc2V0ID0gZnVuY3Rpb24gc2V0KHRhZywgQ2xhc3MpIHtcbiAgICAgIHJldHVybiAoY2F0Y2hDbGFzcy50ZXN0KHRhZykgP1xuICAgICAgICBhZGQodGFnLCBDbGFzcykgOlxuICAgICAgICBhZGQoQ2xhc3MsIHRhZylcbiAgICAgICksIGh0bWxDbGFzcztcbiAgICB9O1xuICAgIHJldHVybiBodG1sQ2xhc3M7XG4gIH0oe1xuICAgIFwiY29sbGVjdGlvbnNcIjoge1xuICAgICAgXCJIVE1MQWxsQ29sbGVjdGlvblwiOiBbXG4gICAgICAgIFwiYWxsXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxDb2xsZWN0aW9uXCI6IFtcbiAgICAgICAgXCJmb3Jtc1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvblwiOiBbXG4gICAgICAgIFwiZWxlbWVudHNcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE9wdGlvbnNDb2xsZWN0aW9uXCI6IFtcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZWxlbWVudHNcIjoge1xuICAgICAgXCJFbGVtZW50XCI6IFtcbiAgICAgICAgXCJlbGVtZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxBbmNob3JFbGVtZW50XCI6IFtcbiAgICAgICAgXCJhXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxBcHBsZXRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJhcHBsZXRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEFyZWFFbGVtZW50XCI6IFtcbiAgICAgICAgXCJhcmVhXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxBdHRhY2htZW50RWxlbWVudFwiOiBbXG4gICAgICAgIFwiYXR0YWNobWVudFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQXVkaW9FbGVtZW50XCI6IFtcbiAgICAgICAgXCJhdWRpb1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQlJFbGVtZW50XCI6IFtcbiAgICAgICAgXCJiclwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQmFzZUVsZW1lbnRcIjogW1xuICAgICAgICBcImJhc2VcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEJvZHlFbGVtZW50XCI6IFtcbiAgICAgICAgXCJib2R5XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxCdXR0b25FbGVtZW50XCI6IFtcbiAgICAgICAgXCJidXR0b25cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTENhbnZhc0VsZW1lbnRcIjogW1xuICAgICAgICBcImNhbnZhc1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MQ29udGVudEVsZW1lbnRcIjogW1xuICAgICAgICBcImNvbnRlbnRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTERMaXN0RWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGxcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTERhdGFFbGVtZW50XCI6IFtcbiAgICAgICAgXCJkYXRhXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEYXRhTGlzdEVsZW1lbnRcIjogW1xuICAgICAgICBcImRhdGFsaXN0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEZXRhaWxzRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGV0YWlsc1wiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRGlhbG9nRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGlhbG9nXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEaXJlY3RvcnlFbGVtZW50XCI6IFtcbiAgICAgICAgXCJkaXJcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTERpdkVsZW1lbnRcIjogW1xuICAgICAgICBcImRpdlwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRG9jdW1lbnRcIjogW1xuICAgICAgICBcImRvY3VtZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxFbGVtZW50XCI6IFtcbiAgICAgICAgXCJlbGVtZW50XCIsXG4gICAgICAgIFwiYWJiclwiLFxuICAgICAgICBcImFkZHJlc3NcIixcbiAgICAgICAgXCJhcnRpY2xlXCIsXG4gICAgICAgIFwiYXNpZGVcIixcbiAgICAgICAgXCJiXCIsXG4gICAgICAgIFwiYmRpXCIsXG4gICAgICAgIFwiYmRvXCIsXG4gICAgICAgIFwiY2l0ZVwiLFxuICAgICAgICBcImNvZGVcIixcbiAgICAgICAgXCJjb21tYW5kXCIsXG4gICAgICAgIFwiZGRcIixcbiAgICAgICAgXCJkZm5cIixcbiAgICAgICAgXCJkdFwiLFxuICAgICAgICBcImVtXCIsXG4gICAgICAgIFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBcImZpZ3VyZVwiLFxuICAgICAgICBcImZvb3RlclwiLFxuICAgICAgICBcImhlYWRlclwiLFxuICAgICAgICBcImlcIixcbiAgICAgICAgXCJrYmRcIixcbiAgICAgICAgXCJtYXJrXCIsXG4gICAgICAgIFwibmF2XCIsXG4gICAgICAgIFwibm9zY3JpcHRcIixcbiAgICAgICAgXCJycFwiLFxuICAgICAgICBcInJ0XCIsXG4gICAgICAgIFwicnVieVwiLFxuICAgICAgICBcInNcIixcbiAgICAgICAgXCJzYW1wXCIsXG4gICAgICAgIFwic2VjdGlvblwiLFxuICAgICAgICBcInNtYWxsXCIsXG4gICAgICAgIFwic3Ryb25nXCIsXG4gICAgICAgIFwic3ViXCIsXG4gICAgICAgIFwic3VtbWFyeVwiLFxuICAgICAgICBcInN1cFwiLFxuICAgICAgICBcInVcIixcbiAgICAgICAgXCJ2YXJcIixcbiAgICAgICAgXCJ3YnJcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEVtYmVkRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZW1iZWRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEZpZWxkU2V0RWxlbWVudFwiOiBbXG4gICAgICAgIFwiZmllbGRzZXRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEZvbnRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJmb250XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxGb3JtRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZm9ybVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRnJhbWVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJmcmFtZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MRnJhbWVTZXRFbGVtZW50XCI6IFtcbiAgICAgICAgXCJmcmFtZXNldFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MSFJFbGVtZW50XCI6IFtcbiAgICAgICAgXCJoclwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MSGVhZEVsZW1lbnRcIjogW1xuICAgICAgICBcImhlYWRcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEhlYWRpbmdFbGVtZW50XCI6IFtcbiAgICAgICAgXCJoMVwiLFxuICAgICAgICBcImgyXCIsXG4gICAgICAgIFwiaDNcIixcbiAgICAgICAgXCJoNFwiLFxuICAgICAgICBcImg1XCIsXG4gICAgICAgIFwiaDZcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEh0bWxFbGVtZW50XCI6IFtcbiAgICAgICAgXCJodG1sXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxJRnJhbWVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJpZnJhbWVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTEltYWdlRWxlbWVudFwiOiBbXG4gICAgICAgIFwiaW1nXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxJbnB1dEVsZW1lbnRcIjogW1xuICAgICAgICBcImlucHV0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxLZXlnZW5FbGVtZW50XCI6IFtcbiAgICAgICAgXCJrZXlnZW5cIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTExJRWxlbWVudFwiOiBbXG4gICAgICAgIFwibGlcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTExhYmVsRWxlbWVudFwiOiBbXG4gICAgICAgIFwibGFiZWxcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTExlZ2VuZEVsZW1lbnRcIjogW1xuICAgICAgICBcImxlZ2VuZFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTGlua0VsZW1lbnRcIjogW1xuICAgICAgICBcImxpbmtcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1hcEVsZW1lbnRcIjogW1xuICAgICAgICBcIm1hcFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTWFycXVlZUVsZW1lbnRcIjogW1xuICAgICAgICBcIm1hcnF1ZWVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1lZGlhRWxlbWVudFwiOiBbXG4gICAgICAgIFwibWVkaWFcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE1lbnVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJtZW51XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxNZW51SXRlbUVsZW1lbnRcIjogW1xuICAgICAgICBcIm1lbnVpdGVtXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxNZXRhRWxlbWVudFwiOiBbXG4gICAgICAgIFwibWV0YVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTWV0ZXJFbGVtZW50XCI6IFtcbiAgICAgICAgXCJtZXRlclwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MTW9kRWxlbWVudFwiOiBbXG4gICAgICAgIFwiZGVsXCIsXG4gICAgICAgIFwiaW5zXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxPTGlzdEVsZW1lbnRcIjogW1xuICAgICAgICBcIm9sXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxPYmplY3RFbGVtZW50XCI6IFtcbiAgICAgICAgXCJvYmplY3RcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE9wdEdyb3VwRWxlbWVudFwiOiBbXG4gICAgICAgIFwib3B0Z3JvdXBcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTE9wdGlvbkVsZW1lbnRcIjogW1xuICAgICAgICBcIm9wdGlvblwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MT3V0cHV0RWxlbWVudFwiOiBbXG4gICAgICAgIFwib3V0cHV0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxQYXJhZ3JhcGhFbGVtZW50XCI6IFtcbiAgICAgICAgXCJwXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxQYXJhbUVsZW1lbnRcIjogW1xuICAgICAgICBcInBhcmFtXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxQaWN0dXJlRWxlbWVudFwiOiBbXG4gICAgICAgIFwicGljdHVyZVwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MUHJlRWxlbWVudFwiOiBbXG4gICAgICAgIFwicHJlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxQcm9ncmVzc0VsZW1lbnRcIjogW1xuICAgICAgICBcInByb2dyZXNzXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxRdW90ZUVsZW1lbnRcIjogW1xuICAgICAgICBcImJsb2NrcXVvdGVcIixcbiAgICAgICAgXCJxXCIsXG4gICAgICAgIFwicXVvdGVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFNjcmlwdEVsZW1lbnRcIjogW1xuICAgICAgICBcInNjcmlwdFwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MU2VsZWN0RWxlbWVudFwiOiBbXG4gICAgICAgIFwic2VsZWN0XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTaGFkb3dFbGVtZW50XCI6IFtcbiAgICAgICAgXCJzaGFkb3dcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFNsb3RFbGVtZW50XCI6IFtcbiAgICAgICAgXCJzbG90XCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTb3VyY2VFbGVtZW50XCI6IFtcbiAgICAgICAgXCJzb3VyY2VcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFNwYW5FbGVtZW50XCI6IFtcbiAgICAgICAgXCJzcGFuXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxTdHlsZUVsZW1lbnRcIjogW1xuICAgICAgICBcInN0eWxlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZUNhcHRpb25FbGVtZW50XCI6IFtcbiAgICAgICAgXCJjYXB0aW9uXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZUNlbGxFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0ZFwiLFxuICAgICAgICBcInRoXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZUNvbEVsZW1lbnRcIjogW1xuICAgICAgICBcImNvbFwiLFxuICAgICAgICBcImNvbGdyb3VwXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZUVsZW1lbnRcIjogW1xuICAgICAgICBcInRhYmxlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZVJvd0VsZW1lbnRcIjogW1xuICAgICAgICBcInRyXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0aGVhZFwiLFxuICAgICAgICBcInRib2R5XCIsXG4gICAgICAgIFwidGZvb3RcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFRlbXBsYXRlRWxlbWVudFwiOiBbXG4gICAgICAgIFwidGVtcGxhdGVcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFRleHRBcmVhRWxlbWVudFwiOiBbXG4gICAgICAgIFwidGV4dGFyZWFcIlxuICAgICAgXSxcbiAgICAgIFwiSFRNTFRpbWVFbGVtZW50XCI6IFtcbiAgICAgICAgXCJ0aW1lXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUaXRsZUVsZW1lbnRcIjogW1xuICAgICAgICBcInRpdGxlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxUcmFja0VsZW1lbnRcIjogW1xuICAgICAgICBcInRyYWNrXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxVTGlzdEVsZW1lbnRcIjogW1xuICAgICAgICBcInVsXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxVbmtub3duRWxlbWVudFwiOiBbXG4gICAgICAgIFwidW5rbm93blwiLFxuICAgICAgICBcInZoZ3JvdXB2XCIsXG4gICAgICAgIFwidmtleWdlblwiXG4gICAgICBdLFxuICAgICAgXCJIVE1MVmlkZW9FbGVtZW50XCI6IFtcbiAgICAgICAgXCJ2aWRlb1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcIm5vZGVzXCI6IHtcbiAgICAgIFwiQXR0clwiOiBbXG4gICAgICAgIFwibm9kZVwiXG4gICAgICBdLFxuICAgICAgXCJBdWRpb1wiOiBbXG4gICAgICAgIFwiYXVkaW9cIlxuICAgICAgXSxcbiAgICAgIFwiQ0RBVEFTZWN0aW9uXCI6IFtcbiAgICAgICAgXCJub2RlXCJcbiAgICAgIF0sXG4gICAgICBcIkNoYXJhY3RlckRhdGFcIjogW1xuICAgICAgICBcIm5vZGVcIlxuICAgICAgXSxcbiAgICAgIFwiQ29tbWVudFwiOiBbXG4gICAgICAgIFwiI2NvbW1lbnRcIlxuICAgICAgXSxcbiAgICAgIFwiRG9jdW1lbnRcIjogW1xuICAgICAgICBcIiNkb2N1bWVudFwiXG4gICAgICBdLFxuICAgICAgXCJEb2N1bWVudEZyYWdtZW50XCI6IFtcbiAgICAgICAgXCIjZG9jdW1lbnQtZnJhZ21lbnRcIlxuICAgICAgXSxcbiAgICAgIFwiRG9jdW1lbnRUeXBlXCI6IFtcbiAgICAgICAgXCJub2RlXCJcbiAgICAgIF0sXG4gICAgICBcIkhUTUxEb2N1bWVudFwiOiBbXG4gICAgICAgIFwiI2RvY3VtZW50XCJcbiAgICAgIF0sXG4gICAgICBcIkltYWdlXCI6IFtcbiAgICAgICAgXCJpbWdcIlxuICAgICAgXSxcbiAgICAgIFwiT3B0aW9uXCI6IFtcbiAgICAgICAgXCJvcHRpb25cIlxuICAgICAgXSxcbiAgICAgIFwiUHJvY2Vzc2luZ0luc3RydWN0aW9uXCI6IFtcbiAgICAgICAgXCJub2RlXCJcbiAgICAgIF0sXG4gICAgICBcIlNoYWRvd1Jvb3RcIjogW1xuICAgICAgICBcIiNzaGFkb3ctcm9vdFwiXG4gICAgICBdLFxuICAgICAgXCJUZXh0XCI6IFtcbiAgICAgICAgXCIjdGV4dFwiXG4gICAgICBdLFxuICAgICAgXCJYTUxEb2N1bWVudFwiOiBbXG4gICAgICAgIFwieG1sXCJcbiAgICAgIF1cbiAgICB9XG4gIH0pKTtcbiAgXG4gIFxuICAgIHZhclxuICAgIC8vIFYwIHBvbHlmaWxsIGVudHJ5XG4gICAgUkVHSVNURVJfRUxFTUVOVCA9ICdyZWdpc3RlckVsZW1lbnQnLFxuICBcbiAgICAvLyBJRSA8IDExIG9ubHkgKyBvbGQgV2ViS2l0IGZvciBhdHRyaWJ1dGVzICsgZmVhdHVyZSBkZXRlY3Rpb25cbiAgICBFWFBBTkRPX1VJRCA9ICdfXycgKyBSRUdJU1RFUl9FTEVNRU5UICsgKHdpbmRvdy5NYXRoLnJhbmRvbSgpICogMTBlNCA+PiAwKSxcbiAgXG4gICAgLy8gc2hvcnRjdXRzIGFuZCBjb3N0YW50c1xuICAgIEFERF9FVkVOVF9MSVNURU5FUiA9ICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICBBVFRBQ0hFRCA9ICdhdHRhY2hlZCcsXG4gICAgQ0FMTEJBQ0sgPSAnQ2FsbGJhY2snLFxuICAgIERFVEFDSEVEID0gJ2RldGFjaGVkJyxcbiAgICBFWFRFTkRTID0gJ2V4dGVuZHMnLFxuICBcbiAgICBBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDSyA9ICdhdHRyaWJ1dGVDaGFuZ2VkJyArIENBTExCQUNLLFxuICAgIEFUVEFDSEVEX0NBTExCQUNLID0gQVRUQUNIRUQgKyBDQUxMQkFDSyxcbiAgICBDT05ORUNURURfQ0FMTEJBQ0sgPSAnY29ubmVjdGVkJyArIENBTExCQUNLLFxuICAgIERJU0NPTk5FQ1RFRF9DQUxMQkFDSyA9ICdkaXNjb25uZWN0ZWQnICsgQ0FMTEJBQ0ssXG4gICAgQ1JFQVRFRF9DQUxMQkFDSyA9ICdjcmVhdGVkJyArIENBTExCQUNLLFxuICAgIERFVEFDSEVEX0NBTExCQUNLID0gREVUQUNIRUQgKyBDQUxMQkFDSyxcbiAgXG4gICAgQURESVRJT04gPSAnQURESVRJT04nLFxuICAgIE1PRElGSUNBVElPTiA9ICdNT0RJRklDQVRJT04nLFxuICAgIFJFTU9WQUwgPSAnUkVNT1ZBTCcsXG4gIFxuICAgIERPTV9BVFRSX01PRElGSUVEID0gJ0RPTUF0dHJNb2RpZmllZCcsXG4gICAgRE9NX0NPTlRFTlRfTE9BREVEID0gJ0RPTUNvbnRlbnRMb2FkZWQnLFxuICAgIERPTV9TVUJUUkVFX01PRElGSUVEID0gJ0RPTVN1YnRyZWVNb2RpZmllZCcsXG4gIFxuICAgIFBSRUZJWF9UQUcgPSAnPCcsXG4gICAgUFJFRklYX0lTID0gJz0nLFxuICBcbiAgICAvLyB2YWxpZCBhbmQgaW52YWxpZCBub2RlIG5hbWVzXG4gICAgdmFsaWROYW1lID0gL15bQS1aXVtBLVowLTldKig/Oi1bQS1aMC05XSspKyQvLFxuICAgIGludmFsaWROYW1lcyA9IFtcbiAgICAgICdBTk5PVEFUSU9OLVhNTCcsXG4gICAgICAnQ09MT1ItUFJPRklMRScsXG4gICAgICAnRk9OVC1GQUNFJyxcbiAgICAgICdGT05ULUZBQ0UtU1JDJyxcbiAgICAgICdGT05ULUZBQ0UtVVJJJyxcbiAgICAgICdGT05ULUZBQ0UtRk9STUFUJyxcbiAgICAgICdGT05ULUZBQ0UtTkFNRScsXG4gICAgICAnTUlTU0lORy1HTFlQSCdcbiAgICBdLFxuICBcbiAgICAvLyByZWdpc3RlcmVkIHR5cGVzIGFuZCB0aGVpciBwcm90b3R5cGVzXG4gICAgdHlwZXMgPSBbXSxcbiAgICBwcm90b3MgPSBbXSxcbiAgXG4gICAgLy8gdG8gcXVlcnkgc3Vibm9kZXNcbiAgICBxdWVyeSA9ICcnLFxuICBcbiAgICAvLyBodG1sIHNob3J0Y3V0IHVzZWQgdG8gZmVhdHVyZSBkZXRlY3RcbiAgICBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIFxuICAgIC8vIEVTNSBpbmxpbmUgaGVscGVycyB8fCBiYXNpYyBwYXRjaGVzXG4gICAgaW5kZXhPZiA9IHR5cGVzLmluZGV4T2YgfHwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdjspe31cbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gIFxuICAgIC8vIG90aGVyIGhlbHBlcnMgLyBzaG9ydGN1dHNcbiAgICBPUCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgaE9QID0gT1AuaGFzT3duUHJvcGVydHksXG4gICAgaVBPID0gT1AuaXNQcm90b3R5cGVPZixcbiAgXG4gICAgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgZW1wdHkgPSBbXSxcbiAgICBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBnT1BOID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgZ1BPID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIHNQTyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZixcbiAgXG4gICAgLy8ganNoaW50IHByb3RvOiB0cnVlXG4gICAgaGFzUHJvdG8gPSAhIU9iamVjdC5fX3Byb3RvX18sXG4gIFxuICAgIC8vIFYxIGhlbHBlcnNcbiAgICBmaXhHZXRDbGFzcyA9IGZhbHNlLFxuICAgIERSRUNFVjEgPSAnX19kcmVDRXYxJyxcbiAgICBjdXN0b21FbGVtZW50cyA9IHdpbmRvdy5jdXN0b21FbGVtZW50cyxcbiAgICB1c2FibGVDdXN0b21FbGVtZW50cyA9ICEhKFxuICAgICAgY3VzdG9tRWxlbWVudHMgJiZcbiAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSAmJlxuICAgICAgY3VzdG9tRWxlbWVudHMuZ2V0ICYmXG4gICAgICBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZFxuICAgICksXG4gICAgRGljdCA9IE9iamVjdC5jcmVhdGUgfHwgT2JqZWN0LFxuICAgIE1hcCA9IHdpbmRvdy5NYXAgfHwgZnVuY3Rpb24gTWFwKCkge1xuICAgICAgdmFyIEsgPSBbXSwgViA9IFtdLCBpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBWW2luZGV4T2YuY2FsbChLLCBrKV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICBpID0gaW5kZXhPZi5jYWxsKEssIGspO1xuICAgICAgICAgIGlmIChpIDwgMCkgVltLLnB1c2goaykgLSAxXSA9IHY7XG4gICAgICAgICAgZWxzZSBWW2ldID0gdjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIFByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhclxuICAgICAgICBub3RpZnkgPSBbXSxcbiAgICAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICBwID0ge1xuICAgICAgICAgICdjYXRjaCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3RoZW4nOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIG5vdGlmeS5wdXNoKGNiKTtcbiAgICAgICAgICAgIGlmIChkb25lKSBzZXRUaW1lb3V0KHJlc29sdmUsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA7XG4gICAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobm90aWZ5Lmxlbmd0aCkgbm90aWZ5LnNoaWZ0KCkodmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4ocmVzb2x2ZSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGp1c3RDcmVhdGVkID0gZmFsc2UsXG4gICAgY29uc3RydWN0b3JzID0gRGljdChudWxsKSxcbiAgICB3YWl0aW5nTGlzdCA9IERpY3QobnVsbCksXG4gICAgbm9kZU5hbWVzID0gbmV3IE1hcCgpLFxuICAgIHNlY29uZEFyZ3VtZW50ID0gU3RyaW5nLFxuICBcbiAgICAvLyB1c2VkIHRvIGNyZWF0ZSB1bmlxdWUgaW5zdGFuY2VzXG4gICAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBCcmlkZ2UocHJvdG8pIHtcbiAgICAgIC8vIHNpbGx5IGJyb2tlbiBwb2x5ZmlsbCBwcm9iYWJseSBldmVyIHVzZWQgYnV0IHNob3J0IGVub3VnaCB0byB3b3JrXG4gICAgICByZXR1cm4gcHJvdG8gPyAoKEJyaWRnZS5wcm90b3R5cGUgPSBwcm90byksIG5ldyBCcmlkZ2UoKSkgOiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIHdpbGwgc2V0IHRoZSBwcm90b3R5cGUgaWYgcG9zc2libGVcbiAgICAvLyBvciBjb3B5IG92ZXIgYWxsIHByb3BlcnRpZXNcbiAgICBzZXRQcm90b3R5cGUgPSBzUE8gfHwgKFxuICAgICAgaGFzUHJvdG8gP1xuICAgICAgICBmdW5jdGlvbiAobywgcCkge1xuICAgICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSA6IChcbiAgICAgIChnT1BOICYmIGdPUEQpID9cbiAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZnVuY3Rpb24gc2V0UHJvcGVydGllcyhvLCBwKSB7XG4gICAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG5hbWVzID0gZ09QTihwKSxcbiAgICAgICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAga2V5ID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgIGlmICghaE9QLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZ09QRChwLCBrZXkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgc2V0UHJvcGVydGllcyhvLCBwKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKChwID0gZ1BPKHApKSAmJiAhaVBPLmNhbGwocCwgbykpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpKSA6XG4gICAgICAgIGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHApIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHBba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICApKSxcbiAgXG4gICAgLy8gRE9NIHNob3J0Y3V0cyBhbmQgaGVscGVycywgaWYgYW55XG4gIFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixcbiAgXG4gICAgSFRNTEVsZW1lbnRQcm90b3R5cGUgPSAoXG4gICAgICB3aW5kb3cuSFRNTEVsZW1lbnQgfHxcbiAgICAgIHdpbmRvdy5FbGVtZW50IHx8XG4gICAgICB3aW5kb3cuTm9kZVxuICAgICkucHJvdG90eXBlLFxuICBcbiAgICBJRTggPSAhaVBPLmNhbGwoSFRNTEVsZW1lbnRQcm90b3R5cGUsIGRvY3VtZW50RWxlbWVudCksXG4gIFxuICAgIHNhZmVQcm9wZXJ0eSA9IElFOCA/IGZ1bmN0aW9uIChvLCBrLCBkKSB7XG4gICAgICBvW2tdID0gZC52YWx1ZTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0gOiBkZWZpbmVQcm9wZXJ0eSxcbiAgXG4gICAgaXNWYWxpZE5vZGUgPSBJRTggP1xuICAgICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG4gICAgICB9IDpcbiAgICAgIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBpUE8uY2FsbChIVE1MRWxlbWVudFByb3RvdHlwZSwgbm9kZSk7XG4gICAgICB9LFxuICBcbiAgICB0YXJnZXRzID0gSUU4ICYmIFtdLFxuICBcbiAgICBhdHRhY2hTaGFkb3cgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5hdHRhY2hTaGFkb3csXG4gICAgY2xvbmVOb2RlID0gSFRNTEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlLFxuICAgIGRpc3BhdGNoRXZlbnQgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5kaXNwYXRjaEV2ZW50LFxuICAgIGdldEF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLmdldEF0dHJpYnV0ZSxcbiAgICBoYXNBdHRyaWJ1dGUgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5oYXNBdHRyaWJ1dGUsXG4gICAgcmVtb3ZlQXR0cmlidXRlID0gSFRNTEVsZW1lbnRQcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLFxuICAgIHNldEF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLnNldEF0dHJpYnV0ZSxcbiAgXG4gICAgLy8gcmVwbGFjZWQgbGF0ZXIgb25cbiAgICBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCxcbiAgICBwYXRjaGVkQ3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQsXG4gIFxuICAgIC8vIHNoYXJlZCBvYnNlcnZlciBmb3IgYWxsIGF0dHJpYnV0ZXNcbiAgICBhdHRyaWJ1dGVzT2JzZXJ2ZXIgPSBNdXRhdGlvbk9ic2VydmVyICYmIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWVcbiAgICB9LFxuICBcbiAgICAvLyB1c2VmdWwgdG8gZGV0ZWN0IG9ubHkgaWYgdGhlcmUncyBubyBNdXRhdGlvbk9ic2VydmVyXG4gICAgRE9NQXR0ck1vZGlmaWVkID0gTXV0YXRpb25PYnNlcnZlciB8fCBmdW5jdGlvbihlKSB7XG4gICAgICBkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIERPTV9BVFRSX01PRElGSUVELFxuICAgICAgICBET01BdHRyTW9kaWZpZWRcbiAgICAgICk7XG4gICAgfSxcbiAgXG4gICAgLy8gd2lsbCBib3RoIGJlIHVzZWQgdG8gbWFrZSBET01Ob2RlSW5zZXJ0ZWQgYXN5bmNocm9ub3VzXG4gICAgYXNhcFF1ZXVlLFxuICAgIGFzYXBUaW1lciA9IDAsXG4gIFxuICAgIC8vIGludGVybmFsIGZsYWdzXG4gICAgc2V0TGlzdGVuZXIgPSBmYWxzZSxcbiAgICBkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCA9IHRydWUsXG4gICAgZHJvcERvbUNvbnRlbnRMb2FkZWQgPSB0cnVlLFxuICBcbiAgICAvLyBuZWVkZWQgZm9yIHRoZSBpbm5lckhUTUwgaGVscGVyXG4gICAgbm90RnJvbUlubmVySFRNTEhlbHBlciA9IHRydWUsXG4gIFxuICAgIC8vIG9wdGlvbmFsbHkgZGVmaW5lZCBsYXRlciBvblxuICAgIG9uU3VidHJlZU1vZGlmaWVkLFxuICAgIGNhbGxET01BdHRyTW9kaWZpZWQsXG4gICAgZ2V0QXR0cmlidXRlc01pcnJvcixcbiAgICBvYnNlcnZlcixcbiAgICBvYnNlcnZlLFxuICBcbiAgICAvLyBiYXNlZCBvbiBzZXR0aW5nIHByb3RvdHlwZSBjYXBhYmlsaXR5XG4gICAgLy8gd2lsbCBjaGVjayBwcm90byBvciB0aGUgZXhwYW5kbyBhdHRyaWJ1dGVcbiAgICAvLyBpbiBvcmRlciB0byBzZXR1cCB0aGUgbm9kZSBvbmNlXG4gICAgcGF0Y2hJZk5vdEFscmVhZHksXG4gICAgcGF0Y2hcbiAgO1xuICBcbiAgLy8gb25seSBpZiBuZWVkZWRcbiAgaWYgKCEoUkVHSVNURVJfRUxFTUVOVCBpbiBkb2N1bWVudCkpIHtcbiAgXG4gICAgaWYgKHNQTyB8fCBoYXNQcm90bykge1xuICAgICAgICBwYXRjaElmTm90QWxyZWFkeSA9IGZ1bmN0aW9uIChub2RlLCBwcm90bykge1xuICAgICAgICAgIGlmICghaVBPLmNhbGwocHJvdG8sIG5vZGUpKSB7XG4gICAgICAgICAgICBzZXR1cE5vZGUobm9kZSwgcHJvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGF0Y2ggPSBzZXR1cE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2hJZk5vdEFscmVhZHkgPSBmdW5jdGlvbiAobm9kZSwgcHJvdG8pIHtcbiAgICAgICAgICBpZiAoIW5vZGVbRVhQQU5ET19VSURdKSB7XG4gICAgICAgICAgICBub2RlW0VYUEFORE9fVUlEXSA9IE9iamVjdCh0cnVlKTtcbiAgICAgICAgICAgIHNldHVwTm9kZShub2RlLCBwcm90byk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwYXRjaCA9IHBhdGNoSWZOb3RBbHJlYWR5O1xuICAgIH1cbiAgXG4gICAgaWYgKElFOCkge1xuICAgICAgZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIChmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyXG4gICAgICAgICAgZGVzY3JpcHRvciA9IGdPUEQoSFRNTEVsZW1lbnRQcm90b3R5cGUsIEFERF9FVkVOVF9MSVNURU5FUiksXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lciA9IGRlc2NyaXB0b3IudmFsdWUsXG4gICAgICAgICAgcGF0Y2hlZFJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBDdXN0b21FdmVudChET01fQVRUUl9NT0RJRklFRCwge2J1YmJsZXM6IHRydWV9KTtcbiAgICAgICAgICAgIGUuYXR0ck5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgZS5wcmV2VmFsdWUgPSBnZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIGUubmV3VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZVtSRU1PVkFMXSA9IGUuYXR0ckNoYW5nZSA9IDI7XG4gICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhdGNoZWRTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICBoYWQgPSBoYXNBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKSxcbiAgICAgICAgICAgICAgb2xkID0gaGFkICYmIGdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpLFxuICAgICAgICAgICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KERPTV9BVFRSX01PRElGSUVELCB7YnViYmxlczogdHJ1ZX0pXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBlLmF0dHJOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGUucHJldlZhbHVlID0gaGFkID8gb2xkIDogbnVsbDtcbiAgICAgICAgICAgIGUubmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChoYWQpIHtcbiAgICAgICAgICAgICAgZVtNT0RJRklDQVRJT05dID0gZS5hdHRyQ2hhbmdlID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVbQURESVRJT05dID0gZS5hdHRyQ2hhbmdlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uUHJvcGVydHlDaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8ganNoaW50IGVxbnVsbDp0cnVlXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgbm9kZSA9IGUuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgICAgc3VwZXJTZWNyZXQgPSBub2RlW0VYUEFORE9fVUlEXSxcbiAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gZS5wcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoc3VwZXJTZWNyZXQuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICBzdXBlclNlY3JldCA9IHN1cGVyU2VjcmV0W3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KERPTV9BVFRSX01PRElGSUVELCB7YnViYmxlczogdHJ1ZX0pO1xuICAgICAgICAgICAgICBldmVudC5hdHRyTmFtZSA9IHN1cGVyU2VjcmV0Lm5hbWU7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZWYWx1ZSA9IHN1cGVyU2VjcmV0LnZhbHVlIHx8IG51bGw7XG4gICAgICAgICAgICAgIGV2ZW50Lm5ld1ZhbHVlID0gKHN1cGVyU2VjcmV0LnZhbHVlID0gbm9kZVtwcm9wZXJ0eU5hbWVdIHx8IG51bGwpO1xuICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldlZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudFtBRERJVElPTl0gPSBldmVudC5hdHRyQ2hhbmdlID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFtNT0RJRklDQVRJT05dID0gZXZlbnQuYXR0ckNoYW5nZSA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudC5jYWxsKG5vZGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gRE9NX0FUVFJfTU9ESUZJRUQgJiZcbiAgICAgICAgICAgIHRoaXNbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdICYmXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSAhPT0gcGF0Y2hlZFNldEF0dHJpYnV0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpc1tFWFBBTkRPX1VJRF0gPSB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2xhc3NOYW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSA9IHBhdGNoZWRTZXRBdHRyaWJ1dGU7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSA9IHBhdGNoZWRSZW1vdmVBdHRyaWJ1dGU7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgJ3Byb3BlcnR5Y2hhbmdlJywgb25Qcm9wZXJ0eUNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnRQcm90b3R5cGUsIEFERF9FVkVOVF9MSVNURU5FUiwgZGVzY3JpcHRvcik7XG4gICAgICB9KCkpO1xuICAgIH0gZWxzZSBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGRvY3VtZW50RWxlbWVudFtBRERfRVZFTlRfTElTVEVORVJdKERPTV9BVFRSX01PRElGSUVELCBET01BdHRyTW9kaWZpZWQpO1xuICAgICAgZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShFWFBBTkRPX1VJRCwgMSk7XG4gICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEVYUEFORE9fVUlEKTtcbiAgICAgIGlmIChkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCkge1xuICAgICAgICBvblN1YnRyZWVNb2RpZmllZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyXG4gICAgICAgICAgICBub2RlID0gdGhpcyxcbiAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgO1xuICAgICAgICAgIGlmIChub2RlID09PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgb2xkQXR0cmlidXRlcyA9IG5vZGVbRVhQQU5ET19VSURdO1xuICAgICAgICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSAobmV3QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNNaXJyb3Iobm9kZSkpO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gbmV3QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2xkQXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgd2FzIGFkZGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxET01BdHRyTW9kaWZpZWQoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgIEFERElUSU9OXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdBdHRyaWJ1dGVzW2tleV0gIT09IG9sZEF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSB3YXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRE9NQXR0ck1vZGlmaWVkKFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICBNT0RJRklDQVRJT05cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVja2luZyBpZiBpdCBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvbGRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxET01BdHRyTW9kaWZpZWQoXG4gICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgIFJFTU9WQUxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYWxsRE9NQXR0ck1vZGlmaWVkID0gZnVuY3Rpb24gKFxuICAgICAgICAgIGF0dHJDaGFuZ2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldCxcbiAgICAgICAgICBhdHRyTmFtZSxcbiAgICAgICAgICBwcmV2VmFsdWUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgYXR0ckNoYW5nZTogYXR0ckNoYW5nZSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0ck5hbWUsXG4gICAgICAgICAgICBwcmV2VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZVthY3Rpb25dID0gYXR0ckNoYW5nZTtcbiAgICAgICAgICBvbkRPTUF0dHJNb2RpZmllZChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0QXR0cmlidXRlc01pcnJvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICAgIGF0dHIsIG5hbWUsXG4gICAgICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBpID0gMCwgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgbmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSAnc2V0QXR0cmlidXRlJykge1xuICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gc2V0IGFzIGVudW1lcmFibGUsIHdyaXRhYmxlIGFuZCBjb25maWd1cmFibGVcbiAgICBkb2N1bWVudFtSRUdJU1RFUl9FTEVNRU5UXSA9IGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudCh0eXBlLCBvcHRpb25zKSB7XG4gICAgICB1cHBlclR5cGUgPSB0eXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoIXNldExpc3RlbmVyKSB7XG4gICAgICAgIC8vIG9ubHkgZmlyc3QgdGltZSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgaXMgdXNlZFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGlzIGxpc3RlbmVyXG4gICAgICAgIC8vIHNldHRpbmcgaXQgYnkgZGVmYXVsdCBtaWdodCBzbG93IGRvd24gZm9yIG5vIHJlYXNvblxuICAgICAgICBzZXRMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgIGlmIChNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSAoZnVuY3Rpb24oYXR0YWNoZWQsIGRldGFjaGVkKXtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRW1BbGwobGlzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBjYWxsYmFjayhsaXN0W2krK10pKXt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICAgICAgICBjdXJyZW50LCBub2RlLCBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMCwgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tFbUFsbChjdXJyZW50LmFkZGVkTm9kZXMsIGF0dGFjaGVkKTtcbiAgICAgICAgICAgICAgICAgIGNoZWNrRW1BbGwoY3VycmVudC5yZW1vdmVkTm9kZXMsIGRldGFjaGVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICBub2RlW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYXR0cmlidXRlTmFtZSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsIGN1cnJlbnQuYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gY3VycmVudC5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vZGVbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfShleGVjdXRlQWN0aW9uKEFUVEFDSEVEKSwgZXhlY3V0ZUFjdGlvbihERVRBQ0hFRCkpKTtcbiAgICAgICAgICBvYnNlcnZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvYnNlcnZlKGRvY3VtZW50KTtcbiAgICAgICAgICBpZiAoYXR0YWNoU2hhZG93KSB7XG4gICAgICAgICAgICBIVE1MRWxlbWVudFByb3RvdHlwZS5hdHRhY2hTaGFkb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlKGF0dGFjaFNoYWRvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzYXBRdWV1ZSA9IFtdO1xuICAgICAgICAgIGRvY3VtZW50W0FERF9FVkVOVF9MSVNURU5FUl0oJ0RPTU5vZGVJbnNlcnRlZCcsIG9uRE9NTm9kZShBVFRBQ0hFRCkpO1xuICAgICAgICAgIGRvY3VtZW50W0FERF9FVkVOVF9MSVNURU5FUl0oJ0RPTU5vZGVSZW1vdmVkJywgb25ET01Ob2RlKERFVEFDSEVEKSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGRvY3VtZW50W0FERF9FVkVOVF9MSVNURU5FUl0oRE9NX0NPTlRFTlRfTE9BREVELCBvblJlYWR5U3RhdGVDaGFuZ2UpO1xuICAgICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKCdyZWFkeXN0YXRlY2hhbmdlJywgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgXG4gICAgICAgIEhUTUxFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChkZWVwKSB7XG4gICAgICAgICAgdmFyXG4gICAgICAgICAgICBub2RlID0gY2xvbmVOb2RlLmNhbGwodGhpcywgISFkZWVwKSxcbiAgICAgICAgICAgIGkgPSBnZXRUeXBlSW5kZXgobm9kZSlcbiAgICAgICAgICA7XG4gICAgICAgICAgaWYgKC0xIDwgaSkgcGF0Y2gobm9kZSwgcHJvdG9zW2ldKTtcbiAgICAgICAgICBpZiAoZGVlcCkgbG9vcEFuZFNldHVwKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgfVxuICBcbiAgICAgIGlmICgtMiA8IChcbiAgICAgICAgaW5kZXhPZi5jYWxsKHR5cGVzLCBQUkVGSVhfSVMgKyB1cHBlclR5cGUpICtcbiAgICAgICAgaW5kZXhPZi5jYWxsKHR5cGVzLCBQUkVGSVhfVEFHICsgdXBwZXJUeXBlKVxuICAgICAgKSkge1xuICAgICAgICB0aHJvd1R5cGVFcnJvcih0eXBlKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIXZhbGlkTmFtZS50ZXN0KHVwcGVyVHlwZSkgfHwgLTEgPCBpbmRleE9mLmNhbGwoaW52YWxpZE5hbWVzLCB1cHBlclR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR5cGUgJyArIHR5cGUgKyAnIGlzIGludmFsaWQnKTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXJcbiAgICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4dGVuZGluZyA/XG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lLCB1cHBlclR5cGUpIDpcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBvcHQgPSBvcHRpb25zIHx8IE9QLFxuICAgICAgICBleHRlbmRpbmcgPSBoT1AuY2FsbChvcHQsIEVYVEVORFMpLFxuICAgICAgICBub2RlTmFtZSA9IGV4dGVuZGluZyA/IG9wdGlvbnNbRVhURU5EU10udG9VcHBlckNhc2UoKSA6IHVwcGVyVHlwZSxcbiAgICAgICAgdXBwZXJUeXBlLFxuICAgICAgICBpXG4gICAgICA7XG4gIFxuICAgICAgaWYgKGV4dGVuZGluZyAmJiAtMSA8IChcbiAgICAgICAgaW5kZXhPZi5jYWxsKHR5cGVzLCBQUkVGSVhfVEFHICsgbm9kZU5hbWUpXG4gICAgICApKSB7XG4gICAgICAgIHRocm93VHlwZUVycm9yKG5vZGVOYW1lKTtcbiAgICAgIH1cbiAgXG4gICAgICBpID0gdHlwZXMucHVzaCgoZXh0ZW5kaW5nID8gUFJFRklYX0lTIDogUFJFRklYX1RBRykgKyB1cHBlclR5cGUpIC0gMTtcbiAgXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmNvbmNhdChcbiAgICAgICAgcXVlcnkubGVuZ3RoID8gJywnIDogJycsXG4gICAgICAgIGV4dGVuZGluZyA/IG5vZGVOYW1lICsgJ1tpcz1cIicgKyB0eXBlLnRvTG93ZXJDYXNlKCkgKyAnXCJdJyA6IG5vZGVOYW1lXG4gICAgICApO1xuICBcbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IChcbiAgICAgICAgcHJvdG9zW2ldID0gaE9QLmNhbGwob3B0LCAncHJvdG90eXBlJykgP1xuICAgICAgICAgIG9wdC5wcm90b3R5cGUgOlxuICAgICAgICAgIGNyZWF0ZShIVE1MRWxlbWVudFByb3RvdHlwZSlcbiAgICAgICk7XG4gIFxuICAgICAgbG9vcEFuZFZlcmlmeShcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgIEFUVEFDSEVEXG4gICAgICApO1xuICBcbiAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9O1xuICBcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gKHBhdGNoZWRDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGxvY2FsTmFtZSwgdHlwZUV4dGVuc2lvbikge1xuICAgICAgdmFyXG4gICAgICAgIGlzID0gZ2V0SXModHlwZUV4dGVuc2lvbiksXG4gICAgICAgIG5vZGUgPSBpcyA/XG4gICAgICAgICAgY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCBsb2NhbE5hbWUsIHNlY29uZEFyZ3VtZW50KGlzKSkgOlxuICAgICAgICAgIGNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgbG9jYWxOYW1lKSxcbiAgICAgICAgbmFtZSA9ICcnICsgbG9jYWxOYW1lLFxuICAgICAgICBpID0gaW5kZXhPZi5jYWxsKFxuICAgICAgICAgIHR5cGVzLFxuICAgICAgICAgIChpcyA/IFBSRUZJWF9JUyA6IFBSRUZJWF9UQUcpICtcbiAgICAgICAgICAoaXMgfHwgbmFtZSkudG9VcHBlckNhc2UoKVxuICAgICAgICApLFxuICAgICAgICBzZXR1cCA9IC0xIDwgaVxuICAgICAgO1xuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpcycsIGlzID0gaXMudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmIChzZXR1cCkge1xuICAgICAgICAgIHNldHVwID0gaXNJblFTQShuYW1lLnRvVXBwZXJDYXNlKCksIGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90RnJvbUlubmVySFRNTEhlbHBlciA9ICFkb2N1bWVudC5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlcjtcbiAgICAgIGlmIChzZXR1cCkgcGF0Y2gobm9kZSwgcHJvdG9zW2ldKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICBcbiAgfVxuICBcbiAgZnVuY3Rpb24gQVNBUCgpIHtcbiAgICB2YXIgcXVldWUgPSBhc2FwUXVldWUuc3BsaWNlKDAsIGFzYXBRdWV1ZS5sZW5ndGgpO1xuICAgIGFzYXBUaW1lciA9IDA7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgcXVldWUuc2hpZnQoKS5jYWxsKFxuICAgICAgICBudWxsLCBxdWV1ZS5zaGlmdCgpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gbG9vcEFuZFZlcmlmeShsaXN0LCBhY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obGlzdFtpXSwgYWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGxvb3BBbmRTZXR1cChsaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoLCBub2RlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBsaXN0W2ldO1xuICAgICAgcGF0Y2gobm9kZSwgcHJvdG9zW2dldFR5cGVJbmRleChub2RlKV0pO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gZXhlY3V0ZUFjdGlvbihhY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChpc1ZhbGlkTm9kZShub2RlKSkge1xuICAgICAgICB2ZXJpZnlBbmRTZXR1cEFuZEFjdGlvbihub2RlLCBhY3Rpb24pO1xuICAgICAgICBsb29wQW5kVmVyaWZ5KFxuICAgICAgICAgIG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHRhcmdldCkge1xuICAgIHZhclxuICAgICAgaXMgPSBnZXRBdHRyaWJ1dGUuY2FsbCh0YXJnZXQsICdpcycpLFxuICAgICAgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgIGkgPSBpbmRleE9mLmNhbGwoXG4gICAgICAgIHR5cGVzLFxuICAgICAgICBpcyA/XG4gICAgICAgICAgICBQUkVGSVhfSVMgKyBpcy50b1VwcGVyQ2FzZSgpIDpcbiAgICAgICAgICAgIFBSRUZJWF9UQUcgKyBub2RlTmFtZVxuICAgICAgKVxuICAgIDtcbiAgICByZXR1cm4gaXMgJiYgLTEgPCBpICYmICFpc0luUVNBKG5vZGVOYW1lLCBpcykgPyAtMSA6IGk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGlzSW5RU0EobmFtZSwgdHlwZSkge1xuICAgIHJldHVybiAtMSA8IHF1ZXJ5LmluZGV4T2YobmFtZSArICdbaXM9XCInICsgdHlwZSArICdcIl0nKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gb25ET01BdHRyTW9kaWZpZWQoZSkge1xuICAgIHZhclxuICAgICAgbm9kZSA9IGUuY3VycmVudFRhcmdldCxcbiAgICAgIGF0dHJDaGFuZ2UgPSBlLmF0dHJDaGFuZ2UsXG4gICAgICBhdHRyTmFtZSA9IGUuYXR0ck5hbWUsXG4gICAgICB0YXJnZXQgPSBlLnRhcmdldCxcbiAgICAgIGFkZGl0aW9uID0gZVtBRERJVElPTl0gfHwgMixcbiAgICAgIHJlbW92YWwgPSBlW1JFTU9WQUxdIHx8IDNcbiAgICA7XG4gICAgaWYgKG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBub2RlKSAmJlxuICAgICAgICBub2RlW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXSAmJlxuICAgICAgICBhdHRyTmFtZSAhPT0gJ3N0eWxlJyAmJiAoXG4gICAgICAgICAgZS5wcmV2VmFsdWUgIT09IGUubmV3VmFsdWUgfHxcbiAgICAgICAgICAvLyBJRTksIElFMTAsIGFuZCBPcGVyYSAxMiBnb3RjaGFcbiAgICAgICAgICBlLm5ld1ZhbHVlID09PSAnJyAmJiAoXG4gICAgICAgICAgICBhdHRyQ2hhbmdlID09PSBhZGRpdGlvbiB8fFxuICAgICAgICAgICAgYXR0ckNoYW5nZSA9PT0gcmVtb3ZhbFxuICAgICAgICAgIClcbiAgICApKSB7XG4gICAgICBub2RlW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXShcbiAgICAgICAgYXR0ck5hbWUsXG4gICAgICAgIGF0dHJDaGFuZ2UgPT09IGFkZGl0aW9uID8gbnVsbCA6IGUucHJldlZhbHVlLFxuICAgICAgICBhdHRyQ2hhbmdlID09PSByZW1vdmFsID8gbnVsbCA6IGUubmV3VmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBvbkRPTU5vZGUoYWN0aW9uKSB7XG4gICAgdmFyIGV4ZWN1dG9yID0gZXhlY3V0ZUFjdGlvbihhY3Rpb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgYXNhcFF1ZXVlLnB1c2goZXhlY3V0b3IsIGUudGFyZ2V0KTtcbiAgICAgIGlmIChhc2FwVGltZXIpIGNsZWFyVGltZW91dChhc2FwVGltZXIpO1xuICAgICAgYXNhcFRpbWVyID0gc2V0VGltZW91dChBU0FQLCAxKTtcbiAgICB9O1xuICB9XG4gIFxuICBmdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoZSkge1xuICAgIGlmIChkcm9wRG9tQ29udGVudExvYWRlZCkge1xuICAgICAgZHJvcERvbUNvbnRlbnRMb2FkZWQgPSBmYWxzZTtcbiAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKERPTV9DT05URU5UX0xPQURFRCwgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgICB9XG4gICAgbG9vcEFuZFZlcmlmeShcbiAgICAgIChlLnRhcmdldCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICBlLmRldGFpbCA9PT0gREVUQUNIRUQgPyBERVRBQ0hFRCA6IEFUVEFDSEVEXG4gICAgKTtcbiAgICBpZiAoSUU4KSBwdXJnZSgpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBwYXRjaGVkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8ganNoaW50IHZhbGlkdGhpczp0cnVlXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldEF0dHJpYnV0ZS5jYWxsKHNlbGYsIG5hbWUsIHZhbHVlKTtcbiAgICBvblN1YnRyZWVNb2RpZmllZC5jYWxsKHNlbGYsIHt0YXJnZXQ6IHNlbGZ9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gc2V0dXBOb2RlKG5vZGUsIHByb3RvKSB7XG4gICAgc2V0UHJvdG90eXBlKG5vZGUsIHByb3RvKTtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgYXR0cmlidXRlc09ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvZXNOb3RTdXBwb3J0RE9NQXR0ck1vZGlmaWVkKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlID0gcGF0Y2hlZFNldEF0dHJpYnV0ZTtcbiAgICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSBnZXRBdHRyaWJ1dGVzTWlycm9yKG5vZGUpO1xuICAgICAgICBub2RlW0FERF9FVkVOVF9MSVNURU5FUl0oRE9NX1NVQlRSRUVfTU9ESUZJRUQsIG9uU3VidHJlZU1vZGlmaWVkKTtcbiAgICAgIH1cbiAgICAgIG5vZGVbQUREX0VWRU5UX0xJU1RFTkVSXShET01fQVRUUl9NT0RJRklFRCwgb25ET01BdHRyTW9kaWZpZWQpO1xuICAgIH1cbiAgICBpZiAobm9kZVtDUkVBVEVEX0NBTExCQUNLXSAmJiBub3RGcm9tSW5uZXJIVE1MSGVscGVyKSB7XG4gICAgICBub2RlLmNyZWF0ZWQgPSB0cnVlO1xuICAgICAgbm9kZVtDUkVBVEVEX0NBTExCQUNLXSgpO1xuICAgICAgbm9kZS5jcmVhdGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBwdXJnZSgpIHtcbiAgICBmb3IgKHZhclxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuZ3RoID0gdGFyZ2V0cy5sZW5ndGg7XG4gICAgICBpIDwgbGVuZ3RoOyBpKytcbiAgICApIHtcbiAgICAgIG5vZGUgPSB0YXJnZXRzW2ldO1xuICAgICAgaWYgKCFkb2N1bWVudEVsZW1lbnQuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHZlcmlmeUFuZFNldHVwQW5kQWN0aW9uKG5vZGUsIERFVEFDSEVEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHRocm93VHlwZUVycm9yKHR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgJyArIHR5cGUgKyAnIHR5cGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkJyk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHZlcmlmeUFuZFNldHVwQW5kQWN0aW9uKG5vZGUsIGFjdGlvbikge1xuICAgIHZhclxuICAgICAgZm4sXG4gICAgICBpID0gZ2V0VHlwZUluZGV4KG5vZGUpXG4gICAgO1xuICAgIGlmICgtMSA8IGkpIHtcbiAgICAgIHBhdGNoSWZOb3RBbHJlYWR5KG5vZGUsIHByb3Rvc1tpXSk7XG4gICAgICBpID0gMDtcbiAgICAgIGlmIChhY3Rpb24gPT09IEFUVEFDSEVEICYmICFub2RlW0FUVEFDSEVEXSkge1xuICAgICAgICBub2RlW0RFVEFDSEVEXSA9IGZhbHNlO1xuICAgICAgICBub2RlW0FUVEFDSEVEXSA9IHRydWU7XG4gICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoSUU4ICYmIGluZGV4T2YuY2FsbCh0YXJnZXRzLCBub2RlKSA8IDApIHtcbiAgICAgICAgICB0YXJnZXRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBERVRBQ0hFRCAmJiAhbm9kZVtERVRBQ0hFRF0pIHtcbiAgICAgICAgbm9kZVtBVFRBQ0hFRF0gPSBmYWxzZTtcbiAgICAgICAgbm9kZVtERVRBQ0hFRF0gPSB0cnVlO1xuICAgICAgICBpID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpICYmIChmbiA9IG5vZGVbYWN0aW9uICsgQ0FMTEJBQ0tdKSkgZm4uY2FsbChub2RlKTtcbiAgICB9XG4gIH1cbiAgXG4gIFxuICBcbiAgLy8gVjEgaW4gZGEgSG91c2UhXG4gIGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSgpIHt9XG4gIFxuICBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDdXN0b21FbGVtZW50UmVnaXN0cnksXG4gICAgLy8gYSB3b3JrYXJvdW5kIGZvciB0aGUgc3R1YmJvcm4gV2ViS2l0XG4gICAgZGVmaW5lOiB1c2FibGVDdXN0b21FbGVtZW50cyA/XG4gICAgICBmdW5jdGlvbiAobmFtZSwgQ2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBDRVJEZWZpbmUobmFtZSwgQ2xhc3MsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBOQU1FID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0cnVjdG9yc1tOQU1FXSA9IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBDbGFzcyxcbiAgICAgICAgICAgIGNyZWF0ZTogW05BTUVdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlTmFtZXMuc2V0KENsYXNzLCBOQU1FKTtcbiAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUobmFtZSwgQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9IDpcbiAgICAgIENFUkRlZmluZSxcbiAgICBnZXQ6IHVzYWJsZUN1c3RvbUVsZW1lbnRzID9cbiAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBjdXN0b21FbGVtZW50cy5nZXQobmFtZSkgfHwgZ2V0KG5hbWUpO1xuICAgICAgfSA6XG4gICAgICBnZXQsXG4gICAgd2hlbkRlZmluZWQ6IHVzYWJsZUN1c3RvbUVsZW1lbnRzID9cbiAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKG5hbWUpLFxuICAgICAgICAgIHdoZW5EZWZpbmVkKG5hbWUpXG4gICAgICAgIF0pO1xuICAgICAgfSA6XG4gICAgICB3aGVuRGVmaW5lZFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQ0VSRGVmaW5lKG5hbWUsIENsYXNzLCBvcHRpb25zKSB7XG4gICAgdmFyXG4gICAgICBpcyA9IG9wdGlvbnMgJiYgb3B0aW9uc1tFWFRFTkRTXSB8fCAnJyxcbiAgICAgIENQcm90byA9IENsYXNzLnByb3RvdHlwZSxcbiAgICAgIHByb3RvID0gY3JlYXRlKENQcm90byksXG4gICAgICBhdHRyaWJ1dGVzID0gQ2xhc3Mub2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IGVtcHR5LFxuICAgICAgZGVmaW5pdGlvbiA9IHtwcm90b3R5cGU6IHByb3RvfVxuICAgIDtcbiAgICAvLyBUT0RPOiBpcyB0aGlzIG5lZWRlZCBhdCBhbGwgc2luY2UgaXQncyBpbmhlcml0ZWQ/XG4gICAgLy8gZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25zdHJ1Y3RvcicsIHt2YWx1ZTogQ2xhc3N9KTtcbiAgICBzYWZlUHJvcGVydHkocHJvdG8sIENSRUFURURfQ0FMTEJBQ0ssIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoanVzdENyZWF0ZWQpIGp1c3RDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZiAoIXRoaXNbRFJFQ0VWMV0pIHtcbiAgICAgICAgICAgIHRoaXNbRFJFQ0VWMV0gPSB0cnVlO1xuICAgICAgICAgICAgbmV3IENsYXNzKHRoaXMpO1xuICAgICAgICAgICAgaWYgKENQcm90b1tDUkVBVEVEX0NBTExCQUNLXSlcbiAgICAgICAgICAgICAgQ1Byb3RvW0NSRUFURURfQ0FMTEJBQ0tdLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNvbnN0cnVjdG9yc1tub2RlTmFtZXMuZ2V0KENsYXNzKV07XG4gICAgICAgICAgICBpZiAoIXVzYWJsZUN1c3RvbUVsZW1lbnRzIHx8IGluZm8uY3JlYXRlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgbm90aWZ5QXR0cmlidXRlcyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2FmZVByb3BlcnR5KHByb3RvLCBBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDSywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICgtMSA8IGluZGV4T2YuY2FsbChhdHRyaWJ1dGVzLCBuYW1lKSlcbiAgICAgICAgICBDUHJvdG9bQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKENQcm90b1tDT05ORUNURURfQ0FMTEJBQ0tdKSB7XG4gICAgICBzYWZlUHJvcGVydHkocHJvdG8sIEFUVEFDSEVEX0NBTExCQUNLLCB7XG4gICAgICAgIHZhbHVlOiBDUHJvdG9bQ09OTkVDVEVEX0NBTExCQUNLXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChDUHJvdG9bRElTQ09OTkVDVEVEX0NBTExCQUNLXSkge1xuICAgICAgc2FmZVByb3BlcnR5KHByb3RvLCBERVRBQ0hFRF9DQUxMQkFDSywge1xuICAgICAgICB2YWx1ZTogQ1Byb3RvW0RJU0NPTk5FQ1RFRF9DQUxMQkFDS11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXMpIGRlZmluaXRpb25bRVhURU5EU10gPSBpcztcbiAgICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0cnVjdG9yc1tuYW1lXSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDbGFzcyxcbiAgICAgIGNyZWF0ZTogaXMgPyBbaXMsIHNlY29uZEFyZ3VtZW50KG5hbWUpXSA6IFtuYW1lXVxuICAgIH07XG4gICAgbm9kZU5hbWVzLnNldChDbGFzcywgbmFtZSk7XG4gICAgZG9jdW1lbnRbUkVHSVNURVJfRUxFTUVOVF0obmFtZS50b0xvd2VyQ2FzZSgpLCBkZWZpbml0aW9uKTtcbiAgICB3aGVuRGVmaW5lZChuYW1lKTtcbiAgICB3YWl0aW5nTGlzdFtuYW1lXS5yKCk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFyIGluZm8gPSBjb25zdHJ1Y3RvcnNbbmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICByZXR1cm4gaW5mbyAmJiBpbmZvLmNvbnN0cnVjdG9yO1xuICB9XG4gIFxuICBmdW5jdGlvbiBnZXRJcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyA/XG4gICAgICAgIG9wdGlvbnMgOiAob3B0aW9ucyAmJiBvcHRpb25zLmlzIHx8ICcnKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gbm90aWZ5QXR0cmlidXRlcyhzZWxmKSB7XG4gICAgdmFyXG4gICAgICBjYWxsYmFjayA9IHNlbGZbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdLFxuICAgICAgYXR0cmlidXRlcyA9IGNhbGxiYWNrID8gc2VsZi5hdHRyaWJ1dGVzIDogZW1wdHksXG4gICAgICBpID0gYXR0cmlidXRlcy5sZW5ndGgsXG4gICAgICBhdHRyaWJ1dGVcbiAgICA7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXR0cmlidXRlID0gIGF0dHJpYnV0ZXNbaV07IC8vIHx8IGF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGF0dHJpYnV0ZS5uYW1lIHx8IGF0dHJpYnV0ZS5ub2RlTmFtZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlIHx8IGF0dHJpYnV0ZS5ub2RlVmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiB3aGVuRGVmaW5lZChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoIShuYW1lIGluIHdhaXRpbmdMaXN0KSkge1xuICAgICAgd2FpdGluZ0xpc3RbbmFtZV0gPSB7fTtcbiAgICAgIHdhaXRpbmdMaXN0W25hbWVdLnAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB3YWl0aW5nTGlzdFtuYW1lXS5yID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd2FpdGluZ0xpc3RbbmFtZV0ucDtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcG9seWZpbGxWMSgpIHtcbiAgICBpZiAoY3VzdG9tRWxlbWVudHMpIGRlbGV0ZSB3aW5kb3cuY3VzdG9tRWxlbWVudHM7XG4gICAgZGVmaW5lUHJvcGVydHkod2luZG93LCAnY3VzdG9tRWxlbWVudHMnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbmV3IEN1c3RvbUVsZW1lbnRSZWdpc3RyeSgpXG4gICAgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkod2luZG93LCAnQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5Jywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEN1c3RvbUVsZW1lbnRSZWdpc3RyeVxuICAgIH0pO1xuICAgIGZvciAodmFyXG4gICAgICBwYXRjaENsYXNzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIENsYXNzID0gd2luZG93W25hbWVdO1xuICAgICAgICBpZiAoQ2xhc3MpIHtcbiAgICAgICAgICB3aW5kb3dbbmFtZV0gPSBmdW5jdGlvbiBDdXN0b21FbGVtZW50c1YxKHNlbGYpIHtcbiAgICAgICAgICAgIHZhciBpbmZvLCBpc05hdGl2ZTtcbiAgICAgICAgICAgIGlmICghc2VsZikgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXNlbGZbRFJFQ0VWMV0pIHtcbiAgICAgICAgICAgICAganVzdENyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBpbmZvID0gY29uc3RydWN0b3JzW25vZGVOYW1lcy5nZXQoc2VsZi5jb25zdHJ1Y3RvcildO1xuICAgICAgICAgICAgICBpc05hdGl2ZSA9IHVzYWJsZUN1c3RvbUVsZW1lbnRzICYmIGluZm8uY3JlYXRlLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgICAgc2VsZiA9IGlzTmF0aXZlID9cbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChDbGFzcywgZW1wdHksIGluZm8uY29uc3RydWN0b3IpIDpcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KGRvY3VtZW50LCBpbmZvLmNyZWF0ZSk7XG4gICAgICAgICAgICAgIHNlbGZbRFJFQ0VWMV0gPSB0cnVlO1xuICAgICAgICAgICAgICBqdXN0Q3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoIWlzTmF0aXZlKSBub3RpZnlBdHRyaWJ1dGVzKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3aW5kb3dbbmFtZV0ucHJvdG90eXBlID0gQ2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB3aW5kb3dbbmFtZV07XG4gICAgICAgICAgfSBjYXRjaChXZWJLaXQpIHtcbiAgICAgICAgICAgIGZpeEdldENsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KENsYXNzLCBEUkVDRVYxLCB7dmFsdWU6IHdpbmRvd1tuYW1lXX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENsYXNzZXMgPSBodG1sQ2xhc3MuZ2V0KC9eSFRNTFtBLVpdKlthLXpdLyksXG4gICAgICBpID0gQ2xhc3Nlcy5sZW5ndGg7XG4gICAgICBpLS07XG4gICAgICBwYXRjaENsYXNzKENsYXNzZXNbaV0pXG4gICAgKSB7fVxuICAgIChkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpcyA9IGdldElzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGlzID9cbiAgICAgICAgcGF0Y2hlZENyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lLCBzZWNvbmRBcmd1bWVudChpcykpIDpcbiAgICAgICAgcGF0Y2hlZENyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gaWYgY3VzdG9tRWxlbWVudHMgaXMgbm90IHRoZXJlIGF0IGFsbFxuICBpZiAoIWN1c3RvbUVsZW1lbnRzKSBwb2x5ZmlsbFYxKCk7XG4gIGVsc2Uge1xuICAgIC8vIGlmIGF2YWlsYWJsZSB0ZXN0IGV4dGVuZHMgd29yayBhcyBleHBlY3RlZFxuICAgIHRyeSB7XG4gICAgICAoZnVuY3Rpb24gKERSRSwgb3B0aW9ucywgbmFtZSkge1xuICAgICAgICBvcHRpb25zW0VYVEVORFNdID0gJ2EnO1xuICAgICAgICBEUkUucHJvdG90eXBlID0gY3JlYXRlKEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgIERSRS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEUkU7XG4gICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUobmFtZSwgRFJFLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGdldEF0dHJpYnV0ZS5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnLCB7aXM6IG5hbWV9KSwgJ2lzJykgIT09IG5hbWUgfHxcbiAgICAgICAgICAodXNhYmxlQ3VzdG9tRWxlbWVudHMgJiYgZ2V0QXR0cmlidXRlLmNhbGwobmV3IERSRSgpLCAnaXMnKSAhPT0gbmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfShcbiAgICAgICAgZnVuY3Rpb24gRFJFKCkge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChIVE1MQW5jaG9yRWxlbWVudCwgW10sIERSRSk7XG4gICAgICAgIH0sXG4gICAgICAgIHt9LFxuICAgICAgICAnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC1hJ1xuICAgICAgKSk7XG4gICAgfSBjYXRjaChvX08pIHtcbiAgICAgIC8vIG9yIGZvcmNlIHRoZSBwb2x5ZmlsbCBpZiBub3RcbiAgICAgIC8vIGFuZCBrZWVwIGludGVybmFsIG9yaWdpbmFsIHJlZmVyZW5jZVxuICAgICAgcG9seWZpbGxWMSgpO1xuICAgIH1cbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBjcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsICdhJywgJ2EnKTtcbiAgfSBjYXRjaChGaXJlRm94KSB7XG4gICAgc2Vjb25kQXJndW1lbnQgPSBmdW5jdGlvbiAoaXMpIHtcbiAgICAgIHJldHVybiB7aXM6IGlzfTtcbiAgICB9O1xuICB9XG4gIFxufSh3aW5kb3cpKTtcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXplIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHQvLyBJZ25vcmUgdG91Y2hlcyBvbiBjb250ZW50ZWRpdGFibGUgZWxlbWVudHMgdG8gcHJldmVudCBjb25mbGljdCB3aXRoIHRleHQgc2VsZWN0aW9uLlxuXHRcdC8vIChGb3IgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svcHVsbC8yMTEgKVxuXHRcdGlmICh0YXJnZXRFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuXHRcdGlmIChldmVudC50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZXZlbnQuZGV0YWlsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRwZXJtaXR0ZWQgPSB0aGlzLm9uTW91c2UoZXZlbnQpO1xuXG5cdFx0Ly8gT25seSB1bnNldCB0YXJnZXRFbGVtZW50IGlmIHRoZSBjbGljayBpcyBub3QgcGVybWl0dGVkLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGNoZWNrIGZvciAhdGFyZ2V0RWxlbWVudCBpbiBvbk1vdXNlIGZhaWxzIGFuZCB0aGUgYnJvd3NlcidzIGNsaWNrIGRvZXNuJ3QgZ28gdGhyb3VnaC5cblx0XHRpZiAoIXBlcm1pdHRlZCkge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gcGVybWl0dGVkO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMubGF5ZXI7XG5cblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgRmFzdENsaWNrIGlzIG5lZWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqL1xuXHRGYXN0Q2xpY2subm90TmVlZGVkID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xuXHRcdHZhciBjaHJvbWVWZXJzaW9uO1xuXHRcdHZhciBibGFja2JlcnJ5VmVyc2lvbjtcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XG5cblx0XHQvLyBEZXZpY2VzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b3VjaCBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIENocm9tZSB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRjaHJvbWVWZXJzaW9uID0gKygvQ2hyb21lXFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoY2hyb21lVmVyc2lvbikge1xuXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIG9uIEFuZHJvaWQgd2l0aCB1c2VyLXNjYWxhYmxlPVwibm9cIiBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjODkpXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDaHJvbWUgMzIgYW5kIGFib3ZlIHdpdGggd2lkdGg9ZGV2aWNlLXdpZHRoIG9yIGxlc3MgZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIENocm9tZSBkZXNrdG9wIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICMxNSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0JsYWNrQmVycnkxMCkge1xuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xuXG5cdFx0XHQvLyBCbGFja0JlcnJ5IDEwLjMrIGRvZXMgbm90IHJlcXVpcmUgRmFzdGNsaWNrIGxpYnJhcnkuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXG5cdFx0XHRpZiAoYmxhY2tiZXJyeVZlcnNpb25bMV0gPj0gMTAgJiYgYmxhY2tiZXJyeVZlcnNpb25bMl0gPj0gMykge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIHVzZXItc2NhbGFibGU9bm8gZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTEwIHdpdGggLW1zLXRvdWNoLWFjdGlvbjogbm9uZSBvciBtYW5pcHVsYXRpb24sIHdoaWNoIGRpc2FibGVzIGRvdWJsZS10YXAtdG8tem9vbSAoaXNzdWUgIzk3KVxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBGaXJlZm94IHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGZpcmVmb3hWZXJzaW9uID0gKygvRmlyZWZveFxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGZpcmVmb3hWZXJzaW9uID49IDI3KSB7XG5cdFx0XHQvLyBGaXJlZm94IDI3KyBkb2VzIG5vdCBoYXZlIHRhcCBkZWxheSBpZiB0aGUgY29udGVudCBpcyBub3Qgem9vbWFibGUgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjI4OTZcblxuXHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXHRcdFx0aWYgKG1ldGFWaWV3cG9ydCAmJiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTE6IHByZWZpeGVkIC1tcy10b3VjaC1hY3Rpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgaXQncyByZWNvbW1lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG59KCkpO1xuIiwiLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQvaXNzdWVzLzIxI2lzc3VlY29tbWVudC0xMDIwMjAzMTFcbnZhciBpbm5lckhUTUwgPSAoZnVuY3Rpb24gKGRvY3VtZW50KSB7XG5cbiAgdmFyXG4gICAgRVhURU5EUyA9ICdleHRlbmRzJyxcbiAgICByZWdpc3RlciA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCxcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBkcmUgPSAnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudCcsXG4gICAgaW5uZXJIVE1MID0gcmVnaXN0ZXIuaW5uZXJIVE1MLFxuICAgIGluaXRpYWxpemUsXG4gICAgcmVnaXN0ZXJlZFxuICA7XG5cbiAgLy8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGVyc1xuICBpZiAoaW5uZXJIVE1MKSByZXR1cm4gaW5uZXJIVE1MO1xuXG4gIHRyeSB7XG5cbiAgICAvLyBmZWF0dXJlIGRldGVjdCB0aGUgcHJvYmxlbVxuICAgIHJlZ2lzdGVyLmNhbGwoXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGRyZSxcbiAgICAgIHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAge2NyZWF0ZWRDYWxsYmFjazoge3ZhbHVlOiBPYmplY3R9fVxuICAgICAgKX1cbiAgICApO1xuXG4gICAgZGl2LmlubmVySFRNTCA9ICc8JyArIGRyZSArICc+PC8nICsgZHJlICsgJz4nO1xuXG4gICAgLy8gaWYgbmF0aXZlbHkgc3VwcG9ydGVkLCBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCdjcmVhdGVkQ2FsbGJhY2snIGluIGRpdi5xdWVyeVNlbGVjdG9yKGRyZSkpIHtcbiAgICAgIC8vIHJldHVybiBqdXN0IGFuIGlubmVySFRNTCB3cmFwXG4gICAgICByZXR1cm4gKHJlZ2lzdGVyLmlubmVySFRNTCA9IGZ1bmN0aW9uIChlbCwgaHRtbCkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSBjYXRjaChtZWgpIHt9XG5cbiAgLy8gaW4gb3RoZXIgY2FzZXNcbiAgcmVnaXN0ZXJlZCA9IFtdO1xuICBpbml0aWFsaXplID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKFxuICAgICAgJ2NyZWF0ZWRDYWxsYmFjaycgaW4gZWwgICAgICAgICB8fFxuICAgICAgJ2F0dGFjaGVkQ2FsbGJhY2snIGluIGVsICAgICAgICB8fFxuICAgICAgJ2RldGFjaGVkQ2FsbGJhY2snIGluIGVsICAgICAgICB8fFxuICAgICAgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycgaW4gZWxcbiAgICApIHJldHVybjtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlciA9IHRydWU7XG4gICAgZm9yICh2YXJcbiAgICAgIHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgdHlwZSA9IGVsLmdldEF0dHJpYnV0ZSgnaXMnKSxcbiAgICAgIG5hbWUgPSBlbC5ub2RlTmFtZSxcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgdHlwZSA/IFtuYW1lLCB0eXBlXSA6IFtuYW1lXVxuICAgICAgKSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBlbC5hdHRyaWJ1dGVzLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aCxcbiAgICAgIGF0dHIsIGZjO1xuICAgICAgaSA8IGxlbmd0aDsgaSsrXG4gICAgKSB7XG4gICAgICBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgbm9kZS5jcmVhdGVkID0gdHJ1ZTtcbiAgICAgIG5vZGUuY3JlYXRlZENhbGxiYWNrKCk7XG4gICAgICBub2RlLmNyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKChmYyA9IGVsLmZpcnN0Q2hpbGQpKSBub2RlLmFwcGVuZENoaWxkKGZjKTtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBlbCk7XG4gIH07XG4gIC8vIGF1Z21lbnQgdGhlIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCBtZXRob2RcbiAgcmV0dXJuICgoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ID0gZnVuY3Rpb24gcmVnaXN0ZXJFbGVtZW50KHR5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IChvcHRpb25zW0VYVEVORFNdID9cbiAgICAgIChvcHRpb25zW0VYVEVORFNdICsgJ1tpcz1cIicgKyB0eXBlICsgJ1wiXScpIDogdHlwZVxuICAgICkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVnaXN0ZXJlZC5pbmRleE9mKG5hbWUpIDwgMCkgcmVnaXN0ZXJlZC5wdXNoKG5hbWUpO1xuICAgIHJldHVybiByZWdpc3Rlci5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgfSkuaW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsLCBodG1sKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBmb3IgKHZhclxuICAgICAgbm9kZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKHJlZ2lzdGVyZWQuam9pbignLCcpKSxcbiAgICAgIGkgPSBub2Rlcy5sZW5ndGg7IGktLTsgaW5pdGlhbGl6ZShub2Rlc1tpXSlcbiAgICApIHt9XG4gICAgcmV0dXJuIGVsO1xuICB9KTtcbn0oZG9jdW1lbnQpKTsiLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlciAoc2VydmVyIG9yIGJyb3dzZXIpXG4gKiBcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxuICpcbiAqIC0gY3JlYXRlIGEgTWljcm9FdmVudERlYnVnIHdpdGggZ29vZGllcyB0byBkZWJ1Z1xuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXG4qL1xuXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xuXG52YXIgTWljcm9FdmVudCAgPSBmdW5jdGlvbigpe307XG5NaWNyb0V2ZW50LnByb3RvdHlwZSAgPSB7XG4gIG9uICA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcbiAgfSxcbiAgb25jZSA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZXIpO1xuICAgICAgcmV0dXJuIGZjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudCwgd3JhcHBlcik7XG4gIH0sXG4gIG9mZiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcblxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKF9mY3QpIHtcbiAgICAgICAgaWYgKGZjdCkge1xuICAgICAgICAgICByZXR1cm4gZmN0ICE9PSBfZmN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG4gIGVtaXQgOiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF1baV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIG1peGluIHdpbGwgZGVsZWdhdGUgYWxsIE1pY3JvRXZlbnQuanMgZnVuY3Rpb24gaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuICpcbiAqIC0gcmVxdWlyZSgnTWljcm9FdmVudCcpLm1peGluKEZvb2Jhcikgd2lsbCBtYWtlIEZvb2JhciBhYmxlIHRvIHVzZSBNaWNyb0V2ZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcbiovXG5NaWNyb0V2ZW50Lm1peGluICA9IGZ1bmN0aW9uKGRlc3RPYmplY3Qpe1xuICB2YXIgcHJvcHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArKyl7XG4gICAgaWYoIHR5cGVvZiBkZXN0T2JqZWN0ID09PSAnZnVuY3Rpb24nICl7XG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1lbHNle1xuICAgICAgZGVzdE9iamVjdFtwcm9wc1tpXV0gPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBpbiBjb21tb24ganNcbmlmKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmICgnZXhwb3J0cycgaW4gbW9kdWxlKSl7XG4gIG1vZHVsZS5leHBvcnRzICA9IE1pY3JvRXZlbnQ7XG59XG5cbndpbmRvdy5NaWNyb0V2ZW50ID0gTWljcm9FdmVudDtcbiIsIihmdW5jdGlvbiAocm9vdCkge1xuXG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBcbiAgLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICAgIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHNlbGYsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHNlbGYuX3N0YXRlID0gMjtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgIH1cbiAgICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gICAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICAgKlxuICAgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gICAqL1xuICBmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb20gPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKG5vb3ApO1xuXG4gICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgcmV0dXJuIHByb207XG4gIH07XG5cbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIHBvbHlmaWxsIGZvciBzZXRJbW1lZGlhdGUgZm9yIHBlcmZvcm1hbmNlIGdhaW5zXG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH0pIHx8XG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gICAgfTtcblxuICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBpbW1lZGlhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFja3NcbiAgICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0SW1tZWRpYXRlRm4gPSBmdW5jdGlvbiBfc2V0SW1tZWRpYXRlRm4oZm4pIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9IGZuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuKGZuKSB7XG4gICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmbjtcbiAgfTtcblxuICBpZiAoIXdpbmRvdy5Qcm9taXNlKSB7XG4gICAgd2luZG93LlByb21pc2UgPSBQcm9taXNlO1xuICB9XG59KSh0aGlzKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGFcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KCkpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcblxuICAgICAgICB0aGlzLlBSRV9JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLklPUzdfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG4gICAgICAgIHRoaXMuREVGQVVMVF9WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcblxuICAgICAgICB0aGlzLmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0ge307XG4gICAgICAgIHRoaXMucGxhdGZvcm0ubmFtZSA9IHRoaXMuZ2V0UGxhdGZvcm1OYW1lKCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0udmVyc2lvbiA9IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5lbnN1cmVWaWV3cG9ydEVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcbiAgICAgICAgaWYoIXRoaXMudmlld3BvcnRFbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQubmFtZSA9IFwidmlld3BvcnRcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3cG9ydEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5vLWFkanVzdCcpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5uYW1lID09ICdpb3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0udmVyc2lvbiA+PSA3ICYmIGlzV2ViVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLkRFRkFVTFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNXZWJWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImFuZHJvaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpb3NcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVua25vd25cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPUyAnKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5OdW1iZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuc3Vic3RyKHN0YXJ0ICsgMywgMykucmVwbGFjZSgnXycsICcuJykpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuVmlld3BvcnQgPSBWaWV3cG9ydDtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBPcGVuIFRlY2hub2xvZ2llcywgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbi8vIEphdmFTY3JpcHQgRHluYW1pYyBDb250ZW50IHNoaW0gZm9yIFdpbmRvd3MgU3RvcmUgYXBwc1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh3aW5kb3cuTVNBcHAgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcblxuICAgICAgICAvLyBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhbiBcImF0dHJpYnV0ZXNcIiBwcm9wZXJ0eSB3aGljaCBzaGFkb3dzIHRoZSBOb2RlLnByb3RvdHlwZS5hdHRyaWJ1dGVzIHByb3BlcnR5XG4gICAgICAgIC8vICBhbmQgbWVhbnMgd2UgZG9uJ3QgYWN0dWFsbHkgc2VlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBOb2RlIChpbnRlcmVzdGluZ2x5IHRoZSBWUyBkZWJ1ZyBjb25zb2xlXG4gICAgICAgIC8vICBhcHBlYXJzIHRvIHN1ZmZlciBmcm9tIHRoZSBzYW1lIGlzc3VlKS5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIEVsZW1lbnRfc2V0QXR0cmlidXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJzZXRBdHRyaWJ1dGVcIikudmFsdWU7XG4gICAgICAgIHZhciBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwicmVtb3ZlQXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIpO1xuICAgICAgICB2YXIgTm9kZV9nZXRfYXR0cmlidXRlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBOb2RlX2dldF9jaGlsZE5vZGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIpLmdldDtcbiAgICAgICAgdmFyIGRldGVjdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfYXR0cmlidXRlcy5jYWxsKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkTm9kZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2NoaWxkTm9kZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEhUTUwoZWxlbWVudCwgcG9zaXRpb24sIGh0bWwpIHtcbiAgICAgICAgICAgIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvci52YWx1ZS5jYWxsKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluVW5zYWZlTW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBpc1Vuc2FmZSA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvbkRpdi5pbm5lckhUTUwgPSBcIjx0ZXN0Lz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlzVW5zYWZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1Vuc2FmZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2UoaHRtbCwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNsZWFuZXIgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJjbGVhbmVyXCIpO1xuICAgICAgICAgICAgZW1wdHkoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50SFRNTChjbGVhbmVyLmRvY3VtZW50RWxlbWVudCwgXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gY2xlYW5lci5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2NyaXB0cywgZnVuY3Rpb24gKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NyaXB0LnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvanNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9saXZlc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwidGV4dC9cIi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJhcHBsaWNhdGlvbi9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwiYXBwbGljYXRpb24vXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhdHRyaWJ1dGVzIGNvbGxlY3Rpb24gaXMgbGl2ZSBpdCBpcyBzaW1wbGVyIHRvIHF1ZXVlIHVwIHRoZSByZW5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5hbWVbMF0gPT09IFwib1wiIHx8IG5hbWVbMF0gPT09IFwiT1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lWzFdID09PSBcIm5cIiB8fCBuYW1lWzFdID09PSBcIk5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyBuYW1lOiBhdHRyaWJ1dGUubmFtZSwgdmFsdWU6IGF0dHJpYnV0ZS52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBcIngtXCIgKyBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZE5vZGVzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgY2xlYW5lZE5vZGVzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCkuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5oZWFkKS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5ib2R5KS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZVByb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2V0dGVyID0gcHJvcGVydHlEZXNjcmlwdG9yLnNldDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5XaW5KUyAmJiB3aW5kb3cuV2luSlMuX2V4ZWNVbnNhZmUgJiYgaW5VbnNhZmVNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY2xlYW5zZSh2YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHByb3BlcnR5RGVzY3JpcHRvciwgdGhhdCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcImlubmVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbXB0eSh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcIm91dGVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0oKSk7IiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1bndyYXAgPSBzdHJpbmcgPT4gc3RyaW5nLnNsaWNlKDEsIC0xKTtcbmNvbnN0IGlzT2JqZWN0U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCd7JykgJiYgc3RyaW5nLmVuZHNXaXRoKCd9Jyk7XG5jb25zdCBpc0FycmF5U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCdbJykgJiYgc3RyaW5nLmVuZHNXaXRoKCddJyk7XG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHN0cmluZyA9PiAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcJycpICYmIHN0cmluZy5lbmRzV2l0aCgnXFwnJykpIHx8IChzdHJpbmcuc3RhcnRzV2l0aCgnXCInKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1wiJykpO1xuXG5jb25zdCBlcnJvciA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG59O1xuXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgcmV0dXJuICsodG9rZW4pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgbmV4dFRva2VuID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbUxlZnQoKTtcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcblxuICBpZiAoc3RyaW5nWzBdID09PSAnOicgfHwgc3RyaW5nWzBdID09PSAnLCcpIHtcblxuICAgIGxpbWl0ID0gMTtcblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYykge1xuICAgICAgICBuZXN0ZWRPYmplY3QrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMgKyAyKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdC0tO1xuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XG4gICAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ1xcJycgfHwgc3RyaW5nWzBdID09PSAnXFxcIicpIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSBzdHJpbmdbMF0pIHtcbiAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcbn07XG5cbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBpc1ZhbGlkS2V5ID0ga2V5ID0+IC9eW0EtWl9cXCRdW0EtWjAtOV9cXCRdKiQvaS50ZXN0KGtleSk7XG5cbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xuXG4gICAgaWYgKCh0b2tlbiA9PT0gJzonICYmICghcmVhZGluZ0tleSB8fCAhcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKVxuICAgICAgIHx8ICh0b2tlbiA9PT0gJywnICYmIHJlYWRpbmdLZXkpXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBwYXJzZUFycmF5ID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2UgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xuXG5jb25zdCB1dGlsID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnV0aWwucHJlcGFyZVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIHJldHVybiBxdWVyeSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcXVlcnkgOiAoZWxlbWVudCkgPT4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZVxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHMgQ1NTIFNlbGVjdG9yLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5tYXRjaCA9IChlLCBzKSA9PiAoZS5tYXRjaGVzIHx8IGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGUubXNNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZSwgcyk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICBpZiAobWF0Y2gobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRQYXJlbnQgPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobWF0Y2gocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzQXR0YWNoZWQgPSAoZWxlbWVudCkgPT4ge1xuICB3aGlsZSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8ob25zLW5hdmlnYXRvcnxvbnMtdGFiYmFyfG9ucy1tb2RhbHxvbnMtc2xpZGluZy1tZW51fG9ucy1zcGxpdC12aWV3KS8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gKi9cbnV0aWwucHJvcGFnYXRlQWN0aW9uID0gKGVsZW1lbnQsIGFjdGlvbikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZFthY3Rpb25dIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oY2hpbGQsIGFjdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGUgPSAoc2VsZWN0b3IgPSAnJywgc3R5bGUgPSB7fSkgPT4ge1xuICBjb25zdCBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XG5cbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cblxuICB1dGlsLmV4dGVuZChlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZUVsZW1lbnQgPSAoaHRtbCkgPT4ge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVySFRNTCh3cmFwcGVyLCBodG1sKTtcblxuICBpZiAod3JhcHBlci5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImh0bWxcIiBtdXN0IGJlIG9uZSB3cmFwcGVyIGVsZW1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlci5jaGlsZHJlblswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXJIVE1MKHdyYXBwZXIsIGh0bWwpO1xuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn07XG5cbi8qXG4gKiBAcGFyYW0ge09iamVjdH0gZHN0IERlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cbiAqL1xudXRpbC5leHRlbmQgPSAoZHN0LCAuLi5hcmdzKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnc1tpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgZHN0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuYXJyYXlGcm9tID0gKGFycmF5TGlrZSkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhaWxTYWZlXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLnBhcnNlSlNPTk9iamVjdFNhZmVseSA9IChqc29uU3RyaW5nLCBmYWlsU2FmZSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFpbFNhZmU7XG4gIH1cbiAgcmV0dXJuIGZhaWxTYWZlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcbiAqIEByZXR1cm4ge0FueX0gLSB3aGF0ZXZlciBpcyBsb2NhdGVkIGF0IHRoYXQgcGF0aFxuICovXG51dGlsLmZpbmRGcm9tUGF0aCA9IChwYXRoKSA9PiB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBlbCA9IHdpbmRvdywga2V5O1xuICB3aGlsZSAoa2V5ID0gcGF0aC5zaGlmdCgpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICBlbCA9IGVsW2tleV07XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxuICogQHJldHVybiB7Q3VzdG9tRXZlbnR9XG4gKi9cbnV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgZGV0YWlsID0ge30pID0+IHtcblxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZGV0YWlsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZXZlbnRba2V5XSA9IGRldGFpbFtrZXldO1xuICB9KTtcblxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5oYXNNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKS5zb21lKGUgPT4gZSA9PT0gbW9kaWZpZXJOYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGFkZGVkIG9yIG5vdC5cbiAqL1xudXRpbC5hZGRNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAodXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtb2RpZmllck5hbWUgPSBtb2RpZmllck5hbWUudHJpbSgpO1xuICBjb25zdCBtb2RpZmllckF0dHJpYnV0ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgKG1vZGlmaWVyQXR0cmlidXRlICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC5yZW1vdmVNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLyk7XG5cbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lKTtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKTtcblxuICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcbn07XG5cbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn07XG5cbnV0aWwuYmluZExpc3RlbmVycyA9IChlbGVtZW50LCBsaXN0ZW5lck5hbWVzKSA9PiB7XG4gIGxpc3RlbmVyTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBib3VuZE5hbWUgPSBuYW1lLnJlcGxhY2UoL15fW2Etel0vLCAnX2JvdW5kJyArIG5hbWVbMV0udG9VcHBlckNhc2UoKSk7XG4gICAgZWxlbWVudFtib3VuZE5hbWVdID0gZWxlbWVudFtib3VuZE5hbWVdIHx8IGVsZW1lbnRbbmFtZV0uYmluZChlbGVtZW50KTtcbiAgfSk7XG59O1xuXG51dGlsLmVhY2ggPSAob2JqLCBmKSA9PiBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IGYoa2V5LCBvYmpba2V5XSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xudXRpbC51cGRhdGVSaXBwbGUgPSAodGFyZ2V0KSA9PiB7XG4gIGNvbnN0IHJpcHBsZUVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0YXJnZXQsICdvbnMtcmlwcGxlJyk7XG5cbiAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICAgaWYgKCFyaXBwbGVFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1yaXBwbGUnKSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyaXBwbGVFbGVtZW50KSB7XG4gICAgcmlwcGxlRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UgPSBhbmltYXRpb25PcHRpb25zUGFyc2U7XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG51dGlsLmlzSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7T2JlamN0fSBEZWZlcnJlZCBwcm9taXNlLlxuICovXG51dGlsLmRlZmVyID0gKCkgPT4ge1xuICBjb25zdCBkZWZlcnJlZCA9IHt9O1xuICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHJldHVybiBkZWZlcnJlZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5cbi8qKlxuICogTWluaW1hbCBhbmltYXRpb24gbGlicmFyeSBmb3IgbWFuYWdpbmcgY3NzIHRyYW5zaXRpb24gb24gbW9iaWxlIGJyb3dzZXJzLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUSU1FT1VUX1JBVElPID0gMS40O1xuXG52YXIgdXRpbCA9IHtcbn07XG5cbi8vIGNhcGl0YWxpemUgc3RyaW5nXG51dGlsLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICogQHBhcmFtIHtGbG9hdH0gcGFyYW1zLmR1cmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnRpbWluZ1xuICovXG51dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcy5wcm9wZXJ0eSA9IHBhcmFtcy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XG5cbiAgdmFyIHByb3BzID0gcGFyYW1zLnByb3BlcnR5LnNwbGl0KC8gKy8pO1xuXG4gIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wICsgJyAnICsgcGFyYW1zLmR1cmF0aW9uICsgJ3MgJyArIHBhcmFtcy50aW1pbmc7XG4gIH0pLmpvaW4oJywgJyk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICovXG51dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcblxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbn07XG5cbnV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiBbJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJ107XG4gIH1cblxuICBpZiAodXRpbC52ZW5kb3JQcmVmaXggPT09ICd3ZWJraXQnIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbycgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtb3onIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbXMnKSB7XG4gICAgcmV0dXJuIFt1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn0pKCk7XG5cbnV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICB2YXIgZGljdCA9IHt9O1xuICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xuXG4gIHZhciB1cHBlciA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgIC5yZXBsYWNlKC9eW1xcLV0rLywgJycpXG4gICAgLnJlcGxhY2UoL1tcXC1dW2Etel0vZywgdXBwZXIpXG4gICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICBpZiAoYSA8PSBrZXkuY2hhckNvZGVBdCgwKSAmJiB6ID49IGtleS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnY3NzVGV4dCcgJiYga2V5ICE9PSAncGFyZW50VGV4dCcpIHtcbiAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGljdDtcbn0pKCk7XG5cbnV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcbn07XG5cbi8qKlxuICogVmVuZG9yIHByZWZpeCBmb3IgY3NzIHByb3BlcnR5LlxuICovXG51dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpLFxuICAgIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5jYWxsKHN0eWxlcylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgICApWzFdO1xuICAgIHJldHVybiBwcmU7XG59KSgpO1xuXG51dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuYmF0Y2hJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxudXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gJ3RyYW5zaXRpb24nO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkodXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbic7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbnZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltaXQoZWxlbWVudCk7XG4gIH1cblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtlbGVtZW50XTtcbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudDtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvciBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudC4nKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNpdGlvblF1ZXVlID0gW107XG4gIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xufTtcblxuQW5pbWl0LnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgKi9cbiAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9KVxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2Nzczoge2NvbG9yOiAncmVkJ30sIGR1cmF0aW9uOiAwLjJ9KVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMudHJhbnNpdGlvblF1ZXVlO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gJiYgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgaWYgKHRyYW5zaXRpb24uY3NzKSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHtcbiAgICAgICAgICBjc3M6IHRyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgKi9cbiAgd2FpdDogZnVuY3Rpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCAqIHNlY29uZHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgZWxlbWVudCdzIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNpdGlvbl1cbiAgICovXG4gIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmR1cmF0aW9uXCIgaXMgcmVxdWlyZWQgd2hlbiBcIm9wdGlvbnMudHJhbnNpdGlvblwiIGlzIGVuYWJsZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiB8fCAob3B0aW9ucy5kdXJhdGlvbiAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSBvcHRpb25zLnRyYW5zaXRpb24gfHwgKCdhbGwgJyArIG9wdGlvbnMuZHVyYXRpb24gKyAncyAnICsgKG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInKSk7XG5cbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJyc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmb3IgZmFpbCBzYWZlLlxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPKTtcblxuICAgICAgICAvLyB0cmFuc2l0aW9uIGFuZCBzdHlsZSBzZXR0aW5nc1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3NzW25hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJ25vbmUnO1xuXG4gICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5hbWUgPSAnJzsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RhcnRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHR3aWNlLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QW5pbWl0fSBhcmd1bWVudHNcbiAqL1xuQW5pbWl0LnJ1bkFsbCA9IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cy4uLiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICovXG5BbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLmR1cmF0aW9uID0gdGhpcy5vcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLnByb3BlcnR5ID0gdGhpcy5vcHRpb25zLnByb3BlcnR5IHx8ICdhbGwnO1xufTtcblxuQW5pbWl0LlRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmNzcyBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgY3NzID0gY3JlYXRlQWN0dWFsQ3NzUHJvcHModGhpcy5vcHRpb25zLmNzcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSAnJztcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHV0aWwuZm9yY2VMYXlvdXRBdE9uY2UoZWxlbWVudHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdHVhbENzc1Byb3BzKGNzcykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkocHJlZml4ZWQpKSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0ICBBbmltaXQ7XG5cbiIsIi8qXG4gKiBHZXN0dXJlIGRldGVjdG9yIGxpYnJhcnkgdGhhdCBmb3JrZWQgZnJvbSBnaXRodWIuY29tL0VpZ2h0TWVkaWEvaGFtbWVyLmpzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50LCBVdGlscywgRGV0ZWN0aW9uLCBQb2ludGVyRXZlbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMuR2VzdHVyZURldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1VdGlsaXR5IGNsYXNzIGZvciBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Kv44Op44K544Gn44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAqIEBzaWduYXR1cmUgY29uc3RydWN0b3IoZWxlbWVudFssIG9wdGlvbnNdKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXUNyZWF0ZSBhIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UuWy9lbl1cbiAqICBbamFdR2VzdHVyZURldGVjdG9y44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi0RPTeimgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge29ucy5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbnZhciBHZXN0dXJlRGV0ZWN0b3IgPSBmdW5jdGlvbiBHZXN0dXJlRGV0ZWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZShlbGVtZW50LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICogbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBgL2dlc3R1cmVzYC4gRWFjaCBnZXN0dXJlIGNhbiBiZSBkaXNhYmxlZC9lbmFibGVkXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cbiAqIFlvdSBjYW4gc2V0IHRoZSBkZWZhdWx0cyBmb3IgYWxsIGluc3RhbmNlcyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmcgYW4gaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5kcmFnID0gZmFsc2U7XG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uID0gJ3Bhbi15JztcbiAqICBkZWxldGUgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XG4gKiBgYGBgXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyA9IHtcbiAgYmVoYXZpb3I6IHtcbiAgICAvLyB1c2VyU2VsZWN0OiAnbm9uZScsIC8vIEFsc28gZGlzYWJsZXMgc2VsZWN0aW9uIGluIGBpbnB1dGAgY2hpbGRyZW5cbiAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcbiAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcbiAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICB9XG59O1xuXG4vKipcbiAqIEdlc3R1cmVEZXRlY3RvciBkb2N1bWVudCB3aGVyZSB0aGUgYmFzZSBldmVudHMgYXJlIGFkZGVkIGF0XG4gKiBAcHJvcGVydHkgRE9DVU1FTlRcbiAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAqIEBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICovXG5HZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQgPSBkb2N1bWVudDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfUE9JTlRFUkVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4vKipcbiAqIGRldGVjdCBtb2JpbGUgYnJvd3NlcnNcbiAqIEBwcm9wZXJ0eSBJU19NT0JJTEVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBkZXRlY3QgaWYgd2Ugd2FudCB0byBzdXBwb3J0IG1vdXNlZXZlbnRzIGF0IGFsbFxuICogQHByb3BlcnR5IE5PX01PVVNFRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTID0gKEdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgJiYgR2VzdHVyZURldGVjdG9yLklTX01PQklMRSkgfHwgR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTO1xuXG4vKipcbiAqIGludGVydmFsIGluIHdoaWNoIEdlc3R1cmVEZXRlY3RvciByZWNhbGN1bGF0ZXMgY3VycmVudCB2ZWxvY2l0eS9kaXJlY3Rpb24vYW5nbGUgaW4gbXNcbiAqIEBwcm9wZXJ0eSBDQUxDVUxBVEVfSU5URVJWQUxcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCAyNVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMID0gMjU7XG5cbi8qKlxuICogZXZlbnR0eXBlcyBwZXIgdG91Y2hldmVudCAoc3RhcnQsIG1vdmUsIGVuZCkgYXJlIGZpbGxlZCBieSBgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlc2Agb24gYHNldHVwYFxuICogdGhlIG9iamVjdCBjb250YWlucyB0aGUgRE9NIGV2ZW50IG5hbWVzIHBlciB0eXBlIChgRVZFTlRfU1RBUlRgLCBgRVZFTlRfTU9WRWAsIGBFVkVOVF9FTkRgKVxuICogQHByb3BlcnR5IEVWRU5UX1RZUEVTXG4gKiBAcHJpdmF0ZVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge307XG5cbi8qKlxuICogZGlyZWN0aW9uIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgRElSRUNUSU9OX0RPV058TEVGVHxVUHxSSUdIVFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ2Rvd24nICdsZWZ0JyAndXAnICdyaWdodCdcbiAqL1xudmFyIERJUkVDVElPTl9ET1dOID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9ET1dOID0gJ2Rvd24nO1xudmFyIERJUkVDVElPTl9MRUZUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xudmFyIERJUkVDVElPTl9VUCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fVVAgPSAndXAnO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuXG4vKipcbiAqIHBvaW50ZXJ0eXBlIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5cbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdtb3VzZScgJ3RvdWNoJyAncGVuJ1xuICovXG52YXIgUE9JTlRFUl9NT1VTRSA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX01PVVNFID0gJ21vdXNlJztcbnZhciBQT0lOVEVSX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xudmFyIFBPSU5URVJfUEVOID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfUEVOID0gJ3Blbic7XG5cbi8qKlxuICogZXZlbnR0eXBlc1xuICogQHByb3BlcnR5IEVWRU5UX1NUQVJUfE1PVkV8RU5EfFJFTEVBU0V8VE9VQ0hcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdzdGFydCcgJ2NoYW5nZScgJ21vdmUnICdlbmQnICdyZWxlYXNlJyAndG91Y2gnXG4gKi9cbnZhciBFVkVOVF9TVEFSVCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9TVEFSVCA9ICdzdGFydCc7XG52YXIgRVZFTlRfTU9WRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9NT1ZFID0gJ21vdmUnO1xudmFyIEVWRU5UX0VORCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9FTkQgPSAnZW5kJztcbnZhciBFVkVOVF9SRUxFQVNFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1JFTEVBU0UgPSAncmVsZWFzZSc7XG52YXIgRVZFTlRfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfVE9VQ0ggPSAndG91Y2gnO1xuXG4vKipcbiAqIGlmIHRoZSB3aW5kb3cgZXZlbnRzIGFyZSBzZXQuLi5cbiAqIEBwcm9wZXJ0eSBSRUFEWVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSBmYWxzZTtcblxuLyoqXG4gKiBwbHVnaW5zIG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHBsdWdpbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zID0gR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgfHwge307XG5cbi8qKlxuICogZ2VzdHVyZXMgbmFtZXNwYWNlXG4gKiBzZWUgYC9nZXN0dXJlc2AgZm9yIHRoZSBkZWZpbml0aW9uc1xuICogQHByb3BlcnR5IGdlc3R1cmVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgPSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgfHwge307XG5cbi8qKlxuICogc2V0dXAgZXZlbnRzIHRvIGRldGVjdCBnZXN0dXJlcyBvbiB0aGUgZG9jdW1lbnRcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYW4gbmV3IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgaWYoR2VzdHVyZURldGVjdG9yLlJFQURZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XG5cbiAgLy8gUmVnaXN0ZXIgYWxsIGdlc3R1cmVzIGluc2lkZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgVXRpbHMuZWFjaChHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICBEZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gIH0pO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9NT1ZFLCBEZXRlY3Rpb24uZGV0ZWN0KTtcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgLy8gR2VzdHVyZURldGVjdG9yIGlzIHJlYWR5Li4uIVxuICBHZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFV0aWxzXG4gKiBAc3RhdGljXG4gKi9cblV0aWxzID0gR2VzdHVyZURldGVjdG9yLnV0aWxzID0ge1xuICAvKipcbiAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV0gIGRvIGEgbWVyZ2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChkZXN0W2tleV0gPT09IHVuZGVmaW5lZCB8fCAhbWVyZ2UpKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3JFYWNoIG92ZXIgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHthbnl9IGl0ZXJhdG9yLml0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBpdGVyYXRvci5vYmogdGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYCBpbiB0aGUgaXRlcmF0b3JcbiAgICovXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBuYXRpdmUgZm9yRWFjaCBvbiBhcnJheXNcbiAgICBpZignZm9yRWFjaCcgaW4gb2JqKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAvLyBhcnJheXNcbiAgICB9IGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZihpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG9iamVjdHNcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaW5TdHI6IGZ1bmN0aW9uIGluU3RyKHNyYywgZmluZCkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG4gIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kKSB7XG4gICAgaWYoc3JjLmluZGV4T2YpIHtcbiAgICAgIHZhciBpbmRleCA9IHNyYy5pbmRleE9mKGZpbmQpO1xuICAgICAgcmV0dXJuIChpbmRleCA9PT0gLTEpID8gZmFsc2UgOiBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBoYXNQYXJlbnQ6IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZShub2RlKSB7XG4gICAgICBpZihub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHBhZ2VYYCwgYHBhZ2VZYCwgYGNsaWVudFhgIGFuZCBgY2xpZW50WWAgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIodG91Y2hlcykge1xuICAgIHZhciBwYWdlWCA9IFtdLFxuICAgICAgICBwYWdlWSA9IFtdLFxuICAgICAgICBjbGllbnRYID0gW10sXG4gICAgICAgIGNsaWVudFkgPSBbXSxcbiAgICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZih0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgIHBhZ2VZOiB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBVdGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VYOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VYKSArIG1heC5hcHBseShNYXRoLCBwYWdlWCkpIC8gMixcbiAgICAgIHBhZ2VZOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VZKSArIG1heC5hcHBseShNYXRoLCBwYWdlWSkpIC8gMixcbiAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcbiAgICAgIGNsaWVudFk6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WSkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WSkpIC8gMlxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMoZGVsdGFYIC8gZGVsdGFUaW1lKSB8fCAwLFxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGdldEFuZ2xlOiBmdW5jdGlvbiBnZXRBbmdsZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXG4gICAqL1xuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZKTtcblxuICAgIGlmKHggPj0geSkge1xuICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXNcbiAgICogQHBhcmFtIHtUb3VjaH10b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cbiAgZ2V0Um90YXRpb246IGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIG91dCBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9VUHxET1dOYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBjc3MgcHJvcGVydGllcyB3aXRoIHRoZWlyIHByZWZpeGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2V0UHJlZml4ZWRDc3M6IGZ1bmN0aW9uIHNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHJvcDtcbiAgICAgIC8vIHByZWZpeGVzXG4gICAgICBpZihwcmVmaXhlc1tpXSkge1xuICAgICAgICBwID0gcHJlZml4ZXNbaV0gKyBwLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXN0IHRoZSBzdHlsZVxuICAgICAgaWYocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09PSBudWxsIHx8IHRvZ2dsZSkgJiYgdmFsdWUgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogdG9nZ2xlIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBieSBzZXR0aW5nIGNzcyBwcm9wZXJ0aWVzLlxuICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKi9cbiAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICBpZighcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgIFV0aWxzLnNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGFsc28gdGhlIGRpc2FibGUgb25zZWxlY3RzdGFydFxuICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgIH1cbiAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgIGlmKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGEgc3RyaW5nIHdpdGggdW5kZXJzY29yZXMgdG8gY2FtZWxDYXNlXG4gICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBjYW1lbENhc2VTdHJcbiAgICovXG4gIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG5FdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzdG9wIG1vdXNlIGV2ZW50c1xuICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHByZXZlbnRNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAqIEBwcm9wZXJ0eSBzdGFydGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhcnRlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gICAqIEBwcm9wZXJ0eSBzaG91bGRfZGV0ZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IGJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IHVuYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgVXRpbHMub2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSB0b3VjaCBldmVudCBoYW5kbGVyLlxuICAgKiB0aGlzIGZpbmRzIG91dCBpZiB3ZSBzaG91bGQgdG8gZGV0ZWN0IGdlc3R1cmVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIG9uVG91Y2hIYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNvcmUgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaXNQb2ludGVyID0gR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgaWYoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAvLyBqdXN0IGEgdmFsaWQgc3RhcnQgZXZlbnQsIGJ1dCBubyBtb3VzZVxuICAgICAgfSBlbHNlIGlmKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIGEgdG91Y2gvZG93biBzdGF0ZSwgc28gYWxsb3dlZCBkZXRlY3Rpb24gb2YgZ2VzdHVyZXNcbiAgICAgIGlmKHNlbGYuc2hvdWxkRGV0ZWN0KSB7XG4gICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IGZhbHNlO1xuICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cbiAgICAgIH1cblxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oZWxlbWVudCwgRVZFTlRfVFlQRVNbZXZlbnRUeXBlXSwgb25Ub3VjaEhhbmRsZXIpO1xuICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgZGV0ZWN0aW9uIG1ldGhvZFxuICAgKiB0aGlzIGZpbmRzIG91dCB3aGF0IEdlc3R1cmVEZXRlY3Rvci10b3VjaC1ldmVudHMgdG8gdHJpZ2dlclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdHJpZ2dlclR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqL1xuICBkb0RldGVjdDogZnVuY3Rpb24gZG9EZXRlY3QoZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcikge1xuICAgIHZhciB0b3VjaExpc3QgPSB0aGlzLmdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKTtcbiAgICB2YXIgdG91Y2hMaXN0TGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aDtcbiAgICB2YXIgdHJpZ2dlclR5cGUgPSBldmVudFR5cGU7XG4gICAgdmFyIHRyaWdnZXJDaGFuZ2UgPSB0b3VjaExpc3QudHJpZ2dlcjsgLy8gdXNlZCBieSBmYWtlTXVsdGl0b3VjaCBwbHVnaW5cbiAgICB2YXIgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdExlbmd0aDtcblxuICAgIC8vIGF0IGVhY2ggdG91Y2hzdGFydC1saWtlIGV2ZW50IHdlIHdhbnQgYWxzbyB3YW50IHRvIHRyaWdnZXIgYSBUT1VDSCBldmVudC4uLlxuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1RPVUNIO1xuICAgICAgLy8gLi4udGhlIHNhbWUgZm9yIGEgdG91Y2hlbmQtbGlrZSBldmVudFxuICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcblxuICAgICAgLy8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcbiAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgIC8vIGJ1dCBvbmx5IGFmdGVyIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB0aGUgZmlyc3QgdGltZSB3ZSBhY3R1YWxseSB3YW50IGEgU1RBUlRcbiAgICBpZihjaGFuZ2VkTGVuZ3RoID4gMCAmJiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRyaWdnZXJUeXBlID0gRVZFTlRfTU9WRTtcbiAgICB9XG5cbiAgICAvLyBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGlzLCBzZWUgYWJvdmVcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgLy8gZ2VuZXJhdGUgc29tZSBldmVudCBkYXRhLCBzb21lIGJhc2ljIGluZm9ybWF0aW9uXG4gICAgdmFyIGV2RGF0YSA9IHRoaXMuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCB0cmlnZ2VyVHlwZSwgdG91Y2hMaXN0LCBldik7XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSB0cmlnZ2VyVHlwZSBldmVudCBiZWZvcmUgdGhlIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50c1xuICAgIC8vIGJ1dCB0aGUgRU5EIGV2ZW50IHNob3VsZCBiZSBhdCBsYXN0XG4gICAgaWYoZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGEgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnQsIHRoaXMgbWVhbnMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2hlcyBjaGFuZ2VkXG4gICAgaWYodHJpZ2dlckNoYW5nZSkge1xuICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcbiAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaWdnZXJUeXBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiB3ZSBoYXZlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggZGV2aWNlL2Jyb3dzZXJcbiAgICogZGV0ZXJtaW5lIHdoYXQgd2UgbmVlZCBhbmQgc2V0IHRoZW0gaW4gdGhlIEVWRU5UX1RZUEVTIGNvbnN0YW50XG4gICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBldmVudHNcbiAgICovXG4gIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XG4gICAgdmFyIHR5cGVzO1xuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgaWYod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIGxvc3Rwb2ludGVyY2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgJ01TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCBNU0xvc3RQb2ludGVyQ2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTKSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJ1xuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsXG4gICAgICAgICd0b3VjaG1vdmUgbW91c2Vtb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAnXG4gICAgICBdO1xuICAgIH1cblxuICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfRU5EXSA9IHR5cGVzWzJdO1xuICAgIHJldHVybiBFVkVOVF9UWVBFUztcbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlIHRvdWNoTGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGVzXG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XG4gICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICBpZihHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIHJldHVybiBQb2ludGVyRXZlbnQuZ2V0VG91Y2hMaXN0KCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB0b3VjaGxpc3RcbiAgICBpZihldi50b3VjaGVzKSB7XG4gICAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfTU9WRSkge1xuICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIGlmKFV0aWxzLmluQXJyYXkoaWRlbnRpZmllcnMsIHRvdWNoLmlkZW50aWZpZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRvdWNoTGlzdC5wdXNoKHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRvdWNoLmlkZW50aWZpZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0b3VjaExpc3Q7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBmYWtlIHRvdWNoTGlzdCBmcm9tIG1vdXNlIHBvc2l0aW9uXG4gICAgZXYuaWRlbnRpZmllciA9IDE7XG4gICAgcmV0dXJuIFtldl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbGxlY3QgYmFzaWMgZXZlbnQgZGF0YVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGNvbGxlY3RFdmVudERhdGE6IGZ1bmN0aW9uIGNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgZXZlbnRUeXBlLCB0b3VjaGVzLCBldikge1xuICAgIC8vIGZpbmQgb3V0IHBvaW50ZXJUeXBlXG4gICAgdmFyIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9UT1VDSDtcbiAgICBpZihVdGlscy5pblN0cihldi50eXBlLCAnbW91c2UnKSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfTU9VU0UsIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX01PVVNFO1xuICAgIH0gZWxzZSBpZihQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfUEVOLCBldikpIHtcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9QRU47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjogVXRpbHMuZ2V0Q2VudGVyKHRvdWNoZXMpLFxuICAgICAgdGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXG4gICAgICB0b3VjaGVzOiB0b3VjaGVzLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXYsXG5cbiAgICAgIC8qKlxuICAgICAgICogcHJldmVudCB0aGUgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICAqIG1vc3RseSB1c2VkIHRvIGRpc2FibGUgc2Nyb2xsaW5nIG9mIHRoZSBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gdGhpcy5zcmNFdmVudDtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0ICYmIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0b3AgYnViYmxpbmcgdGhlIGV2ZW50IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgKi9cbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBEZXRlY3Rpb24uc3RvcERldGVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBQb2ludGVyRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuUG9pbnRlckV2ZW50ID0gR2VzdHVyZURldGVjdG9yLlBvaW50ZXJFdmVudCA9IHtcbiAgLyoqXG4gICAqIGhvbGRzIGFsbCBwb2ludGVycywgYnkgYGlkZW50aWZpZXJgXG4gICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9pbnRlcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHBvaW50ZXJzIGFzIGFuIGFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGxpc3RcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xuICAgIHZhciB0b3VjaGxpc3QgPSBbXTtcbiAgICAvLyB3ZSBjYW4gdXNlIGZvckVhY2ggc2luY2UgcG9pbnRlckV2ZW50cyBvbmx5IGlzIGluIElFMTBcbiAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBwb2ludGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICovXG4gIHVwZGF0ZVBvaW50ZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfRU5EIHx8IChldmVudFR5cGUgIT0gRVZFTlRfRU5EICYmIHBvaW50ZXJFdmVudC5idXR0b25zICE9PSAxKSkge1xuICAgICAgZGVsZXRlIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJFdmVudC5pZGVudGlmaWVyID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMucG9pbnRlcnNbcG9pbnRlckV2ZW50LnBvaW50ZXJJZF0gPSBwb2ludGVyRXZlbnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjaGVjayBpZiBldiBtYXRjaGVzIHBvaW50ZXJ0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludGVyVHlwZSBtYXRjaGVzIGBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTmBcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2XG4gICAqL1xuICBtYXRjaFR5cGU6IGZ1bmN0aW9uIG1hdGNoVHlwZShwb2ludGVyVHlwZSwgZXYpIHtcbiAgICBpZighZXYucG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcbiAgICAgICAgdHlwZXMgPSB7fTtcblxuICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgUE9JTlRFUl9NT1VTRSkpO1xuICAgIHR5cGVzW1BPSU5URVJfVE9VQ0hdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgUE9JTlRFUl9UT1VDSCkpO1xuICAgIHR5cGVzW1BPSU5URVJfUEVOXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1BFTiB8fCBQT0lOVEVSX1BFTikpO1xuICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlc2V0IHRoZSBzdG9yZWQgcG9pbnRlcnNcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgRGV0ZWN0aW9uXG4gKiBAc3RhdGljXG4gKi9cbkRldGVjdGlvbiA9IEdlc3R1cmVEZXRlY3Rvci5kZXRlY3Rpb24gPSB7XG4gIC8vIGNvbnRhaW5zIGFsbCByZWdpc3RlcmVkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICBnZXN0dXJlczogW10sXG5cbiAgLy8gZGF0YSBvZiB0aGUgY3VycmVudCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gc2Vzc2lvblxuICBjdXJyZW50OiBudWxsLFxuXG4gIC8vIHRoZSBwcmV2aW91cyBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBzZXNzaW9uIGRhdGFcbiAgLy8gaXMgYSBmdWxsIGNsb25lIG9mIHRoZSBwcmV2aW91cyBnZXN0dXJlLmN1cnJlbnQgb2JqZWN0XG4gIHByZXZpb3VzOiBudWxsLFxuXG4gIC8vIHdoZW4gdGhpcyBiZWNvbWVzIHRydWUsIG5vIGdlc3R1cmVzIGFyZSBmaXJlZFxuICBzdG9wcGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogc3RhcnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfSBpbnN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICovXG4gIHN0YXJ0RGV0ZWN0OiBmdW5jdGlvbiBzdGFydERldGVjdChpbnN0LCBldmVudERhdGEpIHtcbiAgICAvLyBhbHJlYWR5IGJ1c3kgd2l0aCBhIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvLyBob2xkcyBjdXJyZW50IHNlc3Npb25cbiAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICBpbnN0OiBpbnN0LCAvLyByZWZlcmVuY2UgdG8gR2VzdHVyZURldGVjdG9ySW5zdGFuY2Ugd2UncmUgd29ya2luZyBmb3JcbiAgICAgIHN0YXJ0RXZlbnQ6IFV0aWxzLmV4dGVuZCh7fSwgZXZlbnREYXRhKSwgLy8gc3RhcnQgZXZlbnREYXRhIGZvciBkaXN0YW5jZXMsIHRpbWluZyBldGNcbiAgICAgIGxhc3RFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhXG4gICAgICBsYXN0Q2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGZ1dHVyZUNhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBsYXN0Q2FsY0RhdGE6IHt9LCAvLyBsYXN0IGxhc3RDYWxjRGF0YVxuICAgICAgbmFtZTogJycgLy8gY3VycmVudCBnZXN0dXJlIHdlJ3JlIGluL2RldGVjdGVkLCBjYW4gYmUgJ3RhcCcsICdob2xkJyBldGNcbiAgICB9O1xuXG4gICAgdGhpcy5kZXRlY3QoZXZlbnREYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZGV0ZWN0OiBmdW5jdGlvbiBkZXRlY3QoZXZlbnREYXRhKSB7XG4gICAgaWYoIXRoaXMuY3VycmVudCB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXG4gICAgZXZlbnREYXRhID0gdGhpcy5leHRlbmRFdmVudERhdGEoZXZlbnREYXRhKTtcblxuICAgIC8vIEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZSBhbmQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHZhciBpbnN0ID0gdGhpcy5jdXJyZW50Lmluc3QsXG4gICAgICAgIGluc3RPcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgLy8gY2FsbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYW5kbGVyc1xuICAgIFV0aWxzLmVhY2godGhpcy5nZXN0dXJlcywgZnVuY3Rpb24gdHJpZ2dlckdlc3R1cmUoZ2VzdHVyZSkge1xuICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcbiAgICAgIGlmKCF0aGlzLnN0b3BwZWQgJiYgaW5zdC5lbmFibGVkICYmIGluc3RPcHRpb25zW2dlc3R1cmUubmFtZV0pIHtcbiAgICAgICAgZ2VzdHVyZS5oYW5kbGVyLmNhbGwoZ2VzdHVyZSwgZXZlbnREYXRhLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ID0gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIGlmKGV2ZW50RGF0YS5ldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnREYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNsZWFyIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB2YXJzXG4gICAqIHRoaXMgaXMgY2FsbGVkIG9uIGVuZERldGVjdCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgd2hlbiBhIGZpbmFsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhcyBiZWVuIGRldGVjdGVkXG4gICAqIHRvIHN0b3Agb3RoZXIgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGZyb20gYmVpbmcgZmlyZWRcbiAgICovXG4gIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uIHN0b3BEZXRlY3QoKSB7XG4gICAgLy8gY2xvbmUgY3VycmVudCBkYXRhIHRvIHRoZSBzdG9yZSBhcyB0aGUgcHJldmlvdXMgZ2VzdHVyZVxuICAgIC8vIHVzZWQgZm9yIHRoZSBkb3VibGUgdGFwIGdlc3R1cmUsIHNpbmNlIHRoaXMgaXMgYW4gb3RoZXIgZ2VzdHVyZSBkZXRlY3Qgc2Vzc2lvblxuICAgIHRoaXMucHJldmlvdXMgPSBVdGlscy5leHRlbmQoe30sIHRoaXMuY3VycmVudCk7XG5cbiAgICAvLyByZXNldCB0aGUgY3VycmVudFxuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHZlbG9jaXR5LCBhbmdsZSBhbmQgZGlyZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAqL1xuICBnZXRDYWxjdWxhdGVkRGF0YTogZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgIHJlY2FsYyA9IGZhbHNlLFxuICAgICAgICBjYWxjRXYgPSBjdXIubGFzdENhbGNFdmVudCxcbiAgICAgICAgY2FsY0RhdGEgPSBjdXIubGFzdENhbGNEYXRhO1xuXG4gICAgaWYoY2FsY0V2ICYmIGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXAgPiBHZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMKSB7XG4gICAgICBjZW50ZXIgPSBjYWxjRXYuY2VudGVyO1xuICAgICAgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcDtcbiAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gY2FsY0V2LmNlbnRlci5jbGllbnRYO1xuICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBjYWxjRXYuY2VudGVyLmNsaWVudFk7XG4gICAgICByZWNhbGMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGlmKCFjdXIubGFzdENhbGNFdmVudCB8fCByZWNhbGMpIHtcbiAgICAgIGNhbGNEYXRhLnZlbG9jaXR5ID0gVXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBjYWxjRGF0YS5hbmdsZSA9IFV0aWxzLmdldEFuZ2xlKGNlbnRlciwgZXYuY2VudGVyKTtcbiAgICAgIGNhbGNEYXRhLmRpcmVjdGlvbiA9IFV0aWxzLmdldERpcmVjdGlvbihjZW50ZXIsIGV2LmNlbnRlcik7XG5cbiAgICAgIGN1ci5sYXN0Q2FsY0V2ZW50ID0gY3VyLmZ1dHVyZUNhbGNFdmVudCB8fCBldjtcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICB9XG5cbiAgICBldi52ZWxvY2l0eVggPSBjYWxjRGF0YS52ZWxvY2l0eS54O1xuICAgIGV2LnZlbG9jaXR5WSA9IGNhbGNEYXRhLnZlbG9jaXR5Lnk7XG4gICAgZXYuaW50ZXJpbUFuZ2xlID0gY2FsY0RhdGEuYW5nbGU7XG4gICAgZXYuaW50ZXJpbURpcmVjdGlvbiA9IGNhbGNEYXRhLmRpcmVjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAqL1xuICBleHRlbmRFdmVudERhdGE6IGZ1bmN0aW9uIGV4dGVuZEV2ZW50RGF0YShldikge1xuICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgIHN0YXJ0RXYgPSBjdXIuc3RhcnRFdmVudCxcbiAgICAgICAgbGFzdEV2ID0gY3VyLmxhc3RFdmVudCB8fCBzdGFydEV2O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzdGFydCB0b3VjaGxpc3QgdG8gY2FsY3VsYXRlIHRoZSBzY2FsZS9yb3RhdGlvblxuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgc3RhcnRFdi50b3VjaGVzID0gW107XG4gICAgICBVdGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHN0YXJ0RXYudG91Y2hlcy5wdXNoKHtcbiAgICAgICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gc3RhcnRFdi50aW1lU3RhbXAsXG4gICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WCxcbiAgICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBzdGFydEV2LmNlbnRlci5jbGllbnRZO1xuXG4gICAgdGhpcy5nZXRDYWxjdWxhdGVkRGF0YShldiwgbGFzdEV2LmNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICBVdGlscy5leHRlbmQoZXYsIHtcbiAgICAgIHN0YXJ0RXZlbnQ6IHN0YXJ0RXYsXG5cbiAgICAgIGRlbHRhVGltZTogZGVsdGFUaW1lLFxuICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICBkZWx0YVk6IGRlbHRhWSxcblxuICAgICAgZGlzdGFuY2U6IFV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgYW5nbGU6IFV0aWxzLmdldEFuZ2xlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgZGlyZWN0aW9uOiBVdGlscy5nZXREaXJlY3Rpb24oc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBzY2FsZTogVXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcbiAgICAgIHJvdGF0aW9uOiBVdGlscy5nZXRSb3RhdGlvbihzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIG5ldyBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZXN0dXJlIG9iamVjdCwgc2VlIGBnZXN0dXJlcy9gIGZvciBkb2N1bWVudGF0aW9uXG4gICAqIEByZXR1cm4ge0FycmF5fSBnZXN0dXJlc1xuICAgKi9cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcbiAgICAvLyBhZGQgYW4gZW5hYmxlIGdlc3R1cmUgb3B0aW9ucyBpZiB0aGVyZSBpcyBubyBnaXZlblxuICAgIHZhciBvcHRpb25zID0gZ2VzdHVyZS5kZWZhdWx0cyB8fCB7fTtcbiAgICBpZihvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgR2VzdHVyZURldGVjdG9yIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBvcHRpb25zXG4gICAgVXRpbHMuZXh0ZW5kKEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAvLyBzZXQgaXRzIGluZGV4XG4gICAgZ2VzdHVyZS5pbmRleCA9IGdlc3R1cmUuaW5kZXggfHwgMTAwMDtcblxuICAgIC8vIGFkZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB0byB0aGUgbGlzdFxuICAgIHRoaXMuZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcblxuICAgIC8vIHNvcnQgdGhlIGxpc3QgYnkgaW5kZXhcbiAgICB0aGlzLmdlc3R1cmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYoYS5pbmRleCA8IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqL1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqXG4gKiBAY2xhc3MgSW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzYFxuICogQHJldHVybiB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBzZXR1cCBHZXN0dXJlRGV0ZWN0b3JKUyB3aW5kb3cgZXZlbnRzIGFuZCByZWdpc3RlciBhbGwgZ2VzdHVyZXNcbiAgLy8gdGhpcyBhbHNvIHNldHMgdXAgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICBzZXR1cCgpO1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogb3B0aW9ucywgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRzXG4gICAqIG9wdGlvbnMgd2l0aCBhbiBfIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBVdGlscy5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgb3B0aW9uc1tVdGlscy50b0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgdGhpcy5vcHRpb25zID0gVXRpbHMuZXh0ZW5kKFV0aWxzLmV4dGVuZCh7fSwgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gYWRkIHNvbWUgY3NzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZyBpdHMgbmF0aXZlIGJlaGF2aW9yXG4gIGlmKHRoaXMub3B0aW9ucy5iZWhhdmlvcikge1xuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBldmVudCBzdGFydCBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBkZXRlY3Rpb25cbiAgICogQHByb3BlcnR5IGV2ZW50U3RhcnRIYW5kbGVyXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyID0gRXZlbnQub25Ub3VjaChlbGVtZW50LCBFVkVOVF9TVEFSVCwgZnVuY3Rpb24oZXYpIHtcbiAgICBpZihzZWxmLmVuYWJsZWQgJiYgZXYuZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICBEZXRlY3Rpb24uc3RhcnREZXRlY3Qoc2VsZiwgZXYpO1xuICAgIH0gZWxzZSBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGtlZXAgYSBsaXN0IG9mIHVzZXIgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbmVlZHMgdG8gYmUgcmVtb3ZlZCB3aGVuIGNhbGxpbmcgJ2Rpc3Bvc2UnXG4gICAqIEBwcm9wZXJ0eSBldmVudEhhbmRsZXJzXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xufTtcblxuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBtZXRob2Qgb25cbiAgICogQHNpZ25hdHVyZSBvbihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQWRkcyBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdlc3R1cmUuIEF2YWlsYWJsZSBnZXN0dXJlcyBhcmU6IGRyYWcsIGRyYWdsZWZ0LCBkcmFncmlnaHQsIGRyYWd1cCwgZHJhZ2Rvd24sIGhvbGQsIHJlbGVhc2UsIHN3aXBlLCBzd2lwZWxlZnQsIHN3aXBlcmlnaHQsIHN3aXBldXAsIHN3aXBlZG93biwgdGFwLCBkb3VibGV0YXAsIHRvdWNoLCB0cmFuc2Zvcm0sIHBpbmNoLCBwaW5jaGluLCBwaW5jaG91dCBhbmQgcm90YXRlLiBbL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+OBq+WvvuOBmeOCi+OCpOODmeODs+ODiOODj+ODs+ODieODqeOCkui/veWKoOOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OCuOOCp+OCueODgeODo+WQjeOBr+OAgWRyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBob2xkIHJlbGVhc2Ugc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24gdGFwIGRvdWJsZXRhcCB0b3VjaCB0cmFuc2Zvcm0gcGluY2ggcGluY2hpbiBwaW5jaG91dCByb3RhdGUg44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd5qSc55+l44GZ44KL44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgRXZlbnQub24oc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9mZlxuICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIEV2ZW50Lm9mZihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgIGlmKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICBzZWxmLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XG4gICAqIEBtZXRob2QgdHJpZ2dlclxuICAgKiBAc2lnbmF0dXJlIHRyaWdnZXIoZ2VzdHVyZSwgZXZlbnREYXRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV1cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChnZXN0dXJlLCBldmVudERhdGEpIHtcbiAgICAvLyBvcHRpb25hbFxuICAgIGlmKCFldmVudERhdGEpIHtcbiAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGdlc3R1cmUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XG5cbiAgICAvLyB0cmlnZ2VyIG9uIHRoZSB0YXJnZXQgaWYgaXQgaXMgaW4gdGhlIGluc3RhbmNlIGVsZW1lbnQsXG4gICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZihVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZW5hYmxlXG4gICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuZCBkZXN0cm95IGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5bL2VuXVxuICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHZhciBpLCBlaDtcblxuICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICBmb3IoaSA9IC0xOyAoZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgIFV0aWxzLm9mZih0aGlzLmVsZW1lbnQsIGVoLmdlc3R1cmUsIGVoLmhhbmRsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxuICAgIEV2ZW50Lm9mZih0aGlzLmVsZW1lbnQsIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSwgdGhpcy5ldmVudFN0YXJ0SGFuZGxlcik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cbiAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy5cbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xuICogICAgY29uc29sZS5sb2coZXYpO1xuICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICogIH0pO1xuICogYGBgYFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhcGxlZnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFncmlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFndXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZG93blxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZHJhZ0dlc3R1cmUoZXYsIGluc3QpIHtcbiAgICB2YXIgY3VyID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAvLyBtYXggdG91Y2hlc1xuICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcbiAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgaWYoZXYuZGlzdGFuY2UgPCBpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlICYmXG4gICAgICAgIGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRDZW50ZXIgPSBjdXIuc3RhcnRFdmVudC5jZW50ZXI7XG5cbiAgICAgIC8vIHdlIGFyZSBkcmFnZ2luZyFcbiAgICAgIGlmKGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgIGV2ID0gRGV0ZWN0aW9uLmV4dGVuZEV2ZW50RGF0YShldik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9jayBkcmFnIHRvIGF4aXM/XG4gICAgICBpZihjdXIubGFzdEV2ZW50LmRyYWdMb2NrVG9BeGlzIHx8XG4gICAgICAgICggaW5zdC5vcHRpb25zLmRyYWdMb2NrVG9BeGlzICYmXG4gICAgICAgICAgaW5zdC5vcHRpb25zLmRyYWdMb2NrTWluRGlzdGFuY2UgPD0gZXYuZGlzdGFuY2VcbiAgICAgICAgKSkge1xuICAgICAgICAgIGV2LmRyYWdMb2NrVG9BeGlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgZGlyZWN0aW9uIG9uIHRoZSBheGlzIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBzdGFydGVkIG9uXG4gICAgICAgIHZhciBsYXN0RGlyZWN0aW9uID0gY3VyLmxhc3RFdmVudC5kaXJlY3Rpb247XG4gICAgICAgIGlmKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgIGlmKFV0aWxzLmlzVmVydGljYWwobGFzdERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFYIDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRzXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG5cbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSBVdGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gYmxvY2sgdGhlIGJyb3dzZXIgZXZlbnRzXG4gICAgICAgIGlmKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcbiAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDUwLFxuICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgICAgICAgKiBiZSBjYWxjdWxhdGVkIGZyb20gd2hlcmUgdGhlIGRyYWcgd2FzIHRyaWdnZXJlZCwgbm90IGZyb20gd2hlcmUgdGhlIHRvdWNoIHN0YXJ0ZWQuXG4gICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWF4VG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrSG9yaXpvbnRhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja1ZlcnRpY2FsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZ0xvY2tUb0F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgICAgICAqIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrVG9BeGlzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogVGhpcyB3YXksIGxvY2tpbmcgb2NjdXJzIG9ubHkgd2hlbiB0aGUgZGlzdGFuY2UgaGFzIGJlY29tZSBsYXJnZSBlbm91Z2ggdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ2RyYWcnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXIgYSBzaW1wbGUgZ2VzdHVyZSBldmVudCwgc28geW91IGNhbiBkbyBhbnl0aGluZyBpbiB5b3VyIGhhbmRsZXIuXG4gICAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICAgKlxuICAgKiBAY2xhc3MgR2VzdHVyZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICBuYW1lOiAnZ2VzdHVyZScsXG4gICAgaW5kZXg6IDEzMzcsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gICAqXG4gICAqIEBjbGFzcyBIb2xkXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgaG9sZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoY3VycmVudCAmJiBjdXJyZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuaG9sZFRpbWVvdXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBpZihldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmVtZW50IGFsbG93ZWQgd2hpbGUgaG9sZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGhyZXNob2xkOiAyXG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICB9O1xuICB9KSgnaG9sZCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHJlbGVhc2VkIGZyb20gdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFJlbGVhc2VcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByZWxlYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gICAgbmFtZTogJ3JlbGVhc2UnLFxuICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICAgKiBmb3IgYmVzdCB1c2FnZSwgc2V0IGBwcmV2ZW50RGVmYXVsdGAgKG9uIHRoZSBkcmFnIGdlc3R1cmUpIHRvIGB0cnVlYFxuICAgKiBgYGBgXG4gICAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ2xlZnQgc3dpcGVsZWZ0XCIsIGZ1bmN0aW9uKGV2KSB7XG4gICAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAgICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgKiAgfSk7XG4gICAqIGBgYGBcbiAgICpcbiAgICogQGNsYXNzIFN3aXBlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlbGVmdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVyaWdodFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGV1cFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlN3aXBlID0ge1xuICAgIG5hbWU6ICdzd2lwZScsXG4gICAgaW5kZXg6IDQwLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1pblRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWluVG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNYXhUb3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1heFRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogaG9yaXpvbnRhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlYXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXG5cbiAgICAgIC8qKlxuICAgICAgICogdmVydGljYWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WVxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WTogMC42XG4gICAgfSxcblxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHN3aXBlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgaWYodG91Y2hlcyA8IG9wdGlvbnMuc3dpcGVNaW5Ub3VjaGVzIHx8XG4gICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKGV2LnZlbG9jaXR5WCA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVggfHxcbiAgICAgICAgICBldi52ZWxvY2l0eVkgPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlZKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBzd2lwZSBldmVudHNcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogU2luZ2xlIHRhcCBhbmQgYSBkb3VibGUgdGFwIG9uIGEgcGxhY2VcbiAgICpcbiAgICogQGNsYXNzIFRhcFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZG91YmxldGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGhhc01vdmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0YXBHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgcHJldiA9IERldGVjdGlvbi5wcmV2aW91cyxcbiAgICAgICAgICBzaW5jZVByZXYsXG4gICAgICAgICAgZGlkRG91YmxlVGFwO1xuXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBoYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBoYXNNb3ZlZCA9IGhhc01vdmVkIHx8IChldi5kaXN0YW5jZSA+IG9wdGlvbnMudGFwTWF4RGlzdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIGlmKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xuICAgICAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgICAgICBzaW5jZVByZXYgPSBwcmV2ICYmIHByZXYubGFzdEV2ZW50ICYmIGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgICAgICBpZihwcmV2ICYmIHByZXYubmFtZSA9PSBuYW1lICYmXG4gICAgICAgICAgICAoc2luY2VQcmV2ICYmIHNpbmNlUHJldiA8IG9wdGlvbnMuZG91YmxlVGFwSW50ZXJ2YWwpICYmXG4gICAgICAgICAgICBldi5kaXN0YW5jZSA8IG9wdGlvbnMuZG91YmxlVGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignZG91YmxldGFwJywgZXYpO1xuICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkbyBhIHNpbmdsZSB0YXBcbiAgICAgICAgICBpZighZGlkRG91YmxlVGFwIHx8IG9wdGlvbnMudGFwQWx3YXlzKSB7XG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKGN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVGFwID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMDAsXG4gICAgICBoYW5kbGVyOiB0YXBHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4VGltZTogMjUwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwQWx3YXlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwRGlzdGFuY2U6IDIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBJbnRlcnZhbFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbiAgICAgIH1cbiAgICB9O1xuICB9KSgndGFwJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgVG91Y2hcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0b3VjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgICBuYW1lOiAndG91Y2gnLFxuICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIHVzaW5nIHRoaXMsIGl0IGNhbiBiZSB2ZXJ5IGFubm95aW5nIGZvciB1c2VycyB0byBiZSBzdHVjayBvbiB0aGUgcGFnZVxuICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudE1vdXNlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnRNb3VzZTogZmFsc2VcbiAgICB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHRvdWNoR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICAgKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCB0aGVcbiAgICogYHByZXZlbnREZWZhdWx0YCBvcHRpb24uXG4gICAqXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1lbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNoaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNob3V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByb3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICBpZihldi50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NhbGVUaHJlc2hvbGQgPSBNYXRoLmFicygxIC0gZXYuc2NhbGUpO1xuICAgICAgICB2YXIgcm90YXRpb25UaHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlICYmXG4gICAgICAgICAgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgIGlmKHJvdGF0aW9uVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdyb3RhdGUnLCBldik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHBpbmNoIGV2ZW50XG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UcmFuc2Zvcm0gPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDQ1LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5TY2FsZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluUm90YXRpb25cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZXI6IHRyYW5zZm9ybUdlc3R1cmVcbiAgICB9O1xuICB9KSgndHJhbnNmb3JtJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVEZXRlY3RvcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZWxlY3RcbiAgICogQHNpZ25hdHVyZSBzZWxlY3QocGxhdGZvcm0pXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGxhdGZvcm0gTmFtZSBvZiB0aGUgcGxhdGZvcm0uXG4gICAqICAgW2VuXVBvc3NpYmxlIHZhbHVlcyBhcmU6IFwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiIG9yIFwid3BcIi5bL2VuXVxuICAgKiAgIFtqYV1cIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiwgXCJ3cFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldHMgdGhlIHBsYXRmb3JtIHVzZWQgdG8gcmVuZGVyIHRoZSBlbGVtZW50cy4gVXNlZnVsIGZvciB0ZXN0aW5nLlsvZW5dXG4gICAqICAgW2phXeimgee0oOOCkuaPj+eUu+OBmeOCi+OBn+OCgeOBq+WIqeeUqOOBmeOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOWQjeOCkuioreWumuOBl+OBvuOBmeOAguODhuOCueODiOOBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuICBzZWxlY3QocGxhdGZvcm0pIHtcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAgICogICBbamFdQ29yZG92YeWGheOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dlYlZpZXcoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1dlYlZpZXcoKSBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIGRvbSBjb250ZW50cyBsb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpb3MnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYW5kcm9pZCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnd3AnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL1dpbjMyTlR8V2luQ0UvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9zIGlzSVBob25lXG4gICAqIEBzaWduYXR1cmUgaXNJUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lLlsvZW5dXG4gICAqICAgW2phXWlQaG9uZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lQYWRcbiAgICogQHNpZ25hdHVyZSBpc0lQYWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBhZC5bL2VuXVxuICAgKiAgIFtqYV1pUGFk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBhZCgpIHtcbiAgICByZXR1cm4gL2lQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQb2QoKSB7XG4gICAgcmV0dXJuIC9pUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQmxhY2tCZXJyeVxuICAgKiBAc2lnbmF0dXJlIGlzQmxhY2tCZXJyeSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBCbGFja0JlcnJ5LlsvZW5dXG4gICAqICAgW2phXUJsYWNrQmVycnnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNCbGFja0JlcnJ5KCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYmxhY2tiZXJyeSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5fFJJTSBUYWJsZXQgT1N8QkIxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLlsvZW5dXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT3BlcmEoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdvcGVyYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxuICAgKiBAc2lnbmF0dXJlIGlzRmlyZWZveCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2ZpcmVmb3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTYWZhcmkoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdzYWZhcmknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0Nocm9tZVxuICAgKiBAc2lnbmF0dXJlIGlzQ2hyb21lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBDaHJvbWUuWy9lbl1cbiAgICogICBbamFdQ2hyb21l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQ2hyb21lKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnY2hyb21lJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICghIXdpbmRvdy5jaHJvbWUgJiYgISghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCkgJiYgIShuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDApKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lFXG4gICAqIEBzaWduYXR1cmUgaXNJRSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXIuWy9lbl1cbiAgICogICBbamFdSW50ZXJuZXQgRXhwbG9yZXLkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJRSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2llJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRWRnZVxuICAgKiBAc2lnbmF0dXJlIGlzRWRnZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRWRnZS5bL2VuXVxuICAgKiAgIFtqYV1FZGdl5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRWRnZSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2VkZ2UnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSU9TN2Fib3ZlXG4gICAqIEBzaWduYXR1cmUgaXNJT1M3YWJvdmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBpT1MgdmVyc2lvbiBpcyA3IG9yIGFib3ZlLlsvZW5dXG4gICAqICAgW2phXWlPUzfku6XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1M3YWJvdmUoKSB7XG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuICgvaU9TL2kudGVzdChkZXZpY2UucGxhdGZvcm0pICYmIChwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3KSk7XG4gICAgfSBlbHNlIGlmKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc3QgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vYmlsZU9TKCkge1xuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XG4gICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcbiAgICAgIHJldHVybiAnd3AnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRJT1NEZXZpY2UoKSB7XG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwb2QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnbmEnO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQbGF0Zm9ybSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmNvbnN0IHJlYWR5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgcmVhZHlNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhlbGVtZW50LCBmbikge1xuICBpZiAoIXF1ZXVlTWFwLmhhcyhlbGVtZW50KSkge1xuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XG4gIH1cbiAgcXVldWVNYXAuZ2V0KGVsZW1lbnQpLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lUXVldWUoZWxlbWVudCkge1xuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xuICBxdWV1ZU1hcC5kZWxldGUoZWxlbWVudCk7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50UmVhZHkoZWxlbWVudCwgZm4gPSAoKSA9PiB7fSkge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIGFsZXJ0IGRpYWxvZ3MuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZyBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgYTjgY/jgaTjgYvjga7nqK7poZ7jga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLkvZzmiJDjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0hlbGxvLCB3b3JsZCEnKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oJ0FyZSB5b3UgcmVhZHk/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYW5zd2VyKSB7XG4gKiAgICAgICBpZiAoYW5zd2VyID09PSAxKSB7XG4gKiAgICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ0xldFxcJ3MgZ28hJyk7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICApO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KCdIb3cgb2xkIGFyZSA/JylcbiAqICAgLnRoZW4oXG4gKiAgICAgZnVuY3Rpb24oYWdlKSB7XG4gKiAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdZb3UgYXJlICcgKyBhZ2UgKyAnIHllYXJzIG9sZC4nKTtcbiAqICAgICB9XG4gKiAgICk7XG4gKi9cbmNvbnN0IG5vdGlmaWNhdGlvbiA9IHt9O1xuXG5ub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nID0gb3B0aW9ucyA9PiB7XG4gIC8vIFByb21wdCBpbnB1dCBzdHJpbmdcbiAgbGV0IGlucHV0U3RyaW5nID0gJyc7XG4gIGlmIChvcHRpb25zLmlzUHJvbXB0KSB7XG4gICAgaW5wdXRTdHJpbmcgPSBgXG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3M9XCJ0ZXh0LWlucHV0IHRleHQtaW5wdXQtLXVuZGVyYmFyXCJcbiAgICAgICAgdHlwZT1cIiR7b3B0aW9ucy5pbnB1dFR5cGUgfHwgJ3RleHQnfVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiJHtvcHRpb25zLnBsYWNlaG9sZGVyIHx8ICcnfVwiXG4gICAgICAgIHZhbHVlPVwiJHtvcHRpb25zLmRlZmF1bHRWYWx1ZSB8fCAnJ31cIlxuICAgICAgICBzdHlsZT1cIndpZHRoOiAxMDAlOyBtYXJnaW4tdG9wOiAxMHB4O1wiXG4gICAgICAvPlxuICAgIGA7XG4gIH1cblxuICAvLyBCdXR0b25zIHN0cmluZ1xuICBsZXQgYnV0dG9ucyA9ICcnO1xuICBvcHRpb25zLmJ1dHRvbkxhYmVscy5mb3JFYWNoKChsYWJlbCwgaW5kZXgpID0+IHtcbiAgICBidXR0b25zICs9IGBcbiAgICAgIDxidXR0b24gY2xhc3M9XCJcbiAgICAgICAgYWxlcnQtZGlhbG9nLWJ1dHRvblxuICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXInIDogJyd9XG4gICAgICBcIj5cbiAgICAgICAgJHtsYWJlbH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIGA7XG4gIH0pO1xuXG4gIC8vIERpYWxvZyBFbGVtZW50XG4gIGxldCBlbCA9IHt9O1xuICBjb25zdCBfZGVzdHJveURpYWxvZyA9ICgpID0+IHtcbiAgICBpZiAoZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKSB7XG4gICAgICBlbC5kaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZWwpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBlbFtrZXldKTtcbiAgICBlbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBlbC5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gIGlubmVySFRNTChlbC5kaWFsb2csIGBcbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+XG4gICAgICAgICAgJHtvcHRpb25zLnRpdGxlIHx8ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTH1cbiAgICAgICAgICAke2lucHV0U3RyaW5nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlxuICAgICAgICAgIGFsZXJ0LWRpYWxvZy1mb290ZXJcbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiPlxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCk7XG4gIGNvbnRlbnRSZWFkeShlbC5kaWFsb2cpO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIFsnaWQnLCAnY2xhc3MnLCAnYW5pbWF0aW9uJ11cbiAgICAuZm9yRWFjaChhID0+IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoYSkgJiYgZWwuZGlhbG9nLnNldEF0dHJpYnV0ZShhLCBvcHRpb25zW2FdKSk7XG4gIGlmIChvcHRpb25zLm1vZGlmaWVyKSB7XG4gICAgdXRpbC5hZGRNb2RpZmllcihlbC5kaWFsb2csIG9wdGlvbnMubW9kaWZpZXIpO1xuICB9XG5cbiAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG5cbiAgLy8gUHJvbXB0IGV2ZW50c1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLnN1Ym1pdE9uRW50ZXIpIHtcbiAgICBlbC5pbnB1dCA9IGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yKCcudGV4dC1pbnB1dCcpO1xuICAgIGVsLmlucHV0Lm9ua2V5cHJlc3MgPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGVsLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQnV0dG9uIGV2ZW50c1xuICBlbC5mb290ZXIgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcbiAgdXRpbC5hcnJheUZyb20oZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbGVydC1kaWFsb2ctYnV0dG9uJykpLmZvckVhY2goKGJ1dHRvbkVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9uRWxlbWVudC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gb3B0aW9ucy5pc1Byb21wdCA/IGVsLmlucHV0LnZhbHVlIDogaW5kZXg7XG4gICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgIF9kZXN0cm95RGlhbG9nKCk7XG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGVsLmZvb3Rlci5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgfSk7XG5cbiAgLy8gQ2FuY2VsIGV2ZW50c1xuICBpZiAob3B0aW9ucy5jYW5jZWxhYmxlKSB7XG4gICAgZWwuZGlhbG9nLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCA9ICgpID0+IHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGVsLmRpYWxvZy5yZW1vdmUoKTtcbiAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gb3B0aW9ucy5pc1Byb21wdCA/IG51bGwgOiAtMTtcbiAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgIGRlZmVycmVkLnJlamVjdChyZXNvbHZlVmFsdWUpO1xuICAgIH07XG4gICAgZWwuZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFNob3cgZGlhbG9nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwuZGlhbG9nKTtcbiAgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZWwuZGlhbG9nLnNob3coKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuaW5wdXQgJiYgb3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLmF1dG9mb2N1cykge1xuICAgICAgICAgIGVsLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbmNvbnN0IF9ub3JtYWxpemVBcmd1bWVudHMgPSAobWVzc2FnZSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGVydCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbHMnKSB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbCcpKSB7XG4gICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBvcHRpb25zLmJ1dHRvbkxhYmVsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmJ1dHRvbkxhYmVscykpIHtcbiAgICAgIG9wdGlvbnMuYnV0dG9uTGFiZWxzID0gW29wdGlvbnMuYnV0dG9uTGFiZWxzIHx8ICcnXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICBjb21waWxlOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGNhbGxiYWNrOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGJ1dHRvbkxhYmVsczogWydPSyddLFxuICAgICAgcHJpbWFyeUJ1dHRvbkluZGV4OiAwLFxuICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgIH0sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhbGVydFxuICogQHNpZ25hdHVyZSBhbGVydChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UgaW4gSFRNTC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KLSFRNTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIGAwYC5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDAg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gRGVmYXVsdCBpcyBgZmFsc2VgLiBJZiB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSBjbGlja2luZyB0aGUgYmFja2dyb3VuZCBvciBwcmVzc2luZyB0aGUgQW5kcm9pZCBiYWNrIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBub25lYCBhbmQgYGZhZGVgLiBEZWZhdWx0IGlzIGBmYWRlYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xhc3NdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIGNsYXNzLlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuY2xhc3PjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIGBcIkFsZXJ0XCJgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7kuIrpg6jjgavooajnpLrjgZnjgovjgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIkFsZXJ0XCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGFuIGFsZXJ0IGRpYWxvZyB0byBzaG93IHRoZSB1c2VyIGEgbWVzc2FnZS5cbiAqXG4gKiAgICAgVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBzaW1wbGUgdGV4dCBvciBIVE1MLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244O844G444Oh44OD44K744O844K444KS6KaL44Gb44KL44Gf44KB44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg6KGo56S644GZ44KL44Oh44OD44K744O844K444Gv44CB44OG44Kt44K544OI44GL44KC44GX44GP44GvSFRNTOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmFsZXJ0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIHRpdGxlOiAnQWxlcnQnXG4gIH0pO1xuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbmZpcm1cbiAqIEBzaWduYXR1cmUgY29uZmlybShtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHRvIGFzayB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICogICAgIFRoZSBkZWZhdWx0IGJ1dHRvbiBsYWJlbHMgYXJlIGBcIkNhbmNlbFwiYCBhbmQgYFwiT0tcImAgYnV0IHRoZXkgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0obWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244Gr56K66KqN44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmNvbmZpcm0gPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgIHByaW1hcnlCdXR0b25JbmRleDogMSxcbiAgICB0aXRsZTogJ0NvbmZpcm0nXG4gIH0pO1xuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByb21wdFxuICogQHNpZ25hdHVyZSBwcm9tcHQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5wdXQgdmFsdWUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMGAuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5wdXRUeXBlXVxuICogICBbZW5dVHlwZSBvZiB0aGUgaW5wdXQgZWxlbWVudCAoYHBhc3N3b3JkYCwgYGRhdGVgLi4uKS4gRGVmYXVsdCBpcyBgdGV4dGAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1Ym1pdE9uRW50ZXJdXG4gKiAgIFtlbl1TdWJtaXQgYXV0b21hdGljYWxseSB3aGVuIGVudGVyIGlzIHByZXNzZWQuIERlZmF1bHQgaXMgYHRydWVgLlsvZW5dXG4gKiAgIFtqYV1FbnRlcuOBjOaKvOOBleOCjOOBn+mam+OBq+OBneOBrmZvcm3jgpJzdWJtaXTjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB3aXRoIGEgcHJvbXB0IHRvIGFzayB0aGUgdXNlciBhIHF1ZXN0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5wcm9tcHQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgdGl0bGU6ICdBbGVydCcsXG4gICAgaXNQcm9tcHQ6IHRydWUsXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgIHN1Ym1pdE9uRW50ZXI6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgY29uc3QgcmUgPSAvXlxcJHsoLio/KX0kLyxcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCByZXR1cm4gYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmludGVybmFsLmNvbmZpZyA9IHtcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiB7XG4gIGh0bWwgPSAoJycgKyBodG1sKS50cmltKCk7XG5cbiAgaWYgKCFodG1sLm1hdGNoKC9ePG9ucy1wYWdlLykpIHtcbiAgICBodG1sID0gJzxvbnMtcGFnZSBfbXV0ZWQ+JyArIGh0bWwgKyAnPC9vbnMtcGFnZT4nO1xuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwgPSBhY3Rpb24gPT4ge1xuICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKCkpIHtcbiAgICAgIGFjdGlvbigpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIG9uUmVhZHkoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvblJlYWR5KCk7XG4gIH1cbn07XG5cbmludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIgPSAoKSA9PiBpbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCgpICYmIHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCk7XG5cbmludGVybmFsLnRlbXBsYXRlU3RvcmUgPSB7XG4gIF9zdG9yYWdlOiB7fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmcvbnVsbH0gdGVtcGxhdGVcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXQoa2V5LCB0ZW1wbGF0ZSkge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59O1xuXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignX3RlbXBsYXRlbG9hZGVkJywgZnVuY3Rpb24oZSkge1xuICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChlLnRlbXBsYXRlSWQsIGUudGVtcGxhdGUpO1xuICB9XG59LCBmYWxzZSk7XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiXScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufSwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGUgPSBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLmdldChwYWdlKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgcGFnZSwgdHJ1ZSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFnZSBpcyBub3QgZm91bmQ6ICR7cGFnZX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgY29uc3QgcGFnZXMgPSBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5ldmFsdWF0ZShwYWdlKTtcblxuICBjb25zdCBnZXRQYWdlID0gKHBhZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAocGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAudGhlbihodG1sID0+IGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpKTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBhbmltYXRpb246ICcgKyB0aGlzLl9hbmltYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3QvbnVsbH1cbiAgICovXG4gIHN0YXRpYyBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGpzb25TdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0QW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl0gVGhlIGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXSBUaGUgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRBbmltYXRvciBUaGUgZGVmYXVsdCBhbmltYXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFuaW1hdG9yIGluc3RhbmNlXG4gICAqL1xuICBuZXdBbmltYXRvcihvcHRpb25zID0ge30sIGRlZmF1bHRBbmltYXRvcikge1xuXG4gICAgbGV0IGFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGxldCBBbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xuICAgIH1cblxuICAgIGlmICghQW5pbWF0b3IgJiYgZGVmYXVsdEFuaW1hdG9yKSB7XG4gICAgICBhbmltYXRvciA9IGRlZmF1bHRBbmltYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbWF0b3IgPSBBbmltYXRvciB8fCB0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8ge2R1cmF0aW9uOiAwLCBkZWxheTogMH0gOiB7fVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgYW5pbWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGFuaW1hdG9yIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFuaW1hdG9yXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mICcgKyB0aGlzLl9iYXNlQ2xhc3NOYW1lICsgJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RpZmllclV0aWwge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICovXG4gIHN0YXRpYyBkaWZmKGxhc3QsIGN1cnJlbnQpIHtcbiAgICBsYXN0ID0gbWFrZURpY3QoKCcnICsgbGFzdCkudHJpbSgpKTtcbiAgICBjdXJyZW50ID0gbWFrZURpY3QoKCcnICsgY3VycmVudCkudHJpbSgpKTtcblxuICAgIGNvbnN0IHJlbW92ZWQgPSBPYmplY3Qua2V5cyhsYXN0KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghY3VycmVudFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBhZGRlZCA9IE9iamVjdC5rZXlzKGN1cnJlbnQpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xuICAgICAgaWYgKCFsYXN0W3Rva2VuXSkge1xuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7YWRkZWQsIHJlbW92ZWR9O1xuXG4gICAgZnVuY3Rpb24gbWFrZURpY3QobW9kaWZpZXIpIHtcbiAgICAgIGNvbnN0IGRpY3QgPSB7fTtcbiAgICAgIE1vZGlmaWVyVXRpbC5zcGxpdChtb2RpZmllcikuZm9yRWFjaCh0b2tlbiA9PiBkaWN0W3Rva2VuXSA9IHRva2VuKTtcbiAgICAgIHJldHVybiBkaWN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlmZlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NMaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIGNsYXNzTGlzdCwgdGVtcGxhdGUpIHtcbiAgICBkaWZmLmFkZGVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBjbGFzc0xpc3QuYWRkKGtsYXNzKSk7XG5cbiAgICBkaWZmLnJlbW92ZWRcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcbiAgICAgIC5mb3JFYWNoKGtsYXNzID0+IGNsYXNzTGlzdC5yZW1vdmUoa2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlmZlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0VsZW1lbnQoZGlmZiwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBpbiBzY2hlbWUpIHtcbiAgICAgIGlmIChzY2hlbWUuaGFzT3duUHJvcGVydHkoc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzID0gIXNlbGVjdG9yIHx8IHV0aWwubWF0Y2goZWxlbWVudCwgc2VsZWN0b3IpID8gW2VsZW1lbnRdIDogZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCB0YXJnZXRFbGVtZW50c1tpXS5jbGFzc0xpc3QsIHNjaGVtZVtzZWxlY3Rvcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIG9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIHJldHVybiBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9FbGVtZW50KE1vZGlmaWVyVXRpbC5kaWZmKGxhc3QsIGN1cnJlbnQpLCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGluaXRNb2RpZmllcihlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudCh7XG4gICAgICByZW1vdmVkOiBbXSxcbiAgICAgIGFkZGVkOiBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpXG4gICAgfSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBzcGxpdChtb2RpZmllcikge1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvICsvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4gIT09ICcnKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcblxuICBjb25zdHJ1Y3Rvcih1c2VyRGVsZWdhdGUsIHRlbXBsYXRlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWxlZ2F0ZSAhPT0gJ29iamVjdCcgfHwgdXNlckRlbGVnYXRlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJkZWxlZ2F0ZVwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdXNlckRlbGVnYXRlO1xuXG4gICAgaWYgKCEodGVtcGxhdGVFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkgJiYgdGVtcGxhdGVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJ0ZW1wbGF0ZUVsZW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50IG9yIG51bGwuJyk7XG4gICAgfVxuICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRlbXBsYXRlRWxlbWVudDtcbiAgfVxuXG4gIGdldCBpdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuaXRlbUhlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzUmVuZGVyRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5fcmVuZGVyIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIF9yZW5kZXIoaXRlbXMsIGhlaWdodCkge1xuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5fcmVuZGVyKGl0ZW1zLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIEEgZnVuY3Rpb24gdGhhdCB0YWtlIGl0ZW0gb2JqZWN0IGFzIHBhcmFtZXRlci5cbiAgICovXG4gIGxvYWRJdGVtRWxlbWVudChpbmRleCwgcGFyZW50LCBkb25lKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgcGFyZW50LCBlbGVtZW50ID0+IGRvbmUoe2VsZW1lbnR9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnQoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCk7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZUl0ZW1Db250ZW50KCkgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIGRvbmUoe2VsZW1lbnR9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY291bnRJdGVtcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VudEl0ZW1zKCkgbXVzdCByZXR1cm4gYSBudW1iZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBpdGVtLmVsZW1lbnRcbiAgICovXG4gIHVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS51cGRhdGVJdGVtQ29udGVudChpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoaW5kZXgpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaW5kZXgpO1xuXG4gICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NhbGN1bGF0ZUl0ZW1IZWlnaHQoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICovXG4gIGRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlIGNvcmUgZnVuY3Rpb25zIGZvciBvbnMtbGF6eS1yZXBlYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0UHJvdmlkZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHdyYXBwZXJFbGVtZW50XG4gICAqIEBwYXJhbSB7TGF6eVJlcGVhdERlbGVnYXRlfSBkZWxlZ2F0ZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgaWYgKCEoZGVsZWdhdGUgaW5zdGFuY2VvZiBMYXp5UmVwZWF0RGVsZWdhdGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcignXCJkZWxlZ2F0ZVwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIExhenlSZXBlYXREZWxlZ2F0ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IHdyYXBwZXJFbGVtZW50O1xuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG5cbiAgICBpZiAod3JhcHBlckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QnKSB7XG4gICAgICB3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYXp5LWxpc3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudCA9IHRoaXMuX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbnMtbGF6eS1yZXBlYXQgbXVzdCBiZSBhIGRlc2NlbmRhbnQgb2YgYW4gPG9ucy1wYWdlPiBvciBhbiBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX3RvcFBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSB7fTtcblxuICAgIGlmICghdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCAmJiAhdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCgwKSkge1xuICAgICAgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBfZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLnBhZ2VfX2NvbnRlbnQnKTtcblxuICAgIGlmIChwYWdlQ29udGVudCkge1xuICAgICAgcmV0dXJuIHBhZ2VDb250ZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICdvbnMtcGFnZScpO1xuICAgIGlmIChwYWdlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQocGFnZSwgJy5jb250ZW50Jyk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9jaGVja0l0ZW1IZWlnaHQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoMCwgdGhpcy5fd3JhcHBlckVsZW1lbnQsIGl0ZW0gPT4ge1xuICAgICAgaWYgKCF0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPiAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSB0byBtZWFzdXJlIG9mZnNldCBoZWlnaHRcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgYW5ndWxhcjIgZGlyZWN0aXZlXG4gICAgICBjb25zdCBsYXN0VmlzaWJpbGl0eSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnZpc2liaWxpdHk7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPT0gMCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlOiB0aGlzLl9pdGVtSGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IGxhc3RWaXNpYmlsaXR5O1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzdGF0aWNJdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0IHx8IHRoaXMuX2l0ZW1IZWlnaHQ7XG4gIH1cblxuICBfY291bnRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY291bnRJdGVtcygpO1xuICB9XG5cbiAgX2dldEl0ZW1IZWlnaHQoaSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRpY0l0ZW1IZWlnaHQgfHwgdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICB9XG5cbiAgX3JlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNJblZpZXcoKTtcblxuICAgIGlmICh0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbiAmJiB0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbigpKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKGl0ZW1zLCB0aGlzLl9saXN0SGVpZ2h0KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGtlZXAgPSB7fTtcblxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGl0ZW0pO1xuICAgICAga2VlcFtpdGVtLmluZGV4XSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiBrZWVwW2tleV0gfHwgdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX2xpc3RIZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtLmluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtLnRvcFxuICAgKi9cbiAgX3JlbmRlckVsZW1lbnQoe2luZGV4LCB0b3B9KSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS51cGRhdGVJdGVtKGluZGV4LCBpdGVtKTsgLy8gdXBkYXRlIGlmIGl0IGV4aXN0c1xuICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KGluZGV4LCB0aGlzLl93cmFwcGVyRWxlbWVudCwgaXRlbSA9PiB7XG4gICAgICB1dGlsLmV4dGVuZChpdGVtLmVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICBfcmVtb3ZlRWxlbWVudChpbmRleCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcblxuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgIGlmIChpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gIH1cblxuICBfcmVtb3ZlQWxsRWxlbWVudHMoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4gdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSB0aGlzLl9pdGVtQ291bnQgLSAxO1xuXG4gICAgaWYgKHRoaXMuc3RhdGljSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KC1jdXJyZW50IC8gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciBpbmRleCBhdCB0b3Agb2Ygc2NyZWVuIHNvIHdlIGNhbiBzcGVlZCB1cCByZW5kZXJpbmcuXG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnQgKyB0aGlzLl90b3BQb3NpdGlvbnNbbWlkZGxlXTtcblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwICYmIHZhbHVlICsgdGhpcy5fZ2V0SXRlbUhlaWdodChtaWRkbGUpID4gMCkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPj0gMCkge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucygpIHtcbiAgICBjb25zdCBsID0gTWF0aC5taW4odGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCwgdGhpcy5faXRlbUNvdW50KTtcbiAgICB0aGlzLl90b3BQb3NpdGlvbnNbMF0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAxLCBsOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaSAtIDFdICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbXNJblZpZXcoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIGNvbnN0IGxpbWl0ID0gNCAqIHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcblxuICAgIGlmIChjb3VudCAhPT0gdGhpcy5faXRlbUNvdW50KXtcbiAgICAgIHRoaXMuX2l0ZW1Db3VudCA9IGNvdW50O1xuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoKTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IE1hdGgubWF4KDAsIHRoaXMuX2NhbGN1bGF0ZVN0YXJ0SW5kZXgob2Zmc2V0KSAtIDMwKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgaXRlbXMucHVzaCh7dG9wLCBpbmRleDogaX0pO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2xpc3RIZWlnaHQgPSB0b3A7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBfZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBfZG91YmxlRmlyZU9uVG91Y2hlbmQoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fZGVib3VuY2UodGhpcy5fcmVuZGVyLmJpbmQodGhpcyksIDEwMCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdXRpbC5iaW5kTGlzdGVuZXJzKHRoaXMsIFsnX29uQ2hhbmdlJywgJ19kb3VibGVGaXJlT25Ub3VjaGVuZCddKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fZGVib3VuY2UodGhpcy5fYm91bmRPbkNoYW5nZSwgMzApO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kLCB0cnVlKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IHtMYXp5UmVwZWF0UHJvdmlkZXIsIExhenlSZXBlYXREZWxlZ2F0ZX0gZnJvbSAnLi9sYXp5LXJlcGVhdCc7XG5cbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbmludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcblxuICAvKipcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICogQGNhdGVnb3J5IHV0aWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBjb25zdCBvYmogPSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzLlsvZW5dXG4gICAgICogICBbamFd44OH44OQ44Kk44K544Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd54++5Zyo44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAc2lnbmF0dXJlIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgZPjga7jgqTjg5njg7Pjg4jjgYznmbrngavjgZXjgozjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvbmNlXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCdzIG9ubHkgdHJpZ2dlcmVkIG9uY2UuWy9lbl1cbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHNpZ25hdHVyZSBvZmYoZXZlbnROYW1lLCBbbGlzdGVuZXJdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgdHlwZSB3aWxsIGJlIHJlbW92ZWQuWy9lbl1cbiAgICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAguOCguOBl+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBquOBi+OBo+OBn+WgtOWQiOOBq+OBr+OAgeOBneOBruOCpOODmeODs+ODiOOBq+e0kOOBpeOBj+WFqOOBpuOBruOCpOODmeODs+ODiOODquOCueODiuODvOOBjOWJiumZpOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd5YmK6Zmk44GZ44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8vIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0byBkZXRlY3QgaWYgd2hldGhlciBjdXJyZW50IHNjcmVlbiBpcyBwb3J0cmFpdCBvciBub3RcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAc2lnbmF0dXJlIGlzUG9ydHJhaXQoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0sXG5cbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHRoaXMuX2lzUG9ydHJhaXQoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIG9mIEFuZHJvaWQgaW5jb25zaXN0ZW5jeS5cbiAgICAgIGxldCBuSXRlciA9IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbkl0ZXIrKztcblxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcbiAgICAgICAgICAgKCFpc1BvcnRyYWl0ICYmIHcgPj0gaCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfVxuICB9O1xuXG4gIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlKCkuX2luaXQoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG5jb25zdCBvblNob3cgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSB0cnVlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcbn07XG5cbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2hpZGUnKTtcbn07XG5cbmNvbnN0IGJpbmRFdmVudHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbm1vc2UvY29yZG92YS1rZXlib2FyZC9ibG9iLzk1ZjNkYTNhMzhkOGY4ZTFmYTQxZmJmNDAxNDUzNTJjMTM1MzVhMDAvUkVBRE1FLm1kXG4gICAgS2V5Ym9hcmQub25zaG93ID0gb25TaG93O1xuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG5vUGx1Z2luRXJyb3IgPSAoKSA9PiB7XG4gIGNvbnNvbGUud2Fybignb25zLWtleWJvYXJkOiBDb3Jkb3ZhIEtleWJvYXJkIHBsdWdpbiBpcyBub3QgcHJlc2VudC4nKTtcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICBpZiAoIWJpbmRFdmVudHMoKSkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWFjdGl2ZV0nKSB8fFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgIH1cblxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29mdHdhcmVLZXlib2FyZDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHV0aWwuX29uRE9NQ29udGVudExvYWRlZCgpLCBmYWxzZSk7XG5cbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xuICBfc3RvcmU6IHt9LFxuXG4gIF9nZW5JZDogKCgpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpID0+IGkrKztcbiAgfSkoKSxcblxuICBzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgfVxufTtcblxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLnJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlIGEgJ2JhY2tidXR0b24nIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYmFja2J1dHRvbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2NhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRMaXN0ZW5lcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0sXG5cbiAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCkgPT09IHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpO1xuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChwYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2NhcHR1cmVUcmVlKCkge1xuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJlZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZihlbGVtZW50LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMoY2hpbGRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMocmVzdWx0LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlPZih0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGFyZ2V0W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSkge1xuICAgIHJldHVybiBmaW5kKHRyZWUpO1xuXG4gICAgZnVuY3Rpb24gZmluZChub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaW5kKG5vZGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUuZWxlbWVudDtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZWZ0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxlZnQsICcnKS56SW5kZXgsIDEwKTtcbiAgICAgICAgY29uc3QgcmlnaHRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUocmlnaHQsICcnKS56SW5kZXgsIDEwKTtcblxuICAgICAgICBpZiAoIWlzTmFOKGxlZnRaKSAmJiAhaXNOYU4ocmlnaHRaKSkge1xuICAgICAgICAgIHJldHVybiBsZWZ0WiA+IHJpZ2h0WiA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwdHVyaW5nIGJhY2tidXR0b24taGFuZGxlciBpcyBmYWlsdXJlLicpO1xuICAgICAgfSwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcigpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxubGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAnY2hldnJvbic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgaWYgKCEvb25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtcHJvZ3Jlc3MvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgIS9tYXRlcmlhbC8udGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkpIHtcblxuICAgIGNvbnN0IG9sZE1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG5cbiAgICBjb25zdCBuZXdNb2RpZmllciA9IG9sZE1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IG1vZGlmaWVyc01hcC5oYXNPd25Qcm9wZXJ0eShlKSA/IG1vZGlmaWVyc01hcFtlXSA6IGUpO1xuICAgIG5ld01vZGlmaWVyLnVuc2hpZnQoJ21hdGVyaWFsJyk7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllci5qb2luKCcgJykudHJpbSgpKTtcbiAgfVxuXG4gIC8vIEVmZmVjdHNcbiAgaWYgKC9vbnMtYnV0dG9ufG9ucy1saXN0LWl0ZW18b25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtdGFiJC8udGVzdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpXG4gICAgJiYgIXV0aWwuZmluZENoaWxkKGVsZW1lbnQsICdvbnMtcmlwcGxlJykpIHtcblxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgfVxuICB9XG59O1xuXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XG5cbiAvLyBNb2RpZmllcnNcbiBpZiAoL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xuICAgdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKTtcblxuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcbiAgICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbGFyZ2UnKSkgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgfVxuXG4gICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgfVxuIH1cblxuIC8vIEVmZmVjdHNcbiBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICB9XG5cbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiB9XG59O1xuXG5jb25zdCB1bmxvY2tlZCA9IHtcbiAgYW5kcm9pZDogdHJ1ZVxufTtcblxuY29uc3QgcHJlcGFyZUF1dG9TdHlsZSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHBsYXRmb3Jtc1ttb2JpbGVPU10oZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzRW5hYmxlZDogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCxcbiAgZW5hYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZSxcbiAgZGlzYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IGZhbHNlLFxuICBwcmVwYXJlOiBwcmVwYXJlQXV0b1N0eWxlXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3QgZ2VuZXJhdGVJZCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkrKztcbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogRG9vciBsb2NraW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2ddXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvb3JMb2NrIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9sb2NrTGlzdCA9IFtdO1xuICAgIHRoaXMuX3dhaXRMaXN0ID0gW107XG4gICAgdGhpcy5fbG9nID0gb3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxvY2suXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBDYWxsYmFjayBmb3IgdW5sb2NraW5nLlxuICAgKi9cbiAgbG9jaygpIHtcbiAgICBjb25zdCB1bmxvY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl91bmxvY2sodW5sb2NrKTtcbiAgICB9O1xuICAgIHVubG9jay5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLl9sb2NrTGlzdC5wdXNoKHVubG9jayk7XG4gICAgdGhpcy5fbG9nKCdsb2NrOiAnICsgKHVubG9jay5pZCkpO1xuXG4gICAgcmV0dXJuIHVubG9jaztcbiAgfVxuXG4gIF91bmxvY2soZm4pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2tMaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCBpbiB0aGUgbG9jayBsaXN0LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvY2tMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5fbG9nKCd1bmxvY2s6ICcgKyBmbi5pZCk7XG5cbiAgICB0aGlzLl90cnlUb0ZyZWVXYWl0TGlzdCgpO1xuICB9XG5cbiAgX3RyeVRvRnJlZVdhaXRMaXN0KCkge1xuICAgIHdoaWxlICghdGhpcy5pc0xvY2tlZCgpICYmIHRoaXMuX3dhaXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnNoaWZ0KCkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3Igd2FpdGluZyB1bmxvY2tlZCBkb29yLlxuICAgKlxuICAgKiBAcGFyYW1zIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgb24gdW5sb2NraW5nIHRoZSBkb29yIGNvbXBsZXRlbHkuXG4gICAqL1xuICB3YWl0VW5sb2NrKGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhbGxiYWNrIHBhcmFtIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICB0aGlzLl93YWl0TGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrTGlzdC5sZW5ndGggPiAwO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcblxuLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgZ2xvYmFsIFBhZ2VMb2FkZXIuXG5mdW5jdGlvbiBsb2FkUGFnZSh7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGh0bWwudHJpbSgpKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgZG9uZShwYWdlRWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bmxvYWRQYWdlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuX2Rlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGVsZW1lbnQuX2Rlc3Ryb3koKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdlTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIsIHVubG9hZGVyKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBsb2FkZXIgOiBsb2FkUGFnZTtcbiAgICB0aGlzLl91bmxvYWRlciA9IHVubG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB1bmxvYWRlciA6IHVubG9hZFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGludGVybmFsIGxvYWRlciBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIHNldCBpbnRlcm5hbExvYWRlcihmbikge1xuICAgIGlmICghKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVyID0gZm47XG4gIH1cblxuICBnZXQgaW50ZXJuYWxMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucy5wYWdlXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5wYXJlbnQgQSBsb2NhdGlvbiB0byBsb2FkIHBhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJhbXNdIEV4dHJhIHBhcmFtZXRlcnMgZm9yIG9ucy1wYWdlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIFRha2UgYW4gb2JqZWN0IHRoYXQgaGFzIFwiZWxlbWVudFwiIHByb3BlcnR5IGFuZCBcInVubG9hZFwiIGZ1bmN0aW9uLlxuICAgKi9cbiAgbG9hZCh7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICB0aGlzLl9sb2FkZXIoe3BhZ2UsIHBhcmVudCwgcGFyYW1zfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncGFnZUVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuXG4gICAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHVubG9hZChwYWdlRWxlbWVudCkge1xuICAgIGlmICghKHBhZ2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdW5sb2FkZXIocGFnZUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKCk7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW50UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKFxuICBmdW5jdGlvbih7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KHBhZ2UudHJpbSgpKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICBkb25lKGVsZW1lbnQpO1xuICB9LFxuICB1bmxvYWRQYWdlXG4pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQocHJvcGVydGllcyA9IHt9KSB7XG4gICAgY29uc3QgZXh0ZW5kZWRBbmltYXRvciA9IHRoaXM7XG4gICAgY29uc3QgbmV3QW5pbWF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGV4dGVuZGVkQW5pbWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBuZXdBbmltYXRvci5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3QW5pbWF0b3I7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi9hbmltaXQnXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuL29yaWVudGF0aW9uJztcbmltcG9ydCBzb2Z0d2FyZUtleWJvYXJkIGZyb20gJy4vc29mdHdhcmUta2V5Ym9hcmQnO1xuaW1wb3J0IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlciBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7ZGVmYXVsdFBhZ2VMb2FkZXIsIFBhZ2VMb2FkZXJ9IGZyb20gJy4vcGFnZS1sb2FkZXInO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuL2Jhc2UtYW5pbWF0b3InO1xuXG4vKipcbiAqIEBvYmplY3Qgb25zXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV1PbnNlbiBVSeOBp+WIqeeUqOOBp+OBjeOCi+OCsOODreODvOODkOODq+OBquOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiAgIFtlbl1BIGdsb2JhbCBvYmplY3QgdGhhdCdzIHVzZWQgaW4gT25zZW4gVUkuIFsvZW5dXG4gKi9cbmNvbnN0IG9ucyA9IHt9O1xuXG5vbnMuX3V0aWwgPSB1dGlsO1xub25zLmFuaW1pdCA9IGFuaW1pdDtcbm9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcbm9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3I7XG5vbnMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbm9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcbm9ucy5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xub25zLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5vbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xub25zLl9hbmltYXRpb25PcHRpb25zUGFyc2VyID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlcjtcbm9ucy5fYXV0b1N0eWxlID0gYXV0b1N0eWxlO1xub25zLl9Eb29yTG9jayA9IERvb3JMb2NrO1xub25zLl9jb250ZW50UmVhZHkgPSBjb250ZW50UmVhZHk7XG5vbnMuZGVmYXVsdFBhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbm9ucy5QYWdlTG9hZGVyID0gUGFnZUxvYWRlcjtcbm9ucy5fQmFzZUFuaW1hdG9yID0gQmFzZUFuaW1hdG9yO1xuXG5vbnMuX3JlYWR5TG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG5vbnMucGxhdGZvcm0uc2VsZWN0KCh3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9wbGF0Zm9ybT0oW1xcdy1dKykvKSB8fCBbXSlbMV0pO1xuXG53YWl0RGV2aWNlUmVhZHkoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzUmVhZHlcbiAqIEBzaWduYXR1cmUgaXNSZWFkeSgpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV3liJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXU9uc2VuIFVJ44GM44GZ44Gn44Gr5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmlzUmVhZHkgPSAoKSA9PiB7XG4gIHJldHVybiAhb25zLl9yZWFkeUxvY2suaXNMb2NrZWQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBpc1dlYlZpZXdcbiAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAqICAgW2phXUNvcmRvdmHjgaflrp/ooYzjgZXjgozjgabjgYTjgovloLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIENvcmRvdmEuWy9lbl1cbiAqICAgW2phXUNvcmRvdmHjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNXZWJWaWV3ID0gb25zLnBsYXRmb3JtLmlzV2ViVmlldztcblxuLyoqXG4gKiBAbWV0aG9kIHJlYWR5XG4gKiBAc2lnbmF0dXJlIHJlYWR5KGNhbGxiYWNrKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV3jgqLjg5fjg6rjga7liJ3mnJ/ljJbjgavliKnnlKjjgZnjgovjg6Hjgr3jg4Pjg4njgafjgZnjgILmuKHjgZXjgozjgZ/plqLmlbDjga/jgIFPbnNlbiBVSeOBruWIneacn+WMluOBjOe1guS6huOBl+OBpuOBhOOCi+aZgueCueOBp+W/heOBmuWRvOOBsOOCjOOBvuOBmeOAglsvamFdXG4gKiAgIFtlbl1NZXRob2QgdXNlZCB0byB3YWl0IGZvciBhcHAgaW5pdGlhbGl6YXRpb24uIFRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBleGVjdXRlZCB1bnRpbCBPbnNlbiBVSSBoYXMgYmVlbiBjb21wbGV0ZWx5IGluaXRpYWxpemVkLlsvZW5dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBPbnNlbiBVSSBoYXMgYmVlbiBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzliJ3mnJ/ljJbjgYzlrozkuobjgZfjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMucmVhZHkgPSBjYWxsYmFjayA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICBvbnMuX3JlYWR5TG9jay53YWl0VW5sb2NrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXJcbiAqIEBzaWduYXR1cmUgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lcihsaXN0ZW5lcilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHdoZW4gZGV2aWNlIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQuWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBjOaKvOOBleOCjOOBn+aZguOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNldCBkZWZhdWx0IGhhbmRsZXIgZm9yIGRldmljZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Gf44KB44Gu44OH44OV44Kp44Or44OI44Gu44OP44Oz44OJ44Op44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLnNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5zZXRMaXN0ZW5lcihsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1EaXNhYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44Gq44GE44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmRpc2FibGUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICogQHNpZ25hdHVyZSBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1FbmFibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgovjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcbn07XG5cblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLnhKHlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhbGwgYW5pbWF0aW9ucy4gQ291bGQgYmUgaGFuZHkgZm9yIHRlc3RpbmcgYW5kIG9sZGVyIGRldmljZXMuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuWFqOOBpueEoeWKueOBq+OBl+OBvuOBmeOAguODhuOCueODiOOBrumam+OBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgb25zLl9pbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYW5pbWF0aW9ucyAoZGVmYXVsdCkuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhdXRvbWF0aWMgc3R5bGluZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3R5bGluZyA9IG9ucy5fYXV0b1N0eWxlLmRpc2FibGU7XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBlbmFibGVBdXRvU3R5bGluZygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhdXRvbWF0aWMgc3R5bGluZyBiYXNlZCBvbiBPUyAoZGVmYXVsdCkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5lbmFibGVBdXRvU3R5bGluZyA9IG9ucy5fYXV0b1N0eWxlLmVuYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGZvcmNlUGxhdGZvcm1TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGZvcmNlUGxhdGZvcm1TdHlsaW5nKHBsYXRmb3JtKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZWZyZXNoIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybSBOZXcgcGxhdGZvcm0gdG8gc3R5bGUgdGhlIGVsZW1lbnRzLlxuICovXG5vbnMuZm9yY2VQbGF0Zm9ybVN0eWxpbmcgPSBuZXdQbGF0Zm9ybSA9PiB7XG4gIG9ucy5lbmFibGVBdXRvU3R5bGluZygpO1xuICBvbnMucGxhdGZvcm0uc2VsZWN0KG5ld1BsYXRmb3JtIHx8ICdpb3MnKTtcblxuICBvbnMuX3V0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtaWYnKSB7XG4gICAgICAgIGVsZW1lbnQuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZS5tYXRjaCgvXm9ucy0vaSkpIHtcbiAgICAgICAgb25zLl9hdXRvU3R5bGUucHJlcGFyZShlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgICAgICBlbGVtZW50Ll91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xub25zLl9jcmVhdGVQb3BvdmVyT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1wb3BvdmVyL2dpKSA/IGA8ZGl2PiR7aHRtbH08L2Rpdj5gIDogYDxvbnMtcG9wb3Zlcj4ke2h0bWx9PC9vbnMtcG9wb3Zlcj5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgcG9wb3ZlciA9IGRpdi5xdWVyeVNlbGVjdG9yKCdvbnMtcG9wb3ZlcicpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wb3Zlcik7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhwb3BvdmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9wb3ZlcjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlUG9wb3ZlclxuICogQHNpZ25hdHVyZSBjcmVhdGVQb3BvdmVyKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJlbnRTY29wZV1cbiAqICAgW2VuXVBhcmVudCBzY29wZSBvZiB0aGUgZGlhbG9nLiBVc2VkIHRvIGJpbmQgbW9kZWxzIGFuZCBhY2Nlc3Mgc2NvcGUgbWV0aG9kcyBmcm9tIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOWGheOBp+WIqeeUqOOBmeOCi+imquOCueOCs+ODvOODl+OCkuaMh+WumuOBl+OBvuOBmeOAguODgOOCpOOCouODreOCsOOBi+OCieODouODh+ODq+OChOOCueOCs+ODvOODl+OBruODoeOCveODg+ODieOBq+OCouOCr+OCu+OCueOBmeOCi+OBruOBq+S9v+OBhOOBvuOBmeOAguOBk+OBruODkeODqeODoeODvOOCv+OBr0FuZ3VsYXJKU+ODkOOCpOODs+ODh+OCo+ODs+OCsOOBp+OBruOBv+WIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgcG9wb3ZlciBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgcG9wb3ZlciBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieODneODg+ODl+OCquODvOODkOODvOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5jcmVhdGVQb3BvdmVyID0gb25zLl9jcmVhdGVQb3BvdmVyT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZURpYWxvZ09yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgaWYgKCFwYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XG4gIH1cblxuICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2goLzxvbnMtZGlhbG9nL2dpKSA/IGA8ZGl2PiR7aHRtbH08L2Rpdj5gIDogYDxvbnMtZGlhbG9nPiR7aHRtbH08L29ucy1kaWFsb2c+YDtcbiAgICBjb25zdCBkaXYgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgIGNvbnN0IGRpYWxvZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdvbnMtZGlhbG9nJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsoZGlhbG9nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlhbG9nO1xuICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVEaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlRGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaWFsb2cgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIGRpYWxvZyBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5jcmVhdGVEaWFsb2cgPSBvbnMuX2NyZWF0ZURpYWxvZ09yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xub25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgaWYgKCFwYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XG4gIH1cblxuICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2goLzxvbnMtYWxlcnQtZGlhbG9nL2dpKSA/IGA8ZGl2PiR7aHRtbH08L2Rpdj5gIDogYDxvbnMtYWxlcnQtZGlhbG9nPiR7aHRtbH08L29ucy1hbGVydC1kaWFsb2c+YDtcbiAgICBjb25zdCBkaXYgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgIGNvbnN0IGFsZXJ0RGlhbG9nID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1hbGVydC1kaWFsb2cnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFsZXJ0RGlhbG9nKTtcblxuICAgIGlmIChvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb3B0aW9ucy5saW5rKGFsZXJ0RGlhbG9nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxlcnREaWFsb2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUFsZXJ0RGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZUFsZXJ0RGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWFsZXJ0LWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhbGVydCBkaWFsb2cgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIGFsZXJ0IGRpYWxvZyBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5jcmVhdGVBbGVydERpYWxvZyA9IG9ucy5fY3JlYXRlQWxlcnREaWFsb2dPcmlnaW5hbDtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua1xuICovXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIGxpbmspIHtcbiAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudHNcbiAgICAgIC5maWx0ZXIoZWxlbWVudCA9PiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInLCBwYWdlKTtcbiAgICAgICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKGVsZW1lbnQsIHBhZ2UsIGxpbmspO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBvbnMtbG9hZGluZy1wbGFjZWhvbGRlciBleGlzdHMuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyXG4gKiBAc2lnbmF0dXJlIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIocGFnZSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGVsZW1lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUlmIG5vIHBhZ2UgaXMgZGVmaW5lZCBmb3IgdGhlIGBvbnMtbG9hZGluZy1wbGFjZWhvbGRlcmAgYXR0cmlidXRlIGl0IHdpbGwgd2FpdCBmb3IgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtbG9hZGluZy1wbGFjZWhvbGRlcuOBruWxnuaAp+WApOOBqOOBl+OBpuODmuODvOOCuOOBjOaMh+WumuOBleOCjOOBpuOBhOOBquOBhOWgtOWQiOOBr+OAgeODmuODvOOCuOODreODvOODieWJjeOBq+WRvOOBsOOCjOOCi29ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVy5Yem55CG44GM6KGM44KP44KM44KL44G+44Gn6KGo56S644GV44KM44G+44Gb44KT44CCWy9qYV1cbiAqL1xub25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbDtcblxub25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMgPSBmdW5jdGlvbigpIHtcbiAgb25zLnJlYWR5KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgcGFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicpO1xuICAgICAgaWYgKHR5cGVvZiBwYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24oZWxlbWVudCwgcGFnZSwgbGluaykge1xuICBsaW5rID0gbGluayB8fCBmdW5jdGlvbihlbGVtZW50LCBkb25lKSB7IGRvbmUoKTsgfTtcbiAgb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG5cbiAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcbiAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudCk7XG5cbiAgICBsaW5rKGNvbnRlbnRFbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9KTtcblxuICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGVkIHRvIHJlc29sdmUgcGxhY2Vob2xkZXI6ICcgKyBlcnJvcik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gd2FpdERldmljZVJlYWR5KCkge1xuICBjb25zdCB1bmxvY2tEZXZpY2VSZWFkeSA9IG9ucy5fcmVhZHlMb2NrLmxvY2soKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgaWYgKG9ucy5pc1dlYlZpZXcoKSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgdW5sb2NrRGV2aWNlUmVhZHksIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5sb2NrRGV2aWNlUmVhZHkoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn1cblxud2luZG93Ll9zdXBlclNlY3JldE9ucyA9IG9ucztcbmV4cG9ydCBkZWZhdWx0IG9ucztcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRDbGFzcygpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBjYXNlIG9mIFNhZmFyaVxuICAgIGNvbnN0IEJhc2VFbGVtZW50ID0gKCkgPT4ge307XG4gICAgQmFzZUVsZW1lbnQucHJvdG90eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuIEJhc2VFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBIVE1MRWxlbWVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRWxlbWVudCBleHRlbmRzIGdldEVsZW1lbnRDbGFzcygpIHtcbiAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgIHNlbGYgPSBzdXBlcihzZWxmKTtcbiAgICBzZWxmLmluaXQoKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGluaXQoKSB7IH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGVtcGxhdGVcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERlZmluZSBhIHNlcGFyYXRlIEhUTUwgZnJhZ21lbnQgYW5kIHVzZSBhcyBhIHRlbXBsYXRlLlxuICpcbiAqICAgICBUaGVzZSB0ZW1wbGF0ZXMgY2FuIGJlIGxvYWRlZCBhcyBwYWdlcyBpbiBgPG9ucy1uYXZpZ2F0b3I+YCwgYDxvbnMtdGFiYmFyPmAgYW5kIGA8b25zLXNwbGl0dGVyPmAuIFRoZXkgY2FuIGFsc28gYmUgdXNlZCB0byBnZW5lcmF0ZSBkaWFsb2dzLlxuICogICBbL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44Go44GX44Gm5L2/55So44GZ44KL44Gf44KB44GuSFRNTOODleODqeOCsOODoeODs+ODiOOCkuWumue+qeOBl+OBvuOBmeOAguOBk+OBruimgee0oOOBp0hUTUzjgpLlrqPoqIDjgZnjgovjgajjgIFpZOWxnuaAp+OBq+aMh+WumuOBl+OBn+WQjeWJjeOCknBhZ2Xjga5VUkzjgajjgZfjgaZvbnMtbmF2aWdhdG9y44Gq44Gp44Gu44Kz44Oz44Od44O844ON44Oz44OI44GL44KJ5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBndWlkZSB0ZW1wbGF0ZXNcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXVRoZSBgPG9ucy1uYXZpZ2F0b3I+YCBjb21wb25lbnQgZW5hYmxlcyBzdGFjayBiYXNlZCBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5dVGhlIGA8b25zLXRhYmJhcj5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGFkZCB0YWIgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRyYWdnYWJsZSBtZW51IG9yIGNvbHVtbiBiYXNlZCBsYXlvdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImZvb2Jhci5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICBQYWdlIGNvbnRlbnRcbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtbmF2aWdhdG9yIHBhZ2U9XCJmb29iYXIuaHRtbFwiPlxuICogPC9vbnMtbmF2aWdhdG9yPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0ZW1wbGF0ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UZW1wbGF0ZSBjb250ZW50LiBUaGlzIHByb3BlcnR5IGNhbiBub3QgYmUgdXNlZCB3aXRoIEFuZ3VsYXJKUyBiaW5kaW5ncy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuaW5uZXJIVE1MO1xuXG4gICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnX3RlbXBsYXRlbG9hZGVkJywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWV9KTtcbiAgICBldmVudC50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgZXZlbnQudGVtcGxhdGVJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10ZW1wbGF0ZScsIFRlbXBsYXRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlmXG4gKiBAY2F0ZWdvcnkgY29uZGl0aW9uYWxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pZlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb25kaXRpb25hbGx5IGRpc3BsYXkgY29udGVudCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLCBkZXZpY2Ugb3JpZW50YXRpb24gb3IgYm90aC5cbiAqXG4gKiAgICAgU29tZXRpbWVzIGl0IGlzIHVzZWZ1bCB0byBjb25kaXRpb25hbGx5IGhpZGUgb3Igc2hvdyBjZXJ0YWluIGNvbXBvbmVudHMgYmFzZWQgb24gcGxhdGZvcm0uIFdoZW4gcnVubmluZyBvbiBpT1MgdGhlIGA8b25zLWlmPmAgZWxlbWVudCBjYW4gYmUgdXNlZCB0byBoaWRlIHRoZSBgPG9ucy1mYWI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLWlmIG9yaWVudGF0aW9uPVwibGFuZHNjYXBlXCI+XG4gKiAgICAgTGFuZHNjYXBlIHZpZXchXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiYW5kcm9pZFwiPlxuICogICAgIFRoaXMgaXMgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJpb3Mgb3RoZXJcIj5cbiAqICAgICBUaGlzIGlzIG5vdCBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElmRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwbGF0Zm9ybVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BhY2Utc2VwYXJhdGVkIHBsYXRmb3JtIG5hbWVzLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImlvc1wiYCwgYFwiYW5kcm9pZFwiYCwgYFwid2luZG93c1wiYCBhbmQgYFwib3RoZXJcImAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcmllbnRhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FaXRoZXIgYFwicG9ydHJhaXRcImAgb3IgYFwibGFuZHNjYXBlXCJgLlsvZW5dXG4gICAqICBbamFdcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZfjgb7jgZlbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAocGxhdGZvcm0uX3JlbmRlclBsYXRmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnb3JpZW50YXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICB9XG5cbiAgX3BsYXRmb3JtVXBkYXRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIF9pc0FsbG93ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpLnNwbGl0KC9cXHMrLykuaW5kZXhPZihwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKSA+PSAwO1xuICB9XG5cbiAgX29uT3JpZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50YXRpb24nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY3VycmVudE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAoY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9PT0gY3VycmVudE9yaWVudGF0aW9uKSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pZicsIElmRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZHVyYXRpb24gPSAwLjIsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZHVyYXRpb24gPSAwLjIsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICB9XG5cbiAgLypcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge0FsZXJ0RGlhbG9nQW5pbWF0b3IsIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IsIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uLy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vLi4vb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuYWxlcnQtZGlhbG9nJzogJ2FsZXJ0LWRpYWxvZy0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcic6ICdhbGVydC1kaWFsb2ctY29udGFpbmVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctdGl0bGUnOiAnYWxlcnQtZGlhbG9nLXRpdGxlLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGVudCc6ICdhbGVydC1kaWFsb2ctY29udGVudC0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWZvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1tYXNrJzogJ2FsZXJ0LWRpYWxvZy1tYXNrLS0qJyxcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnbm9uZSc6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFsZXJ0LWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBbGVydCBkaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50IHNjcmVlbi4gVXNlZnVsIGZvciBkaXNwbGF5aW5nIHF1ZXN0aW9ucywgd2FybmluZ3Mgb3IgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIHVzZXIuIFRoZSB0aXRsZSwgY29udGVudCBhbmQgYnV0dG9ucyBjYW4gYmUgZWFzaWx5IGN1c3RvbWl6ZWQgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBzd2l0Y2ggc3R5bGUgYmFzZWQgb24gdGhlIHBsYXRmb3JtLlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVBbGVydERpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBRd3d4eXBcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgcm93Zm9vdGVyXG4gKiAgIFtlbl1Ib3Jpem9udGFsbHkgYWxpZ25zIHRoZSBmb290ZXIgYnV0dG9ucy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFsZXJ0LWRpYWxvZyBpZD1cImFsZXJ0LWRpYWxvZ1wiPlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICA8YnV0dG9uIGlkPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruihqOekuuOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBoaWRpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBp+OBr1wibm9uZVwi44GLXCJkZWZhdWx0XCLjgYzmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSAoKSA9PiB0aGlzLl9jYW5jZWwoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX3RpdGxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWxlcnREaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCByZXN1bHQgYWZ0ZXIgY29tcGlsZTpcbiAgICAgKlxuICAgICAqIDxvbnMtYWxlcnQtZGlhbG9nIHN0eWxlPVwibm9uZVwiPlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gICAgICovXG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgaWYgKCF0aGlzLl9tYXNrICYmICF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWFzaykge1xuICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctbWFzaycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZGlhbG9nLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZywgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJykpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1jb250YWluZXInKTtcbiAgICAgIHRoaXMuX2RpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBBIGNhbmNlbGFibGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OBruOBr+OAgVwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBgUHJvbWlzZWAgb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVzaG93Jywge1xuICAgICAgYWxlcnREaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeVNob3coKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgYWxlcnREaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGhpZGUnLCB7YWxlcnREaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVoaWRlIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUgJiYgIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkaWFsb2ctY2FuY2VsJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJ107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWxlcnREaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWxlcnREaWFsb2dBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hbGVydC1kaWFsb2cnLCBBbGVydERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYmFjay1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnYmFjay1idXR0b24tLSonLFxuICAnLmJhY2stYnV0dG9uX19pY29uJzogJ2JhY2stYnV0dG9uLS0qX19pY29uJyxcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYmFjay1idXR0b25cbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJhY2sgYnV0dG9uIGNvbXBvbmVudCBmb3IgYDxvbnMtdG9vbGJhcj5gLiBQdXQgaXQgaW4gdGhlIGxlZnQgcGFydCBvZiB0aGUgYDxvbnMtdG9vbGJhcj5gLlxuICpcbiAqICAgICBJdCB3aWxsIGZpbmQgdGhlIHBhcmVudCBgPG9ucy1uYXZpZ2F0b3I+YCBlbGVtZW50IGFuZCBwb3AgYSBwYWdlIHdoZW4gY2xpY2tlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNwZWNpZnlpbmcgdGhlIGBvbkNsaWNrYCBwcm9wZXJ0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5db25zLW5hdmlnYXRvciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW5hdmlnYXRvcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIFRpdGxlXG4gKiAgIDxkaXY+XG4gKiA8L29ucy10b29sYmFyPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2xhYmVsJyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGUoJ3NwYW4uYmFjay1idXR0b25fX2ljb24nKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIFwiLWlvc1wiIG9yIFwiLW1kXCJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYmFjay1idXR0b24nLCBCYWNrQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYm90dG9tLWJhcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1ib3R0b20tdG9vbGJhcj5cbiAqICAgQ29udGVudFxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHRvbVRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXBhZ2UnKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJvdHRvbS10b29sYmFyJywgQm90dG9tVG9vbGJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdidXR0b24tLSonfTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdidXR0b24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1idXR0b25cbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQnV0dG9uIHdpdGggb3V0bGluZSBhbmQgdHJhbnNwYXJlbnQgYmFja2dyb3VuZFsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLmjIHjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxpZ2h0XG4gKiAgIFtlbl1CdXR0b24gdGhhdCBkb2Vzbid0IHN0YW5kIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gf44Gq44GE44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBxdWlldFxuICogICBbZW5dQnV0dG9uIHdpdGggbm8gb3V0bGluZSBhbmQgb3IgYmFja2dyb3VuZC4uWy9lbl1cbiAqICAgW2phXeaeoOe3muOChOiDjOaZr+OBjOeEoeOBhOaWh+Wtl+OBoOOBkeOBruODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY3RhXG4gKiAgIFtlbl1CdXR0b24gdGhhdCByZWFsbHkgc3RhbmRzIG91dC5bL2VuXVxuICogICBbamFd55uu56uL44Gk44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZVxuICogICBbZW5dTGFyZ2UgYnV0dG9uIHRoYXQgY292ZXJzIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgovlpKfjgY3jgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1xdWlldFxuICogICBbZW5dTGFyZ2UgcXVpZXQgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotxdWlldOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLWN0YVxuICogICBbZW5dTGFyZ2UgY2FsbCB0byBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3mqKrjgYTjgaPjgbHjgYTjgavluoPjgYzjgotjdGHjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODnOOCv+ODs1svamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWwtLWZsYXRcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBmbGF0IGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5Xjg6njg4Pjg4jjg5zjgr/jg7NbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCdXR0b24gY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBwbGFjZSBhIGJ1dHRvbiBpbiBhIHRvb2xiYXIsIHVzZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIG9yIGA8b25zLWJhY2stYnV0dG9uPmAgaW5zdGVhZC5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYXMgYSBNYXRlcmlhbCBEZXNpZ24gYnV0dG9uIHdpdGggYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgILjg4Tjg7zjg6vjg5Djg7zjgavjg5zjgr/jg7PjgpLoqK3nva7jgZnjgovloLTlkIjjga/jgIFvbnMtdG9vbGJhci1idXR0b27jgoLjgZfjgY/jga9vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9idXR0b25cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsYXJnZS0tY3RhXCI+XG4gKiAgIFRhcCBNZVxuICogPC9vbnMtYnV0dG9uPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYnV0dG9uJywgQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2Nhcm91c2VsLWl0ZW0tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWwtaXRlbVxuICogQGNhdGVnb3J5IGNhcm91c2VsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENhcm91c2VsIGl0ZW0gY29tcG9uZW50LiBVc2VkIGFzIGEgY2hpbGQgb2YgdGhlIGA8b25zLWNhcm91c2VsPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsXG4gKiAgIFtlbl1gPG9ucy1jYXJvdXNlbD5gIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdPG9ucy1jYXJvdXNlbD7jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2Fyb3VzZWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbC1pdGVtJywgQ2Fyb3VzZWxJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9vbnMvYW5pbWl0JztcblxuY29uc3QgVmVydGljYWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlZO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbihzY3JvbGwpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKDBweCwgJyArIC1zY3JvbGwgKyAncHgsIDBweCknO1xuICB9LFxuXG4gIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZU9mZnNldDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuX2RpbWVuc2lvbnMuaGVpZ2h0IHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ1RvcCwgMTApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLShoZWlnaHQgLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcbiAgICB9XG4gIH0sXG5cbiAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUuaGVpZ2h0ID0gc2l6ZUF0dHI7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gKGkgKiBzaXplSW5mby5udW1iZXIpICsgc2l6ZUluZm8udW5pdDtcbiAgICB9XG4gIH0sXG5cbiAgX3NldHVwOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkRhdGEoKTtcbiAgICB0aGlzLl91cGRhdGVPZmZzZXQoKTtcbiAgICB0aGlzLl9sYXlvdXRDYXJvdXNlbEl0ZW1zKCk7XG4gIH1cbn07XG5cbmNvbnN0IEhvcml6b250YWxNb2RlVHJhaXQgPSB7XG5cbiAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgfSxcblxuICBfZ2V0U2Nyb2xsVmVsb2NpdHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUudmVsb2NpdHlYO1xuICB9LFxuXG4gIF9nZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uKHNjcm9sbCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoJyArIC1zY3JvbGwgKyAncHgsIDBweCwgMHB4KSc7XG4gIH0sXG5cbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLl9kaW1lbnNpb25zLndpZHRoIHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gLSh3aWR0aCAtIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSkgLyAyO1xuICAgIH1cbiAgfSxcblxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS53aWR0aCA9IHNpemVBdHRyO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcblxuICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gIH1cblxuICBfb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgICBkZWxldGUgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gIH1cblxuICBfb25EaXJlY3Rpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1ggPSAnYXV0byc7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICcnO1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBfc2F2ZUxhc3RTdGF0ZSgpIHtcbiAgICB0aGlzLl9sYXN0U3RhdGUgPSB7XG4gICAgICBlbGVtZW50U2l6ZTogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpLFxuICAgICAgY2Fyb3VzZWxFbGVtZW50Q291bnQ6IHRoaXMuaXRlbUNvdW50LFxuICAgICAgd2lkdGg6IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIHRoaXMuaXRlbUNvdW50XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG5cbiAgICBpZiAoc2l6ZUluZm8udW5pdCA9PT0gJyUnKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzaXplSW5mby5udW1iZXIgLyAxMDAgKiBlbGVtZW50U2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplSW5mby51bml0ID09PSAncHgnKSB7XG4gICAgICByZXR1cm4gc2l6ZUluZm8ubnVtYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldEluaXRpYWxJbmRleCgpIHtcbiAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksIDEwKTtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInICYmICFpc05hTihpbmRleCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKSB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSAnaXRlbS0nICsgKHRoaXMuX2lzVmVydGljYWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyk7XG4gICAgY29uc3QgaXRlbVNpemVBdHRyID0gKCcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKS50cmltKCk7XG5cbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNpemUubWF0Y2goL14oXFxkKykocHh8JSkvKTtcblxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgIHVuaXQ6IG1hdGNoZXNbMl0sXG4gICAgfTtcbiAgfVxuXG4gIF9zZXR1cEluaXRpYWxJbmRleCgpIHtcbiAgICB0aGlzLl9zY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICB7IGR1cmF0aW9uOiAwLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScgfSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cbiAgICApO1xuXG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSk7XG4gICAgY29uc3Qgc2Nyb2xsID0gKHRoaXMuX29mZnNldCB8fCAwKSArIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIGluZGV4O1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgdGhpcy5fc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsLCBvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZUluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOBjOi/lOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBleOCjOOBpuOBhOOCi29ucy1jYXJvdXNlbC1pdGVt6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZUluZGV4KCkge1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtICh0aGlzLl9vZmZzZXQgfHwgMCk7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoc2l6ZSAqIGkgPD0gc2Nyb2xsICYmIHNpemUgKiAoaSArIDEpID4gc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1heCBjYXJvdXNlbCBpbmRleFxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2lzRW5hYmxlZENoYW5nZUV2ZW50KCkge1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICBjb25zdCBjYXJvdXNlbEl0ZW1TaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuYXV0b1Njcm9sbCAmJiBNYXRoLmFicyhlbGVtZW50U2l6ZSAtIGNhcm91c2VsSXRlbVNpemUpIDwgMC41O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgX3ByZXBhcmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdMb2NrVG9BeGlzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHRoaXMucmVmcmVzaCgpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVN3aXBlYWJsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZUF1dG9SZWZyZXNoKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuXG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLnN3aXBlYWJsZSkge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93bicsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBdXRvUmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKSkge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKSB7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5nZXRBY3RpdmVJbmRleCgpO1xuXG4gICAgaWYgKHRoaXMuX2xhc3RBY3RpdmVJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICBjb25zdCBsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjdXJyZW50SW5kZXg7XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgIGFjdGl2ZUluZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgIGxhc3RBY3RpdmVJbmRleDogbGFzdEFjdGl2ZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfaXNXcm9uZ0RpcmVjdGlvbihkKSB7XG4gICAgLy8gdGhpcy5fbGFzdERyYWdEaXJlY3Rpb24gPSBkO1xuICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsKCkgPyAoZCA9PT0gJ2xlZnQnIHx8IGQgPT09ICdyaWdodCcpIDogKGQgPT09ICd1cCcgfHwgZCA9PT0gJ2Rvd24nKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNXcm9uZ0RpcmVjdGlvbihldmVudC5nZXN0dXJlLmRpcmVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX2xhc3REcmFnRXZlbnQgPSBldmVudDtcblxuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KTtcbiAgICB0aGlzLl9zY3JvbGxUbyhzY3JvbGwpO1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Njcm9sbCA9IHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KTtcblxuICAgIC8vIGlmICghdGhpcy5faXNXcm9uZ0RpcmVjdGlvbih0aGlzLl9sYXN0RHJhZ0RpcmVjdGlvbikgJiYgdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpICE9PSAwKSB7XG4gICAgLy8gICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyB9XG5cbiAgICBpZiAodGhpcy5faXNPdmVyU2Nyb2xsKHRoaXMuX3Njcm9sbCkpIHtcbiAgICAgIGxldCB3YWl0Rm9yQWN0aW9uID0gZmFsc2U7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ292ZXJzY3JvbGwnLCB7XG4gICAgICAgIGNhcm91c2VsOiB0aGlzLFxuICAgICAgICBhY3RpdmVJbmRleDogdGhpcy5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24oKSxcbiAgICAgICAgd2FpdFRvUmV0dXJuOiAocHJvbWlzZSkgPT4ge1xuICAgICAgICAgIHdhaXRGb3JBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHByb21pc2UudGhlbigoKSA9PiB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF3YWl0Rm9yQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhcnRNb21lbnR1bVNjcm9sbCgpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gbnVsbDtcblxuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhaXRcbiAgICovXG4gIF9taXhpbih0cmFpdCkge1xuICAgIE9iamVjdC5rZXlzKHRyYWl0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpc1trZXldID0gdHJhaXRba2V5XTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgX3N0YXJ0TW9tZW50dW1TY3JvbGwoKSB7XG4gICAgaWYgKHRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGhpcy5fZ2V0U2Nyb2xsVmVsb2NpdHkodGhpcy5fbGFzdERyYWdFdmVudCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IDAuMztcbiAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0gZHVyYXRpb24gKiAxMDAgKiB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLl9zY3JvbGwgKyAodGhpcy5fZ2V0U2Nyb2xsRGVsdGEodGhpcy5fbGFzdERyYWdFdmVudCkgPiAwID8gLXNjcm9sbERlbHRhIDogc2Nyb2xsRGVsdGEpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9zY3JvbGwgPSBzY3JvbGw7XG5cbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0odGhpcy5fc2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKHNjcm9sbCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgaWYgKCF0aGlzLmF1dG9TY3JvbGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cbiAgICBsZXQgYXJyID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcbiAgICBjb25zdCBuYnJPZkl0ZW1zID0gdGhpcy5pdGVtQ291bnQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ick9mSXRlbXM7IGkrKykge1xuICAgICAgaWYgKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0IDwgbWF4KSB7XG4gICAgICAgIGFyci5wdXNoKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJyLnB1c2gobWF4KTtcblxuICAgIGFyci5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBsZWZ0ID0gTWF0aC5hYnMobGVmdCAtIHNjcm9sbCk7XG4gICAgICByaWdodCA9IE1hdGguYWJzKHJpZ2h0IC0gc2Nyb2xsKTtcblxuICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICB9KTtcblxuICAgIGFyciA9IGFyci5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgcG9zKSB7XG4gICAgICByZXR1cm4gIXBvcyB8fCBpdGVtICE9IGFycltwb3MgLSAxXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuICAgIGxldCByZXN1bHQgPSBhcnJbMF07XG5cbiAgICBpZiAoc2Nyb2xsUmF0aW8gPD0gdGhpcy5hdXRvU2Nyb2xsUmF0aW8pIHtcbiAgICAgIHJlc3VsdCA9IGxhc3RTY3JvbGw7XG4gICAgfSBlbHNlIGlmIChzY3JvbGxSYXRpbyA8IDEuMCkge1xuICAgICAgaWYgKGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgcmVzdWx0KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1jYXJvdXNlbC1pdGVtJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50XG4gICAqL1xuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpc092ZXJzY3JvbGxhYmxlID0gdGhpcy5vdmVyc2Nyb2xsYWJsZTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZVNjcm9sbCA9IChzY3JvbGwpID0+IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gMC4zNTtcblxuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGlzT3ZlcnNjcm9sbGFibGUgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkpXG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0aW9uICAhPT0gJ25vbmUnID8gb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIDoge30pXG4gICAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlTWF4U2Nyb2xsKCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaXRlbUNvdW50ICogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIC0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG1heCA8IDAgPyAwIDogbWF4KTsgLy8gTmVlZCB0byByZXR1cm4gYW4gaW50ZWdlciB2YWx1ZS5cbiAgfVxuXG4gIF9pc092ZXJTY3JvbGwoc2Nyb2xsKSB7XG4gICAgaWYgKHNjcm9sbCA8IDAgfHwgc2Nyb2xsID4gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfZ2V0T3ZlclNjcm9sbERpcmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgfVxuXG4gIF9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gMC40O1xuXG4gICAgaWYgKHRoaXMuX3Njcm9sbCA8IDApIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0oMClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAucGxheSgpO1xuICAgICAgdGhpcy5fc2Nyb2xsID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgIGlmIChtYXhTY3JvbGwgPCB0aGlzLl9zY3JvbGwpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obWF4U2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgICB0aGlzLl9zY3JvbGwgPSBtYXhTY3JvbGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpdGVtQ291bnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbnVtYmVyIG9mIGNhcm91c2VsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+imgee0oOOBruaVsOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoZSBjYXJvdXNlbC4gVXNlZCB3aGVuIGFkZGluZyBgPG9ucy1jYXJvdXNlbC1pdGVtcz5gIGR5bmFtaWNhbGx5IG9yIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBzaXplLlsvZW5dXG4gICAqICAgW2phXeODrOOCpOOCouOCpuODiOOChOWGhemDqOOBrueKtuaFi+OCkuacgOaWsOOBruOCguOBruOBq+abtOaWsOOBl+OBvuOBmeOAgm9ucy1jYXJvdXNlbC1pdGVt44KS5YuV55qE44Gr5aKX44KE44GX44Gf44KK44CBb25zLWNhcm91c2Vs44Gu5aSn44GN44GV44KS5YuV55qE44Gr5aSJ44GI44KL6Zqb44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgLy8gQnVnIGZpeFxuICAgIGlmICh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9taXhpbih0aGlzLl9pc1ZlcnRpY2FsKCkgPyBWZXJ0aWNhbE1vZGVUcmFpdCA6IEhvcml6b250YWxNb2RlVHJhaXQpO1xuICAgIHRoaXMuX3NldHVwKCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlICYmIHRoaXMuX2xhc3RTdGF0ZS53aWR0aCA+IDApIHtcbiAgICAgIGxldCBzY3JvbGwgPSB0aGlzLl9zY3JvbGw7Ly8gLSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwoc2Nyb2xsKSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywge2Nhcm91c2VsOiB0aGlzfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBmaXJzdFxuICAgKiBAc2lnbmF0dXJlIGZpcnN0KClcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBmaXJzdCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZmlyc3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KDAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbGFzdFxuICAgKiBAc2lnbmF0dXJlIGxhc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbGFzdCBvbnMtY2Fyb3VzZWwgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3mnIDlvozjga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsYXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldEFjdGl2ZUluZGV4KFxuICAgICAgTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuX3NldHVwKCk7XG4gICAgdGhpcy5fc2V0dXBJbml0aWFsSW5kZXgoKTtcblxuICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcblxuICAgIC8vIEZpeCByZW5kZXJpbmcgZ2xpdGNoIG9uIEFuZHJvaWQgNC4xXG4gICAgaWYgKHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N3aXBlYWJsZScsICdhdXRvLXJlZnJlc2gnLCAnZGlyZWN0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXV0by1yZWZyZXNoJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlQXV0b1JlZnJlc2goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9vbkRpcmVjdGlvbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxSYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgYXV0byBzY3JvbGwgcmF0aW8uIFsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycpO1xuXG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICByZXR1cm4gMC41O1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gcGFyc2VGbG9hdChhdHRyKTtcbiAgICBpZiAoc2Nyb2xsUmF0aW8gPCAwLjAgfHwgc2Nyb2xsUmF0aW8gPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOYU4oc2Nyb2xsUmF0aW8pID8gMC41IDogc2Nyb2xsUmF0aW87XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIHRoZSBjYXJvdXNlbCBpcyBzd2lwZWFibGUuWy9lbl1cbiAgICogICBbamFdc3dpcGVhYmxl44Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgc3dpcGVhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJyk7XG4gIH1cblxuICBzZXQgc3dpcGVhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzd2lwZWFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYXV0by1zY3JvbGwnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3ZlcnNjcm9sbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBvdmVyc2Nyb2xsYWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFdb3ZlcnNjcm9sbOOBp+OBjeOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG92ZXJzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnKTtcbiAgfVxuXG4gIHNldCBvdmVyc2Nyb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnb3ZlcnNjcm9sbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNlbnRlcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgY2VudGVyZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXWNlbnRlcmVk54q25oWL44Gr44Gq44Gj44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2VudGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjZW50ZXJlZCcpO1xuICB9XG5cbiAgc2V0IGNlbnRlcmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjZW50ZXJlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3Bvc3RjaGFuZ2UnLCAncmVmcmVzaCcsICdvdmVyc2Nyb2xsJ107XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwnLCBDYXJvdXNlbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSBsYXlvdXRpbmcgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVdpZHRoKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnd2lkdGgnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd3aWR0aCcpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVdpZHRoKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVdpZHRoKCkge1xuICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIGlmICh0eXBlb2Ygd2lkdGggID09PSAnc3RyaW5nJykge1xuICAgICAgd2lkdGggPSAoJycgKyB3aWR0aCkudHJpbSgpO1xuICAgICAgd2lkdGggPSB3aWR0aC5tYXRjaCgvXlxcZCskLykgPyB3aWR0aCArICclJyA6IHdpZHRoO1xuXG4gICAgICB0aGlzLnN0eWxlLndlYmtpdEJveEZsZXggPSAnMCc7XG4gICAgICB0aGlzLnN0eWxlLndlYmtpdEZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubW96Qm94RmxleCA9ICcwJztcbiAgICAgIHRoaXMuc3R5bGUubW96RmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tc0ZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUuZmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tYXhXaWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jb2wnLCBDb2xFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJ1xuXG5leHBvcnQgY2xhc3MgRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAzMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgMzAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGlkZURpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtMzUwJSwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTM1MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7RGlhbG9nQW5pbWF0b3IsIElPU0RpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIFNsaWRlRGlhbG9nQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vLi4vb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5kaWFsb2cnOiAnZGlhbG9nLS0qJyxcbiAgJy5kaWFsb2ctY29udGFpbmVyJzogJ2RpYWxvZy1jb250YWluZXItLSonLFxuICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnc2xpZGUnOiBTbGlkZURpYWxvZ0FuaW1hdG9yLFxuICAnbm9uZSc6IERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi4gQXMgb3Bwb3NlZCB0byB0aGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCwgdGhpcyBjb21wb25lbnQgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgY29udGVudC5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgICBUaGUgZGlhbG9nIGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBtZW51cywgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciB0byBhc2sgdGhlIHVzZXIgdG8gbWFrZSBhIGRlY2lzaW9uLlxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZGlzcGxheWVkIGFzIE1hdGVyaWFsIERlc2lnbiB3aGVuIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBkZXZpY2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHp4eGFHYVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQGd1aWRlIGRpYWxvZ3NcbiAqICAgW2VuXURpYWxvZyBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXURpYWxvZyBjb21wb25lbnRzWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuZGlhbG9nLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfZGlhbG9nKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZycpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcblxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gKCkgPT4gdGhpcy5fY2FuY2VsKCk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IERpYWxvZ0FuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0RpYWxvZ0FuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAxMDAwMTtcblxuICAgIC8qIEV4cGVjdGVkIHJlc3VsdDpcbiAgICAgKiAgIDxvbnMtZGlhbG9nPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxuICAgICAqICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICAgPC9vbnMtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZycpO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkaWFsb2ctY29udGFpbmVyJyk7XG5cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XG4gICAgICBkaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJ107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zRGlhbG9nRWxlbWVudC5EaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWRpYWxvZycsIERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2ZhYic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSonXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1mYWJcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ZhYlxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudCBpcyBhIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gdGhhdCBkaXNwbGF5cyBhIG1lbnUgd2hlbiB0YXBwZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgcG9zaXRpb24gb2YgdGhlIGJ1dHRvbi4gU2hvdWxkIGJlIGEgc3RyaW5nIGxpa2UgYFwiYm90dG9tIHJpZ2h0XCJgIG9yIGBcInRvcCBsZWZ0XCJgLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIHN0YXRlbWVudHMgY2FuIGJlIGV4ZWN1dGVkIGJlZm9yZSBjb250ZW50UmVhZHlcbiAgICAvLyBzaW5jZSB0aGVzZSBkbyBub3QgYWNjZXNzIHRoZSBjaGlsZHJlblxuICAgIHRoaXMuc2hvdygpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5mYWJfX2ljb24nKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZmFiX19pY29uJyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcmlwcGxlJykge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAncG9zaXRpb24nLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1IaWRlIHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDApJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUudHJhbnNmb3JtID09PSAnc2NhbGUoMSknICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy52aXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1mYWInLCBGYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1nZXN0dXJlLWRldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdG8gZGV0ZWN0IGZpbmdlciBnZXN0dXJlcyB3aXRoaW4gdGhlIHdyYXBwZWQgZWxlbWVudC4gRm9sbG93aW5nIGdlc3R1cmVzIGFyZSBzdXBwb3J0ZWQ6XG4gKiAgICAgLSBEcmFnIGdlc3R1cmVzOiBgZHJhZ2AsIGBkcmFnbGVmdGAsIGBkcmFncmlnaHRgLCBgZHJhZ3VwYCwgYGRyYWdkb3duYFxuICogICAgIC0gSG9sZCBnZXN0dXJlczogYGhvbGRgLCBgcmVsZWFzZWBcbiAqICAgICAtIFN3aXBlIGdlc3R1cmVzOiBgc3dpcGVgLCBgc3dpcGVsZWZ0YCwgYHN3aXBlcmlnaHRgLCBgc3dpcGV1cGAsIGBzd2lwZWRvd25gXG4gKiAgICAgLSBUYXAgZ2VzdHVyZXM6IGB0YXBgLCBgZG91YmxldGFwYFxuICogICAgIC0gUGluY2ggZ2VzdHVyZXM6IGBwaW5jaGAsIGBwaW5jaGluYCwgYHBpbmNob3V0YFxuICogICAgIC0gT3RoZXIgZ2VzdHVyZXM6IGB0b3VjaGAsIGB0cmFuc2Zvcm1gLCBgcm90YXRlYFxuICogICBbL2VuXVxuICogICBbamFd6KaB57Sg5YaF44Gu44K444Kn44K544OB44Oj44O85pON5L2c44KS5qSc55+l44GX44G+44GZ44CC6Kmz44GX44GP44Gv44Ks44Kk44OJ44KS5Y+C54Wn44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAqIEBndWlkZSBnZXN0dXJlLWRldGVjdG9yXG4gKiAgIFtlbl1EZXRlY3RpbmcgZmluZ2VyIGdlc3R1cmVzWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOBruaknOefpVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1nZXN0dXJlLWRldGVjdG9yPlxuICogICA8ZGl2IGlkPVwiZGV0ZWN0LWFyZWFcIiBzdHlsZT1cIndpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDtcIj5cbiAqICAgICBTd2lwZSBIZXJlXG4gKiAgIDwvZGl2PlxuICogPC9vbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2lwZWxlZnQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGlmIChldmVudC50YXJnZXQubWF0Y2hlcygnI2RldGVjdC1hcmVhJykpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdTd2lwZSBsZWZ0IGlzIGRldGVjdGVkLicpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VzdHVyZURldGVjdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWdlc3R1cmUtZGV0ZWN0b3InLCBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWljb25cbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheXMgYW4gaWNvbi4gVGhlIGZvbGxvd2luZyBpY29uIHN1aXRlcyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20vKVxuICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geEFodmdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pY29uXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaWNvblxuICogICBpY29uPVwibWQtY2FyXCJcbiAqICAgc2l6ZT1cIjIwcHhcIlxuICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cbiAqIDwvb25zLWljb24+XG4gKlxuICogPG9ucy1idXR0b24+XG4gKiAgIDxvbnMtaWNvbiBpY29uPVwibWQtY2FyXCI+PC9vbnMtaWNvbj5cbiAqICAgQ2FyXG4gKiA8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZS4gYFwibWQtXCJgIHByZWZpeCBmb3IgTWF0ZXJpYWwgSWNvbnMsIGBcImZhLVwiYCBmb3IgRm9udCBBd2Vzb21lIGFuZCBgXCJpb24tXCJgIHByZWZpeCBmb3IgSW9uaWNvbnMuXG4gICAqXG4gICAqICAgICBTZWUgYWxsIGF2YWlsYWJsZSBpY29ucyBvbiB0aGVpciByZXNwZWN0aXZlIHNpdGVzOlxuICAgKlxuICAgKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICAgKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20pXG4gICAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxuICAgKlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdCwgbWF0ZXJpYWw6bWQtZWRpdFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCBkaXNwbGF5IGBcIm1kLWVkaXRcImAgZm9yIE1hdGVyaWFsIERlc2lnbiBhbmQgYFwiaW9uLWVkaXRcImAgYXMgdGhlIGRlZmF1bHQgaWNvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBzaXplcyBvZiB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSBsZywgMngsIDN4LCA0eCwgNXgsIG9yIGluIHRoZSBzaXplIGluIHBpeGVscy5cbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgKlxuICAgKiAgICAgVGhlIGNvZGU6XG4gICAqXG4gICAqICAgICBgYGBcbiAgICogICAgIDxvbnMtaWNvblxuICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXRcIlxuICAgKiAgICAgICBzaXplPVwiMzJweCwgbWF0ZXJpYWw6MjRweFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCByZW5kZXIgYXMgYSBgMjRweGAgaWNvbiBpZiB0aGUgYFwibWF0ZXJpYWxcImAgbW9kaWZpZXIgaXMgcHJlc2VudCBhbmQgYDMycHhgIG90aGVyd2lzZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByb3RhdGVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSA5MCwgMTgwIGFuZCAyNzAuWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz44KS5Zue6Lui44GX44Gm6KGo56S644GX44G+44GZ44CCOTAsIDE4MCwgMjcw44GL44KJ5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtd2lkdGhcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVdoZW4gdXNlZCBpbiBhIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IGRlZmluaW5nIHRoaXMgYXR0cmlidXRlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3BpblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2ljb24nLCAnc2l6ZScsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAoWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fZ2V0QXR0cmlidXRlKCdpY29uJyksIHRoaXMuX2dldEF0dHJpYnV0ZSgnc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX2dldEF0dHJpYnV0ZShhdHRyKSB7XG4gICAgY29uc3QgcGFydHMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgJycpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcbiAgICBsZXQgbWQgPSBwYXJ0c1sxXTtcbiAgICBtZCA9IChtZCB8fCAnJykuc3BsaXQoL1xccyo6XFxzKi8pO1xuICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgKi9cbiAgX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKSB7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiAvXihmYSR8ZmEtfGlvbi18em1kaS0pLy50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd6bWRpJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvbnMtaWNvbi0taW9uJyk7XG4gIH1cblxuICBfYnVpbGRDbGFzc0FuZFN0eWxlKGljb25OYW1lLCBzaXplKSB7XG4gICAgY29uc3QgY2xhc3NMaXN0ID0gWydvbnMtaWNvbiddO1xuICAgIGNvbnN0IHN0eWxlID0ge307XG5cbiAgICAvLyBJY29uXG4gICAgaWYgKGljb25OYW1lLmluZGV4T2YoJ2lvbi0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS1pb24nKTtcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lLmluZGV4T2YoJ2ZhLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEnKTtcbiAgICB9IGVsc2UgaWYoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC9cXC0oLispPy8pWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEtJyArIGljb25OYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWNvbicsIEljb25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQge0xhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyfSBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1sYXp5LXJlcGVhdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXNpbmcgdGhpcyBjb21wb25lbnQgYSBsaXN0IHdpdGggbWlsbGlvbnMgb2YgaXRlbXMgY2FuIGJlIHJlbmRlcmVkIHdpdGhvdXQgYSBkcm9wIGluIHBlcmZvcm1hbmNlLlxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcbiAqICAgICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBET00gd2hlbiB0aGV5IGFyZSBub3QgdmlzaWJsZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOWGheOBp+aPj+eUu+OBleOCjOOCi+OCouOCpOODhuODoOOBrkRPTeimgee0oOOBruiqreOBv+i+vOOBv+OBr+OAgeeUu+mdouOBq+imi+OBiOOBneOBhuOBq+OBquOBo+OBn+aZguOBvuOBp+iHquWLleeahOOBq+mBheW7tuOBleOCjOOAgVxuICogICAgIOeUu+mdouOBi+OCieimi+OBiOOBquOBj+OBquOBo+OBn+WgtOWQiOOBq+OBr+OBneOBruimgee0oOOBr+WLleeahOOBq+OCouODs+ODreODvOODieOBleOCjOOBvuOBmeOAglxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXdyR0JtXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGF6eS1yZXBlYXRcbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGVsZW1lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBsaXN0LlsvZW5dXG4gKiAgIFtqYV1gPG9ucy1saXN0PmDopoHntKDjga/jg6rjgrnjg4jjgpLmj4/nlLvjgZnjgovjga7jgavkvb/jgo/jgozjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24odGhpcyk7XG5cbiAgICAvLyBub3QgdmVyeSBnb29kIGlkZWEgYW5kIGFsc28gbm90IGRvY3VtZW50ZWRcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RlbGVnYXRlJykpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB3aW5kb3dbdGhpcy5nZXRBdHRyaWJ1dGUoJ2RlbGVnYXRlJyldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBhIGRlbGVnYXRlIG9iamVjdCB0byBsb2FkIGFuZCB1bmxvYWQgaXRlbSBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXeimgee0oOOBruODreODvOODieOAgeOCouODs+ODreODvOODieOBquOBqeOBruWHpueQhuOCkuWnlOitsuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgSFRNTEVsZW1lbnRgLlxuICAgKlxuICAgKiAgICAgVG8gaGVscCByZW5kZXJpbmcgdGhlIGVsZW1lbnQsIHRoZSBjdXJyZW50IGluZGV4IGFuZCBhIHRlbXBsYXRlIGlzIHN1cHBsaWVkIGFzIGFyZ3VtZW50cy4gVGhlIHRlbXBsYXRlIGlzIHRoZSBpbml0aWFsIGNvbnRlbnQgb2YgdGhlIGA8b25zLWxhenktcmVwZWF0PmAgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBrumWouaVsOOBr2BIVE1MRWxlbWVudGDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJcbiAgICogICAgIOimgee0oOOCkueUn+aIkOOBl+OChOOBmeOBj+OBmeOCi+OBn+OCgeOBq+OAgeePvuWcqOOBruOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueOBqOODhuODs+ODl+ODrOODvOODiOOBjOW8leaVsOOBq+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu44OG44Oz44OX44Os44O844OI44Gv44CBYDxvbnMtbGF6eS1yZXBlYXQ+YOimgee0oOOBruOCs+ODs+ODhuODs+ODhOOBjOa4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY291bnRJdGVtc1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG91bGQgcmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3QuWy9lbl1cbiAgICogICBbamFd44Oq44K544OI5YaF44Gu44Ki44Kk44OG44Og5pWw44KS6L+U44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU2hvdWxkIHJldHVybiB0aGUgaGVpZ2h0IG9mIGFuIGl0ZW0uIFRoZSBpbmRleCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogICAgIFRoaXMgaXMgaW1wb3J0YW50IHdoZW4gcmVuZGVyaW5nIGxpc3RzIHdoZXJlIHRoZSBpdGVtcyBoYXZlIGRpZmZlcmVudCBoZWlnaHQuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYW5kIGlmIGl0IGlzbid0IHByZXNlbnQgdGhlIGhlaWdodCBvZiB0aGUgZmlyc3QgaXRlbSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdXNlZCBmb3IgYWxsIG90aGVyIGl0ZW1zLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44Ki44Kk44OG44Og44Gu6auY44GVKOODlOOCr+OCu+ODqynjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgILjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjga/lvJXmlbDjgafmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OAgeOBneOCjOOBnuOCjOOBruOCouOCpOODoOOBjOmBleOBo+OBn+mrmOOBleOCkuaMgeOBpOODquOCueODiOOCkuODrOODs+ODgOODquODs+OCsOOBmeOCi+mam+OBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44Kq44OX44K344On44OK44Or44Gn44GZ44CC44KC44GX44GT44Gu6Zai5pWw44GM54Sh44GE5aC05ZCI44Gr44Gv44CBXG4gICAqICAgICDmnIDliJ3jga7jgqLjgqTjg4bjg6Djga7pq5jjgZXjgYzku5bjga7jgZnjgbnjgabjga7jgqLjgqTjg4bjg6Djga7pq5jjgZXjgajjgZfjgabliKnnlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmRlc3Ryb3lJdGVtXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uIFRoZSBpbmRleCBhbmQgRE9NIGVsZW1lbnQgaXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzLlxuICAgKlxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGJ1dCBtYXkgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OAgeOBguOCi+OCouOCpOODhuODoOOBjERPTeODhOODquODvOOBi+OCiemZpOOBi+OCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K55YCk44GoRE9N6KaB57Sg44GM5byV5pWw44Go44GX44Gm5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgYzjgIHlkITjgqLjgqTjg4bjg6Djga7lvozlh6bnkIbjgYzlv4XopoHjgarloLTlkIjjgavjga/jg6Hjg6Ljg6rjg7zjg6rjg7zjgq/jgpLpgb/jgZHjgovjgZ/jgoHjgavph43opoHjgafjgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICBzZXQgZGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRWxlbWVudCAmJiB0aGlzLmNoaWxkcmVuWzBdKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGVnYXRlID0gbmV3IExhenlSZXBlYXREZWxlZ2F0ZSh1c2VyRGVsZWdhdGUsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCB8fCBudWxsKTtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBuZXcgTGF6eVJlcGVhdFByb3ZpZGVyKHRoaXMucGFyZW50RWxlbWVudCwgZGVsZWdhdGUpO1xuICB9XG5cbiAgZ2V0IGRlbGVnYXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwcm9wZXJ0eSBjYW4gb25seSBiZSB1c2VkIHRvIHNldCB0aGUgZGVsZWdhdGUgb2JqZWN0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAc2lnbmF0dXJlIHJlZnJlc2goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVmcmVzaCB0aGUgbGlzdC4gVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGRhdGEgaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Oq44K544OI44KS5pu05paw44GX44G+44GZ44CC44KC44GX44OH44O844K/44GM5aSJ44KP44Gj44Gf5aC05ZCI44Gr44Gv44GT44Gu44Oh44K944OD44OJ44KS5L2/44Gj44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5yZWZyZXNoKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1sYXp5LXJlcGVhdCcsIExhenlSZXBlYXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0X19oZWFkZXInO1xuY29uc3Qgc2NoZW1lID0geycnOiAnbGlzdF9faGVhZGVyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaGVhZGVyXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1IZWFkZXIgZWxlbWVudCBmb3IgbGlzdCBpdGVtcy4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jopoHntKDjgavkvb/nlKjjgZnjgovjg5jjg4Pjg4Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLWxpc3QtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBsaXN0cyBbZW5dVXNpbmcgbGlzdHNbL2VuXVtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBoZWFkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiA8L29ucy1saXN0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SGVhZGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaGVhZGVyLlsvZW5dXG4gICAqICAgW2phXeODmOODg+ODgOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWhlYWRlcicsIExpc3RIZWFkZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3RfX2l0ZW0nO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnLmxpc3RfX2l0ZW0nOiAnbGlzdF9faXRlbS0tKicsXG4gICcubGlzdF9faXRlbV9fbGVmdCc6ICdsaXN0X19pdGVtLS0qX19sZWZ0JyxcbiAgJy5saXN0X19pdGVtX19jZW50ZXInOiAnbGlzdF9faXRlbS0tKl9fY2VudGVyJyxcbiAgJy5saXN0X19pdGVtX19yaWdodCc6ICdsaXN0X19pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdF9faXRlbV9fbGFiZWwnOiAnbGlzdF9faXRlbS0tKl9fbGFiZWwnLFxuICAnLmxpc3RfX2l0ZW1fX3RpdGxlJzogJ2xpc3RfX2l0ZW0tLSpfX3RpdGxlJyxcbiAgJy5saXN0X19pdGVtX19zdWJ0aXRsZSc6ICdsaXN0X19pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdF9faXRlbV9fdGh1bWJuYWlsJzogJ2xpc3RfX2l0ZW0tLSpfX3RodW1ibmFpbCcsXG4gICcubGlzdF9faXRlbV9faWNvbic6ICdsaXN0X19pdGVtLS0qX19pY29uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1pdGVtXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIHRhcHBhYmxlXG4gKiAgIFtlbl1NYWtlIHRoZSBsaXN0IGl0ZW0gY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiBpdCdzIHRhcHBlZC4gT24gaU9TIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIFwidGFwcGFibGVcIiBhbmQgXCJ0YXAtYmFja2dyb3VuZC1jb2xvclwiIGF0dHJpYnV0ZSBmb3IgYmV0dGVyIGJlaGF2aW9yIHdoZW4gc2Nyb2xsaW5nLlsvZW5dXG4gKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZfjgZ/mmYLjgavlirnmnpzjgYzooajnpLrjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNoZXZyb25cbiAqICAgW2VuXURpc3BsYXkgYSBjaGV2cm9uIGF0IHRoZSByaWdodCBlbmQgb2YgdGhlIGxpc3QgaXRlbSBhbmQgbWFrZSBpdCBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIHRhcHBlZC4gVGhlIGNoZXZyb24gaXMgbm90IGRpc3BsYXllZCBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbG9uZ2RpdmlkZXJcbiAqICAgW2VuXURpc3BsYXlzIGEgbG9uZyBob3Jpem9udGFsIGRpdmlkZXIgYmV0d2VlbiBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBub2RpdmlkZXJcbiAqICAgW2VuXVJlbW92ZXMgdGhlIGRpdmlkZXIgYmV0d2VlbiBsaXN0IGl0ZW1zLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGxpc3QgaXRlbS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgcmVwcmVzZW50cyBlYWNoIGl0ZW0gaW4gdGhlIGxpc3QuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5cbiAqXG4gKiAgICAgVGhlIGxpc3QgaXRlbSBpcyBjb21wb3NlZCBvZiB0aHJlZSBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgIGFuZCBgcmlnaHRgIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbXMgaXMgcHJvcGVybHkgYWxpZ25lZC5cbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5DZW50ZXI8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlJpZ2h0PC9kaXY+XG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGVyZSBpcyBhbHNvIGEgbnVtYmVyIG9mIGNsYXNzZXMgKHByZWZpeGVkIHdpdGggYGxpc3RfX2l0ZW1fXypgKSB0aGF0IGhlbHAgd2hlbiBwdXR0aW5nIHRoaW5ncyBsaWtlIGljb25zIGFuZCB0aHVtYm5haWxzIGludG8gdGhlIGxpc3QgaXRlbXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXW9ucy1saXN0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBsaXN0c1xuICogICBbZW5dVXNpbmcgbGlzdHNbL2VuXVxuICogICBbamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdC1pdGVtPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwibWQtZmFjZVwiIGNsYXNzPVwibGlzdF9faXRlbV9faWNvblwiPjwvb25zLWljb24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3RfX2l0ZW1fX3RpdGxlXCI+VGl0bGU8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdF9faXRlbV9fc3VidGl0bGVcIj5TdWJ0aXRsZTwvZGl2PlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy1zd2l0Y2g+PC9vbnMtc3dpdGNoPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWxpc3QtaXRlbT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeWQhOimgee0oOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxvY2stb24tZHJhZ1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2hlbiB0aGUgdXNlciBkcmFncyBob3Jpem9udGFsbHkuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44Om44O844K244O844GM44GT44Gu6KaB57Sg44KS5qiq5pa55ZCR44Gr44OJ44Op44OD44Kw44GX44Gm44GE44KL5pmC44Gr44CB57im5pa55ZCR44Gu44K544Kv44Ot44O844Or44GM6LW344GN44Gq44GE44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwcGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlcyB0aGUgZWxlbWVudCByZWFjdCB0byB0YXBzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX2xlZnQnKTtcbiAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICBjZW50ZXIgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19yaWdodCcpO1xuICAgICAgICByaWdodCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAoZWwgIT09IGxlZnQgJiYgZWwgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNlbnRlciwgcmlnaHQgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ2NlbnRlcicpO1xuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19jZW50ZXInKTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdyaXBwbGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XG5cbiAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICB9XG5cbiAgZ2V0IF90cmFuc2l0aW9uKCkge1xuICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvciAwLjBzIGxpbmVhciAwLjAycywgYm94LXNoYWRvdyAwLjBzIGxpbmVhciAwLjAycyc7XG4gIH1cblxuICBnZXQgX3RhcHBhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgfVxuXG4gIGdldCBfdGFwQmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndGFwLWJhY2tncm91bmQtY29sb3InKSB8fCAnI2Q5ZDlkOSc7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGNvbnN0IGdlc3R1cmUgPSBldmVudC5nZXN0dXJlO1xuICAgIC8vIFByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIGlmIHRoZSB1c2VycyBwYW5zIGxlZnQgb3IgcmlnaHQuXG4gICAgaWYgKHRoaXMuX3Nob3VsZExvY2tPbkRyYWcoKSAmJiBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGdlc3R1cmUuZGlyZWN0aW9uKSA+IC0xKSB7XG4gICAgICBnZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgX29uVG91Y2goKSB7XG4gICAgaWYgKHRoaXMudGFwcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50YXBwZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuICAgIHRoaXMuc3R5bGUuTW96VHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG5cbiAgICBpZiAodGhpcy5fdGFwcGFibGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX3RhcEJhY2tncm91bmRDb2xvcjtcbiAgICAgIHRoaXMuc3R5bGUuYm94U2hhZG93ID0gYDBweCAtMXB4IDBweCAwcHggJHt0aGlzLl90YXBCYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICB9XG4gIH1cblxuICBfb25SZWxlYXNlKCkge1xuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSAnJztcblxuICAgIHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgfHwgJyc7XG4gICAgdGhpcy5zdHlsZS5ib3hTaGFkb3cgPSAnJztcbiAgfVxuXG4gIF9zaG91bGRMb2NrT25EcmFnKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnbG9jay1vbi1kcmFnJyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1pdGVtJywgTGlzdEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0JztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciBpbnNldFxuICogICBbZW5dSW5zZXQgbGlzdCB0aGF0IGRvZXNuJ3QgY292ZXIgdGhlIHdob2xlIHdpZHRoIG9mIHRoZSBwYXJlbnQuWy9lbl1cbiAqICAgW2phXeimquimgee0oOOBrueUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCieOBquOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbm9ib3JkZXJcbiAqICAgW2VuXUEgbGlzdCB3aXRoIG5vIGJvcmRlcnMgYXQgdGhlIHRvcCBhbmQgYm90dG9tLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdG8gZGVmaW5lIGEgbGlzdCwgYW5kIHRoZSBjb250YWluZXIgZm9yIG9ucy1saXN0LWl0ZW0ocykuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuihqOePvuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN0LWl0ZW3jga7jgrPjg7Pjg4bjg4rjgajjgZfjgabkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5db25zLWxpc3QtaXRlbSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1sYXp5LXJlcGVhdFxuICogICBbZW5db25zLWxhenktcmVwZWF0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGF6eS1yZXBlYXTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIGxpc3RzXG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0JywgTGlzdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2hlY2tib3hDbGFzcyA9ICdjaGVja2JveCc7XG5jb25zdCBkZWZhdWx0UmFkaW9CdXR0b25DbGFzcyA9ICdyYWRpby1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCcsXG4gICcucmFkaW8tYnV0dG9uJzogJ3JhZGlvLWJ1dHRvbi0tKicsXG4gICcucmFkaW8tYnV0dG9uX19pbnB1dCc6ICdyYWRpby1idXR0b24tLSpfX2lucHV0JyxcbiAgJy5yYWRpby1idXR0b25fX2NoZWNrbWFyayc6ICdyYWRpby1idXR0b24tLSpfX2NoZWNrbWFyaycsXG4gICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxuICAnLmNoZWNrYm94X19pbnB1dCc6ICdjaGVja2JveC0tKl9faW5wdXQnLFxuICAnLmNoZWNrYm94X19jaGVja21hcmsnOiAnY2hlY2tib3gtLSpfX2NoZWNrbWFyaydcbn07XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd0eXBlJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogIFtlbl1EaXNwbGF5cyBhIHRyYW5zcGFyZW50IGlucHV0LiBXb3JrcyBmb3IgTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBbiBpbnB1dCBlbGVtZW50LiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGlucHV0IHR5cGUuIEFsbCB0ZXh0IGlucHV0IHR5cGVzIGFzIHdlbGwgYXMgYGNoZWNrYm94YCBhbmQgYHJhZGlvYCBhcmUgc3VwcG9ydGVkLlxuICpcbiAqICAgIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBpbnB1dCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQ+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWlucHV0PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gb2pReExqXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaW5wdXRcbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgYWRkaW5nLXBhZ2UtY29udGVudFxuICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pbnB1dCBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgZmxvYXQ+PC9vbnMtaW5wdXQ+XG4gKiA8b25zLWlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ+PC9vbnMtaW5wdXQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwbGFjZWhvbGRlclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGxhY2Vob2xkZXIgdGV4dC4gSW4gTWF0ZXJpYWwgRGVzaWduLCB0aGlzIHBsYWNlaG9sZGVyIHdpbGwgYmUgYSBmbG9hdGluZyBsYWJlbC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmbG9hdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBwcmVzZW50LCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBhbmltYXRlZCBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/mmYLjgIHjg6njg5njg6vjga/jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0eXBlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVxuICAgKiAgICBTcGVjaWZ5IHRoZSBpbnB1dCB0eXBlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBcInR5cGVcIiBhdHRyaWJ1dGUgZm9yIG5vcm1hbCBpbnB1dHMuIEhvd2V2ZXIsIGZvciBcInJhbmdlXCIgeW91IHNob3VsZCBpbnN0ZWFkIHVzZSA8b25zLXJhbmdlPiBlbGVtZW50LlxuICAgKlxuICAgKiAgICBQbGVhc2UgdGFrZSBhIGxvb2sgYXQgW01ETl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItdHlwZSkgZm9yIGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMuIERlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0gYW5kIGJyb3dzZXIgdmVyc2lvbiBzb21lIG9mIHRoZXNlIG1pZ2h0IG5vdCB3b3JrLlxuICAgKiAgWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyA8bGFiZWwgZm9yPVwiLi4uXCI+IGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2NoZWNrZWQnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNpbiA9IHRoaXMuX29uRm9jdXNpbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGhlbHBlci5jbGFzc0xpc3QuYWRkKCdfaGVscGVyJyk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcblxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2lucHV0LWxhYmVsJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KSk7XG4gICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENoZWNrYm94Q2xhc3MpO1xuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCdjaGVja2JveF9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19jaGVja21hcmsnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0UmFkaW9CdXR0b25DbGFzcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9fY2hlY2ttYXJrJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fbGFiZWwnKTtcbiAgICAgICAgdGhpcy5faW5wdXQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19jb250YWluZXInKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcbiAgICAgIHRoaXMuX2lucHV0LmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lucHV0LWlkJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncGxhY2Vob2xkZXInLCAnaW5wdXQtaWQnLCAnY2hlY2tlZCcsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwbGFjZWhvbGRlcic6XG4gICAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlTGFiZWwoKSk7XG4gICAgICBjYXNlICdpbnB1dC1pZCc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5pZCA9IGN1cnJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2hlY2tib3hDbGFzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2hlY2tib3hDbGFzcyArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRSYWRpb0J1dHRvbkNsYXNzKSkge1xuICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRSYWRpb0J1dHRvbkNsYXNzICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lucHV0LnR5cGUgIT09ICdjaGVja2JveCcgJiYgdGhpcy5faW5wdXQudHlwZSAhPT0gJ3JhZGlvJykge1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX3NldExhYmVsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsKCkge1xuICAgIHRoaXMuX3NldExhYmVsKHRoaXMuaGFzQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgOiAnJyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoWydjaGVja2JveCcsICdyYWRpbyddLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkgPT09IC0xKXtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWxlZ2F0ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICBfb25JbnB1dChldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgfVxuXG4gIF9vbkZvY3VzaW4oZXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuX2hlbHBlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0ID09PSBudWxsXG4gICAgICA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICA6IHRoaXMuX2lucHV0LnZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGNoZWNrZWQgb3Igbm90LiBPbmx5IHdvcmtzIGZvciBgcmFkaW9gIGFuZCBgY2hlY2tib3hgIHR5cGUgaW5wdXRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBnZXQgX2lzVGV4dElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09ICdyYWRpbycgJiYgdGhpcy50eXBlICE9PSAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydjaGFuZ2UnLCAnaW5wdXQnLCAnZm9jdXMnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdibHVyJ107XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaW5wdXQnLCBJbnB1dEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZU1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBNb2RhbEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ21vZGFsLS0qJyxcbiAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xufTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdtb2RhbCc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBNb2RhbCBjb21wb25lbnQgdGhhdCBtYXNrcyBjdXJyZW50IHNjcmVlbi4gVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAqICAgWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5U2hvdygpKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIG1vZGFsIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44Gu6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc01vZGFsRWxlbWVudC5Nb2RhbEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBNb2RhbEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBNb2RhbEFuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW1vZGFsJywgTW9kYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgZHVyYXRpb246ICcwLjQnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGJsb2NrKHBhZ2UpIHtcbiAgICBjb25zdCBibG9ja2VyID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyB6LWluZGV4OiAxMDAwMDBcIj48L2Rpdj5cbiAgICBgKTtcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYmxvY2tlcik7XG4gICAgcmV0dXJuICgpID0+IGJsb2NrZXIucmVtb3ZlKCk7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgb3BhY2l0eTogMDsgei1pbmRleDogMlwiPjwvZGl2PlxuICAgIGApO1xuXG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFyID0gcGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gdG9vbGJhci5fZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKTtcbiAgICBjb25zdCByaWdodCA9IHRvb2xiYXIuX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpO1xuXG4gICAgY29uc3QgZXhjbHVkZUJhY2tCdXR0b24gPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b24obGVmdC5jaGlsZHJlbikpXG4gICAgICAuY29uY2F0KHJpZ2h0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHJpZ2h0IDogZXhjbHVkZUJhY2tCdXR0b24ocmlnaHQuY2hpbGRyZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyQ2VudGVyOiB0b29sYmFyLl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uSWNvbjogdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpLFxuICAgICAgYmFja0J1dHRvbkxhYmVsOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpLFxuICAgICAgb3RoZXI6IG90aGVyLFxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgIGJhY2tncm91bmQ6IHBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCksXG4gICAgICB0b29sYmFyOiB0b29sYmFyLFxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgIH07XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICBjb25zdCBib3RoUGFnZUhhc1Rvb2xiYXIgPVxuICAgICAgZW50ZXJQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpICYmIGxlYXZlUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKTtcblxuICAgIHZhciBub01hdGVyaWFsVG9vbGJhciA9XG4gICAgICAhZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJykgJiZcbiAgICAgICFsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXZpZ2F0aW9uLWJhci0tbWF0ZXJpYWwnKTtcblxuICAgIHJldHVybiBib3RoUGFnZUhhc1Rvb2xiYXIgJiYgbm9NYXRlcmlhbFRvb2xiYXI7XG4gIH1cblxuICBfY2FsY3VsYXRlRGVsdGEoZWxlbWVudCwgZGVjb21wb3NpdGlvbikge1xuICAgIGxldCB0aXRsZSwgbGFiZWw7XG5cbiAgICBjb25zdCBwYWdlUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsUmVjdCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKChwYWdlUmVjdC53aWR0aCAvIDIpIC0gKGxhYmVsUmVjdC53aWR0aCAvIDIpIC0gbGFiZWxSZWN0LmxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQoKHBhZ2VSZWN0LndpZHRoIC8gMikgKiAwLjYpO1xuICAgIH1cblxuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgbGFiZWwgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4ge3RpdGxlLCBsYWJlbH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29udGVudFJlYWR5KGVudGVyUGFnZSwgKCkgPT4ge1xuICAgICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2UpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBmaXhcbiAgICAgICAgY29uc3QgZW50ZXJQYWdlVG9vbGJhckhlaWdodCA9IGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnN0eWxlLnRvcCA9IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQ7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmQpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGVudGVyUGFnZVRvb2xiYXJIZWlnaHRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTI1JSwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuXG4gICAgICAgICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZSk7XG4gICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGxlYXZlUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAuc2F2ZVN0eWxlKClcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDAuMSxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuXG4gICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICBjb25zdCBlbnRlclBhZ2VUb29sYmFySGVpZ2h0ID0gZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArICdweCc7XG4gICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnN0eWxlLnRvcCA9IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQ7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmQpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0b3A6IGVudGVyUGFnZVRvb2xiYXJIZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KDApXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTI1JSwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KFtlbnRlclBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIGVudGVyUGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKV0pXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIGxlYXZlUGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKV0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwO1wiPjwvZGl2PlxuICAgIGApO1xuICAgIHRoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAud2FpdCgwLjIpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5LFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTQ1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJywgZGVsYXkgPSAwLjA1LCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1wiPjwvZGl2PlxuICAgIGApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogRmFkZS1pbiArIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjI1fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDQycHgsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4xNSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMDQpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9pb3MtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2lvcy1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbWQtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLWxpZnQtYW5pbWF0b3InO1xuaW1wb3J0IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9ub25lLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCB7UGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXIsIGluc3RhbnRQYWdlTG9hZGVyfSBmcm9tICcuLi8uLi9vbnMvcGFnZS1sb2FkZXInO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZS1pb3MnOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlLW1kJzogTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQtbWQnOiBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbm9uZSc6IE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Jcbn07XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkobmF2aWdhdG9yRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1uYXZpZ2F0b3JcbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcGFnZSBzdGFjayBtYW5hZ2VtZW50IGFuZCBuYXZpZ2F0aW9uLiBTdGFjayBuYXZpZ2F0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbiBuYXZpZ2F0aW9uIHBhdHRlcm4gZm9yIG1vYmlsZSBhcHBzLlxuICpcbiAqICAgICBXaGVuIGEgcGFnZSBpcyBwdXNoZWQgb24gdG9wIG9mIHRoZSBzdGFjayBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gYW5pbWF0aW9uLiBXaGVuIHRoZSB1c2VyIHJldHVybnMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgdGhlIHRvcCBwYWdlIHdpbGwgYmUgcG9wcGVkIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIGhpZGRlbiB3aXRoIGFuIG9wcG9zaXRlIHRyYW5zaXRpb24gYW5pbWF0aW9uLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHlyaHR2XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbmF2aWdhdG9yXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgIFtlbl1HdWlkZSBmb3IgcGFnZSBuYXZpZ2F0aW9uWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOODiuODk+OCsuODvOOCt+ODp+ODs+OBruamguimgVsvamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAZ3VpZGUgY3JlYXRpbmctYS1wYWdlXG4gKiAgIFtlbl1TZXR0aW5nIHVwIGEgcGFnZSBpbiBpdHMgYGluaXRgIGV2ZW50Wy9lbl1cbiAqICAgW2phXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBBbm90aGVyIHBhZ2VcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvb25zLXRvb2xiYXI+XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBhbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fcGFnZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7UGFnZUxvYWRlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVBhZ2VMb2FkZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLmoLzntI3jgZfjgabjgYTjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihwYWdlTG9hZGVyKSB7XG4gICAgaWYgKCEocGFnZUxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIHthbmltYXRpb246ICdub25lJ30pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGFnZXNbaV0ubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNoaWxkcmVuIG9mIDxvbnMtbmF2aWdhdG9yPiBuZWVkIHRvIGJlIG9mIHR5cGUgPG9ucy1wYWdlPicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcy50b3BQYWdlLCAoKSA9PlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcbiAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSwge2FuaW1hdGlvbjogJ25vbmUnfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnYW5pbWF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcG9wUGFnZVxuICAgKiBAc2lnbmF0dXJlIHBvcFBhZ2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVmcmVzaF1cbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXVxuICAgKiAgIFtlbl1DdXN0b20gZGF0YSB0aGF0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJldmVhbGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5piO44KJ44GL44Gr44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Qb3BzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgcGFnZSBzdGFjay4gVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44GL44KJ5Y+W44KK6Zmk44GN44G+44GZ44CC5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KK44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHBvcFBhZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhudWxsLCBvcHRpb25zKSk7XG5cbiAgICBjb25zdCBwb3BVcGRhdGUgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9wUGFnZUFuZFJlZnJlc2gob3B0aW9ucywgcG9wVXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICBfcG9wUGFnZUFuZFJlZnJlc2gob3B0aW9ucywgcG9wVXBkYXRlKSB7XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMjtcbiAgICBjb25zdCBvbGRQYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoIXRoaXMuX3BhZ2VNYXAuaGFzKG9sZFBhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcGFnZXMgZGlyZWN0bHkgaW5zaWRlIHRoZSBOYXZpZ2F0b3IuIFVzZSBvbnMtdGVtcGxhdGUgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlID0gdGhpcy5fcGFnZU1hcC5nZXQob2xkUGFnZSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgIHBhcmFtczogb2xkUGFnZS5wdXNoZWRPcHRpb25zID8gb2xkUGFnZS5wdXNoZWRPcHRpb25zLmRhdGEgOiB7fVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fcGFnZU1hcC5zZXQocGFnZUVsZW1lbnQsIHBhZ2UpO1xuXG4gICAgICAgIHBhZ2VFbGVtZW50ID0gdXRpbC5leHRlbmQocGFnZUVsZW1lbnQsIHtcbiAgICAgICAgICBkYXRhOiBvbGRQYWdlLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb2xkUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCBvbGRQYWdlID8gb2xkUGFnZSA6IG51bGwpO1xuICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRQYWdlKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG5cbiAgICB9KS50aGVuKCgpID0+IHRoaXMuX3BvcFBhZ2Uob3B0aW9ucywgcG9wVXBkYXRlKSk7XG5cbiAgfVxuXG4gIF9wb3BQYWdlKG9wdGlvbnMsIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwb3BQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdvbnMtbmF2aWdhdG9yXFwncyBwYWdlIHN0YWNrIGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUG9wRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwb3AgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5wYWdlc1tsZW5ndGggLSAyXS51cGRhdGVCYWNrQnV0dG9uKChsZW5ndGggLSAyKSA+IDApO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGVudGVyUGFnZSA9IHRoaXMucGFnZXNbbGVuZ3RoIC0gMl07XG5cbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gfHwgKGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zID8gbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMuYW5pbWF0aW9uIDogdW5kZWZpbmVkKTtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMgPyBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb25PcHRpb25zIDoge30sXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cG9wJywge2xlYXZlUGFnZSwgZW50ZXJQYWdlLCBuYXZpZ2F0b3I6IHRoaXN9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuICAgICAgYW5pbWF0b3IucG9wKHRoaXMucGFnZXNbbGVuZ3RoIC0gMl0sIHRoaXMucGFnZXNbbGVuZ3RoIC0gMV0sIGNhbGxiYWNrKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHB1c2hQYWdlXG4gICAqIEBzaWduYXR1cmUgcHVzaFBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhIEhUTUwgZG9jdW1lbnQgb3IgYSB0ZW1wbGF0ZSBkZWZpbmVkIHdpdGggdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZV1cbiAgICogICBbZW5dUGFnZSBVUkwuIE9ubHkgbmVjZXNzYXJ5IGlmIGBwYWdlYCBwYXJhbWV0ZXIgaXMgbnVsbCBvciB1bmRlZmluZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VIVE1MXVxuICAgKiAgIFtlbl1IVE1MIGNvZGUgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGFzIGEgbmV3IHBhZ2UuIE92ZXJ3cml0ZXMgYHBhZ2VgIHBhcmFtZXRlci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFdcHVzaFBhZ2UoKeOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXVxuICAgKiAgIFtlbl1DdXN0b20gZGF0YSB0aGF0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHB1c2hlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXei/veWKoOOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUHVzaGVzIHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS5paw44GX44GE44Oa44O844K444K544K/44OD44Kv44Gr6L+95Yqg44GX44G+44GZ44CC5paw44GX44GE44Oa44O844K444GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICh7cGFnZSwgb3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuXG4gICAgY29uc3QgcHJlcGFyZSA9IHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgIHRoaXMuX3ZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICAgIHRoaXMuX3BhZ2VNYXAuc2V0KHBhZ2VFbGVtZW50LCBwYWdlKTtcbiAgICAgIHBhZ2VFbGVtZW50ID0gdXRpbC5leHRlbmQocGFnZUVsZW1lbnQsIHtcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gICAgICB9KTtcbiAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucGFnZUhUTUwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgaW5zdGFudFBhZ2VMb2FkZXIubG9hZCh7cGFnZTogb3B0aW9ucy5wYWdlSFRNTCwgcGFyZW50OiB0aGlzLCBwYXJhbXM6IG9wdGlvbnMuZGF0YX0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICBwcmVwYXJlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzLCBwYXJhbXM6IG9wdGlvbnMuZGF0YX0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcHJlcGFyZShwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIF9wdXNoUGFnZShvcHRpb25zID0ge30sIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSk7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIHthbmltYXRpb25PcHRpb25zfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgIHJldHVybiB1cGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2VMZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgICAgY29uc3QgZW50ZXJQYWdlICA9IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbGVhdmVQYWdlID0gb3B0aW9ucy5sZWF2ZVBhZ2UgfHwgdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMl07XG5cbiAgICAgIGlmIChlbnRlclBhZ2Uubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGVsZW1lbnRzIG9mIHR5cGUgPG9ucy1wYWdlPiBjYW4gYmUgcHVzaGVkIHRvIHRoZSBuYXZpZ2F0b3InKTtcbiAgICAgIH1cblxuICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24ocGFnZUxlbmd0aCAtIDEpO1xuXG4gICAgICBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyB8fCB7fSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS51bmxvYWQgPSBlbnRlclBhZ2UudW5sb2FkIHx8IG9wdGlvbnMudW5sb2FkO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gZW50ZXJQYWdlLl9zaG93KCkpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHB1c2gnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGVyUGFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgICAgICBhbmltYXRvci5wdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXG4gICAqIEBzaWduYXR1cmUgcmVwbGFjZVBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNvbHZlZFZhbHVlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW5zZXJ0UGFnZVxuICAgKiBAc2lnbmF0dXJlIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44Gr5oy/5YWl44GZ44KL5L2N572u44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaW5zZXJ0ZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluc2VydCB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2sgd2l0aCBhdCBhIHBvc2l0aW9uIGRlZmluZWQgYnkgdGhlIGBpbmRleGAgYXJndW1lbnQuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBrmluZGV444Gn5oyH5a6a44GX44Gf5L2N572u44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICh7cGFnZSwgb3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ID49IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBwYWdlID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5wYWdlSFRNTCA6IHBhZ2U7XG4gICAgY29uc3QgbG9hZGVyID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gaW5zdGFudFBhZ2VMb2FkZXIgOiB0aGlzLl9wYWdlTG9hZGVyO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICAgIHBhZ2VFbGVtZW50ID0gdXRpbC5leHRlbmQocGFnZUVsZW1lbnQsIHtcbiAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShwYWdlRWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbih0cnVlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZ2VzWzBdLnVwZGF0ZUJhY2tCdXR0b24oZmFsc2UpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLnBhZ2UgJiYgIW9wdGlvbnMucGFnZUhUTUwgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXG4gICAqIEBzaWduYXR1cmUgYnJpbmdQYWdlVG9wKGl0ZW0sIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtXG4gICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GuVVJM44GL44KC44GX44GP44Gvb25zLW5hdmlnYXRvcuOBruODmuODvOOCuOOCueOCv+ODg+OCr+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJyaW5ncyB0aGUgZ2l2ZW4gcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHN0YWNrIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyBpdCBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBruS4gOeVquS4iuOBq+enu+WLleOBl+OBvuOBmeOAguOCguOBl+aMh+WumuOBl+OBn+ODmuODvOOCuOOBjOeEoeOBi+OBo+OBn+WgtOWQiOaWsOOBl+OBj3B1c2jjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgYnJpbmdQYWdlVG9wKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChbJ251bWJlcicsICdzdHJpbmcnXS5pbmRleE9mKHR5cGVvZiBpdGVtKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBhZ2UgbmFtZSBvciB0aGUgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZS4gWW91IHN1cHBsaWVkICcgKyBpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgPyB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKSA6IHRoaXMuX2xhc3RJbmRleE9mUGFnZShpdGVtKTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGl0ZW0gJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHBhZ2Uuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIHBhZ2Uuc2V0QXR0cmlidXRlKCdfc2tpcGluaXQnLCAnJyk7XG4gICAgcGFnZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHBhZ2UpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zKTtcbiAgfVxuXG4gIF9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKChwYWdlID09PSBudWxsIHx8IHBhZ2UgPT09IHVuZGVmaW5lZCkgJiYgb3B0aW9ucy5wYWdlKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zLCB7cGFnZX0pO1xuXG4gICAgcmV0dXJuIHtwYWdlLCBvcHRpb25zfTtcbiAgfVxuXG4gIF91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucGFnZXNbaW5kZXhdLnVwZGF0ZUJhY2tCdXR0b24oaW5kZXggPiAwKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5hYnModGhpcy5wYWdlcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBvcFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cblxuICBfbGFzdEluZGV4T2ZQYWdlKHBhZ2VOYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIGZvciAoaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGlmICghdGhpcy5fcGFnZU1hcC5oYXModGhpcy5wYWdlc1tpbmRleF0pKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdUaGlzIGlzIGJ1Zy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VOYW1lID09PSB0aGlzLl9wYWdlTWFwLmdldCh0aGlzLnBhZ2VzW2luZGV4XSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIF9lbWl0UHJlRXZlbnQobmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlJyArIG5hbWUsIHV0aWwuZXh0ZW5kKHtcbiAgICAgIG5hdmlnYXRvcjogdGhpcyxcbiAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0sXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSwgZGF0YSkpO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfZW1pdFByZVB1c2hFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwdXNoJyk7XG4gIH1cblxuICBfZW1pdFByZVBvcEV2ZW50KCkge1xuICAgIGNvbnN0IGwgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwb3AnLCB7XG4gICAgICBsZWF2ZVBhZ2U6IHRoaXMucGFnZXNbbCAtIDFdLFxuICAgICAgZW50ZXJQYWdlOiB0aGlzLnBhZ2VzW2wgLSAyXVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzog5pu444GN55u044GZXG4gIF9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpIHtcbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCh0ZW1wbGF0ZUhUTUwpKTtcbiAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgcmV0dXJuIHBhZ2VFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgX3ZlcmlmeVBhZ2VFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXBhZ2UnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBcIm9ucy1wYWdlXCIgZWxlbWVudCB0byBcIm9ucy1uYXZpZ2F0b3JcIi4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdG9wUGFnZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB0b3AgcGFnZSBlbGVtZW50LiBVc2UgdGhpcyBtZXRob2QgdG8gYWNjZXNzIG9wdGlvbnMgcGFzc2VkIGJ5IGBwdXNoUGFnZSgpYC1saWtlIG1ldGhvZHMuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oa44O844K444KS5Y+W5b6X44GX44G+44GZ44CCcHVzaFBhZ2UoKeOChHJlc2V0VG9QYWdlKCnjg6Hjgr3jg4Pjg4njga7lvJXmlbDjgpLlj5blvpfjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlc1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29weSBvZiB0aGUgbmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09OUy1QQUdFJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURlZmF1bHQgb3B0aW9ucyBvYmplY3QuIEF0dHJpYnV0ZXMgaGF2ZSBwcmlvcml0eSBvdmVyIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLnJlZnJlc2hcbiAgICogQGRlZmF1bHQgIGZhbHNlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwYXJhbWV0ZXIgaXMgYHRydWVgLCB0aGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgYHBvcFBhZ2UoKWAgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICBzZXQgX2lzUnVubmluZyh2YWx1ZSkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gIH1cbiAgZ2V0IF9pc1J1bm5pbmcoKSB7XG4gICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnKSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICB0aGlzLnRvcFBhZ2UuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICB0aGlzLnRvcFBhZ2UuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgTmF2aWdhdG9yRWxlbWVudC5OYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3InKTtcbiAgICB9XG5cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKCkge1xuICAgIHJldHVybiBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVwdXNoJywgJ3Bvc3RwdXNoJywgJ3ByZXBvcCcsICdwb3N0cG9wJ107XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1uYXZpZ2F0b3InLCBOYXZpZ2F0b3JFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbmF2aWdhdGlvbi1iYXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnbmF2aWdhdGlvbi1iYXItLSonLFxuICAnLm5hdmlnYXRpb24tYmFyX19sZWZ0JzogJ25hdmlnYXRpb24tYmFyLS0qX19sZWZ0JyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fY2VudGVyJzogJ25hdmlnYXRpb24tYmFyLS0qX19jZW50ZXInLFxuICAnLm5hdmlnYXRpb24tYmFyX19yaWdodCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fcmlnaHQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dVHJhbnNwYXJlbnQgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vc2hhZG93XG4gKiAgIFtlbl1Ub29sYmFyIHdpdGhvdXQgc2hhZG93Wy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBq+W9seOCkuS7mOOBkeOBmuOBq+ihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGFkZGluZy1hLXRvb2xiYXIgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLWJvdHRvbS10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgIFRpdGxlXG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKiA8L29ucy1wYWdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgdGhlIHRvb2xiYXIgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9faWNvbicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX190aXRsZScpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnbGVmdCcpO1xuICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgncmlnaHQnKTtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5uYXZpZ2F0aW9uLWJhcl9fJyArIG5hbWUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5uYXZpZ2F0aW9uLWJhcl9fJyArIG5hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuJyArIG5hbWUpIHx8IHV0aWwuY3JlYXRlKCcuJyArIG5hbWUpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXInLCBUb29sYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmltcG9ydCAnLi9vbnMtdG9vbGJhcic7IC8vIGVuc3VyZXMgdGhhdCAnb25zLXRvb2xiYXInIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZFxuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3BhZ2UnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3BhZ2UtLSonLFxuICAnLnBhZ2VfX2NvbnRlbnQnOiAncGFnZS0tKl9fY29udGVudCcsXG4gICcucGFnZV9fYmFja2dyb3VuZCc6ICdwYWdlLS0qX19iYWNrZ3JvdW5kJ1xufTtcblxuY29uc3QgbnVsbFRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXRvb2xiYXInKTsgLy8gcmVxdWlyZXMgdGhhdCAnb25zLXRvb2xiYXInIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZFxuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wYWdlXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGVmaW5lcyB0aGUgcm9vdCBvZiBlYWNoIHBhZ2UuIElmIHRoZSBjb250ZW50IGlzIGxhcmdlIGl0IHdpbGwgYmVjb21lIHNjcm9sbGFibGUuXG4gKlxuICogICAgIEEgbmF2aWdhdGlvbiBiYXIgY2FuIGJlIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgdXNpbmcgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wYWdlXG4gKiBAZ3VpZGUgY3JlYXRpbmctYS1wYWdlXG4gKiAgIFtlbl1TZXR0aW5nIHVwIGEgcGFnZSBpbiBpdHMgYGluaXRgIGV2ZW50Wy9lbl1cbiAqICAgW2phXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1Vc2UgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50IHRvIGFkZCBhIG5hdmlnYXRpb24gYmFyIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPHA+UGFnZSBjb250ZW50PC9wPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogPHNjcmlwdD5cbiAqICAgbXlBcHAuaGFuZGxlciA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBsb2FkTW9yZSgpLnRoZW4oZG9uZSk7XG4gKiAgIH1cbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxvbnMtcGFnZSBvbi1pbmZpbml0ZS1zY3JvbGw9XCJteUFwcC5oYW5kbGVyXCI+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+TGlzdDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPG9ucy1saXN0PlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMxPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMyPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMzPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIC4uLlxuICogICA8L29ucy1saXN0PlxuICogPC9vbnMtcGFnZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBpbml0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBhdHRhY2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzjgqLjgr/jg4Pjg4HjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIHNob3duLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOihqOekuuOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgZGVzdHJveVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYmVmb3JlIHRoZSBwYWdlIGlzIGRlc3Ryb3llZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYznoLTmo4TjgZXjgozjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBtb2RpZmllciBuYW1lIHRvIHNwZWNpZnkgY3VzdG9tIHN0eWxlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jgqTjg6vlrprnvqnjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovjgZ/jgoHjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvbi1pbmZpbml0ZS1zY3JvbGxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhdGggb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIGluZmluaXRlIHNjcm9sbGluZy4gRXhhbXBsZTogYGFwcC5sb2FkRGF0YWAuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XG4gICAgICB0aGlzLl9za2lwSW5pdCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBJbml0KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50KHRoaXMpKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90cnlUb0ZpbGxTdGF0dXNCYXIoKTtcblxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnb24taW5maW5pdGUtc2Nyb2xsJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUJhY2tCdXR0b24oc2hvdykge1xuICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgbmFtZShzdHIpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHN0cik7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgX3RyeVRvRmlsbFN0YXR1c0Jhcigpe1xuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgIWZpbGxlZCAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoKSB8fCAhdGhpcy5faGFzQVBhZ2VDb250cm9sQ2hpbGQoKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhc0FQYWdlQ29udHJvbENoaWxkKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZSA9PiBlLm5vZGVOYW1lLm1hdGNoKC9vbnMtKHNwbGl0dGVyfHNsaWRpbmctbWVudXxuYXZpZ2F0b3J8dGFiYmFyKS9pKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uSW5maW5pdGVTY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudCB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgb25JbmZpbml0ZVNjcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25JbmZpbml0ZVNjcm9sbCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX29uSW5maW5pdGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9jb250ZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKSk7XG4gICAgfVxuICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBvbkluZmluaXRlU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkluZmluaXRlU2Nyb2xsO1xuICB9XG5cbiAgX29uU2Nyb2xsKCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLl9jb250ZW50RWxlbWVudCxcbiAgICAgIG92ZXJMaW1pdCA9IChjLnNjcm9sbFRvcCArIGMuY2xpZW50SGVpZ2h0KSAvIGMuc2Nyb2xsSGVpZ2h0ID49IHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQ7XG5cbiAgICBpZiAodGhpcy5fb25JbmZpbml0ZVNjcm9sbCAmJiAhdGhpcy5fbG9hZGluZ0NvbnRlbnQgJiYgb3ZlckxpbWl0KSB7XG4gICAgICB0aGlzLl9sb2FkaW5nQ29udGVudCA9IHRydWU7XG4gICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsKCgpID0+IHRoaXMuX2xvYWRpbmdDb250ZW50ID0gZmFsc2UpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2NvbnRlbnRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfY2FuQW5pbWF0ZVRvb2xiYXIoKSB7XG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEhdXRpbC5maW5kQ2hpbGQodGhpcy5fY29udGVudEVsZW1lbnQsIGVsID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGVsLCAnb25zLXRvb2xiYXInKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignZmFpbCB0byBnZXQgXCIucGFnZV9fYmFja2dyb3VuZFwiIGVsZW1lbnQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtYm90dG9tLXRvb2xiYXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSB8fCBudWxsVG9vbGJhckVsZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdfbXV0ZWQnLCAnX3NraXBpbml0JywgJ29uLWluZmluaXRlLXNjcm9sbCcsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZSArICcgJyArIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ19tdXRlZCc6XG4gICAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnX3NraXBpbml0JzpcbiAgICAgICAgdGhpcy5fc2tpcEluaXQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb24taW5maW5pdGUtc2Nyb2xsJzpcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IChkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gdXRpbC5maW5kRnJvbVBhdGgoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgICAgZihkb25lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpKSB7XG4gICAgICB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmNvbnRlbnQnKS5jbGFzc0xpc3QuYWRkKCdwYWdlX19jb250ZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpKSB7XG4gICAgICB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2tncm91bmQnKS5jbGFzc0xpc3QuYWRkKCdwYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuY3JlYXRlKCcucGFnZV9fY29udGVudCcpO1xuXG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxIHx8IHRoaXMuX2VsZW1lbnRTaG91bGRCZU1vdmVkKG5vZGUpKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByZXZOb2RlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykgfHwgdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJyk7XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIHByZXZOb2RlICYmIHByZXZOb2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kID0gdXRpbC5jcmVhdGUoJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShiYWNrZ3JvdW5kLCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKSk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2VsZW1lbnRTaG91bGRCZU1vdmVkKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgPT09ICdvbnMtZmFiJykge1xuICAgICAgcmV0dXJuICFlbC5oYXNBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBbJ29ucy10b29sYmFyJywgJ29ucy1ib3R0b20tdG9vbGJhcicsICdvbnMtbW9kYWwnLCAnb25zLXNwZWVkLWRpYWwnLCAnb25zLWRpYWxvZycsICdvbnMtYWxlcnQtZGlhbG9nJywgJ29ucy1wb3BvdmVyJ107XG4gICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykgfHwgZml4ZWRFbGVtZW50cy5pbmRleE9mKHRhZ05hbWUpID09PSAtMTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biAmJiB1dGlsLmlzQXR0YWNoZWQodGhpcykpIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdzaG93Jyk7XG4gICAgICB9XG5cbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMuX2NvbnRlbnRFbGVtZW50LCAnX3Nob3cnKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdoaWRlJyk7XG4gICAgICB9XG5cbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMuX2NvbnRlbnRFbGVtZW50LCAnX2hpZGUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9uRGV2aWNlQmFja0J1dHRvbikge1xuICAgICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMuX2NvbnRlbnRFbGVtZW50LCAnX2Rlc3Ryb3knKTtcblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydpbml0JywgJ3Nob3cnLCAnaGlkZScsICdkZXN0cm95J107XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRhdGFcbiAgICogQHR5cGUgeyp9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VyJ3MgY3VzdG9tIGRhdGEgcGFzc2VkIHRvIGBwdXNoUGFnZSgpYC1saWtlIG1ldGhvZHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXBhZ2UnLCBQYWdlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIF9hbmltYXRlKGVsZW1lbnQsIHtmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2ssIHJlc3RvcmUgPSBmYWxzZSwgYW5pbWF0aW9ufSkge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgIGZyb20gPSBhbmltYXRpb24uZnJvbTtcbiAgICAgIHRvID0gYW5pbWF0aW9uLnRvO1xuICAgIH1cblxuICAgIGFuaW1hdGlvbiA9IGFuaW1pdChlbGVtZW50KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnNhdmVTdHlsZSgpO1xuICAgIH1cbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoZnJvbSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICBjc3M6IHRvLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgfSk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5yZXN0b3JlU3R5bGUoKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoKGRvbmUpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBfYW5pbWF0ZUFsbChlbGVtZW50LCBhbmltYXRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9ucykuZm9yRWFjaChrZXkgPT4gdGhpcy5fYW5pbWF0ZShlbGVtZW50W2tleV0sIGFuaW1hdGlvbnNba2V5XSkucGxheSgpKTtcbiAgfVxuXG59XG5cbmNvbnN0IGZhZGUgPSB7XG4gIG91dDoge1xuICAgIGZyb206IHtvcGFjaXR5OiAxLjB9LFxuICAgIHRvOiB7b3BhY2l0eTogMH1cbiAgfSxcbiAgaW46IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMH0sXG4gICAgdG86IHtvcGFjaXR5OiAxLjB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBNREZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLmluLCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLm91dCxcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLm91dCwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBNREZhZGVQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7UG9wb3ZlckFuaW1hdG9yLCBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLCBNREZhZGVQb3BvdmVyQW5pbWF0b3J9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRhaW5lcic6ICdwb3BvdmVyX19jb250YWluZXItLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlcl9fY29udGVudC0tKicsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlcl9fYXJyb3ctLSonXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3BvcG92ZXInO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCB0ZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoYFxuICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1tYXNrXCI+PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGVudFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19hcnJvd1wiPjwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIGRpYWxvZ3NcbiAqICBbZW5dRGlhbG9nIGNvbXBvbmVudHNbL2VuXVxuICogIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfcG9wb3ZlcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wb3BvdmVyX19jb250YWluZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl9pbml0QW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gKCkgPT4gdGhpcy5fY2FuY2VsKCk7XG4gIH1cblxuICBfaW5pdEFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFBvcG92ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdQb3BvdmVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpIHx8ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIHRoaXMuX2FuaW1hdG9yID0gKG9wdGlvbnMpID0+IGZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gIH1cblxuICBfcG9zaXRpb25Qb3BvdmVyKHRhcmdldCkge1xuICAgIGNvbnN0IHtfcmFkaXVzOiByYWRpdXMsIF9jb250ZW50OiBlbCwgX21hcmdpbjogbWFyZ2lufSA9IHRoaXM7XG4gICAgY29uc3QgcG9zID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGlzTUQgPSB1dGlsLmhhc01vZGlmaWVyKHRoaXMsICdtYXRlcmlhbCcpO1xuICAgIGNvbnN0IGNvdmVyID0gaXNNRCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnY292ZXItdGFyZ2V0Jyk7XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogcG9zLnRvcCAtIG1hcmdpbixcbiAgICAgIGxlZnQ6IHBvcy5sZWZ0IC0gbWFyZ2luLFxuICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIC0gcG9zLnJpZ2h0IC0gbWFyZ2luLFxuICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3MuYm90dG9tIC0gbWFyZ2luXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeSwgc2Vjb25kYXJ5fSA9IHRoaXMuX2NhbGN1bGF0ZURpcmVjdGlvbnMoZGlzdGFuY2UpO1xuICAgIHRoaXMuX3BvcG92ZXIuY2xhc3NMaXN0LmFkZCgncG9wb3Zlci0tJyArIHByaW1hcnkpO1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gY292ZXIgPyAwIDogKHZlcnRpY2FsID8gcG9zLmhlaWdodCA6IHBvcy53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgdGhpcy5zdHlsZVtwcmltYXJ5XSA9IE1hdGgubWF4KDAsIGRpc3RhbmNlW3ByaW1hcnldICsgb2Zmc2V0KSArIG1hcmdpbiArICdweCc7XG4gICAgZWwuc3R5bGVbcHJpbWFyeV0gPSAwO1xuXG4gICAgY29uc3QgbCA9IHZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIGNvbnN0IHNpemVzID0gKHN0eWxlID0+ICh7XG4gICAgICB3aWR0aDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xuXG4gICAgZWwuc3R5bGVbc2Vjb25kYXJ5XSA9IE1hdGgubWF4KDAsIGRpc3RhbmNlW3NlY29uZGFyeV0gLSAoc2l6ZXNbbF0gLSBwb3NbbF0pIC8gMikgKyAncHgnO1xuICAgIHRoaXMuX2Fycm93LnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heChyYWRpdXMsIGRpc3RhbmNlW3NlY29uZGFyeV0gKyBwb3NbbF0gLyAyKSArICdweCc7XG5cbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpO1xuXG4gICAgLy8gUHJldmVudCBhbmltaXQgZnJvbSByZXN0b3JpbmcgdGhlIHN0eWxlLlxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltaXQtb3JpZy1zdHlsZScpO1xuICB9XG5cbiAgX3NldFRyYW5zZm9ybU9yaWdpbihkaXN0YW5jZSwgc2l6ZXMsIHBvcywgcHJpbWFyeSkge1xuICAgIGNvbnN0IGNhbGMgPSAoYSwgbywgbCkgPT4gcHJpbWFyeSA9PT0gYSA/IHNpemVzW2xdIC8gMiA6IGRpc3RhbmNlW2FdICsgKHByaW1hcnkgPT09IG8gPyAtc2l6ZXNbbF0gOiBzaXplc1tsXSAtIHBvc1tsXSkgLyAyO1xuICAgIGNvbnN0IFt4LCB5XSA9IFtjYWxjKCdsZWZ0JywgJ3JpZ2h0JywgJ3dpZHRoJykgKyAncHgnLCBjYWxjKCd0b3AnLCAnYm90dG9tJywgJ2hlaWdodCcpICsgJ3B4J107XG4gICAgdXRpbC5leHRlbmQodGhpcy5fcG9wb3Zlci5zdHlsZSwge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB4ICsgJyAnICsgeSxcbiAgICAgIHdlYmtpdFRyYW5zZm9ybU9yaWdpblg6IHgsXG4gICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5ZOiB5XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHByaW1hcnkpICE9PSAtMTtcbiAgICBsZXQgc2Vjb25kYXJ5O1xuXG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS5sZWZ0IDwgZGlzdGFuY2UucmlnaHQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS50b3AgPCBkaXN0YW5jZS5ib3R0b20gPyAndG9wJyA6ICdib3R0b20nO1xuICAgIH1cblxuICAgIHJldHVybiB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX07XG4gIH1cblxuICBfY2xlYXJTdHlsZXMoKSB7XG4gICAgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5fYXJyb3cuc3R5bGVbZV0gPSB0aGlzLl9jb250ZW50LnN0eWxlW2VdID0gdGhpcy5zdHlsZVtlXSA9ICcnO1xuICAgICAgdGhpcy5fcG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKGBwb3BvdmVyLS0ke2V9YCk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdwb3BvdmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBjb25zdCBoYXNEZWZhdWx0Q29udGFpbmVyID0gdGhpcy5fcG9wb3ZlciAmJiB0aGlzLl9jb250ZW50O1xuXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLW1hc2snKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9hcnJvdykge1xuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyX19hcnJvdycpO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgIShvcHRpb25zLmFuaW1hdGlvbiBpbiBfYW5pbWF0b3JEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRvciAke29wdGlvbnMuYW5pbWF0aW9ufSBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgKTtcbiAgfVxuXG4gIF9leGVjdXRlQWN0aW9uKGFjdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB7YWN0aW9uLCBiZWZvcmUsIGFmdGVyfSA9IGFjdGlvbnM7XG5cbiAgICB0aGlzLl9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBzeW5jaHJvbm91c1xuICAgICAgcG9wb3ZlcjogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG5cbiAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0b3Iob3B0aW9ucylbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhZnRlciAmJiBhZnRlcigpO1xuXG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwb3N0JHthY3Rpb259YCwge3BvcG92ZXI6IHRoaXN9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyh0YXJnZXQsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR8SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC4gQ2FuIGJlIGVpdGhlciBhIENTUyBzZWxlY3RvciwgYW4gZXZlbnQgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuIEl0IGNhbiBiZSBhbHNvIHByb3ZpZGVkIGFzICdvcHRpb25zLnRhcmdldCcgaW5zdGVhZC4gWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44K/44O844Ky44OD44OI44Go44Gq44KL6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCQ1NT44K744Os44Kv44K/44GLZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgYtET03opoHntKDjga7jgYTjgZrjgozjgYvjgpLmuKHjgZvjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gdGhlIHBvcG92ZXIgYW5kIHBvaW50IGl0IGF0IGEgdGFyZ2V0LiBUaGUgdGFyZ2V0IGNhbiBiZSBlaXRoZXIgYW4gZXZlbnQsIGEgQ1NTIHNlbGVjdG9yIG9yIGEgRE9NIGVsZW1lbnQuLlsvZW5dXG4gICAqICAgW2phXeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAgnRhcmdldOW8leaVsOOBq+OBr+OAgSRldmVudOOCquODluOCuOOCp+OCr+ODiOOChERPTeOCqOODrOODoeODs+ODiOOChENTU+OCu+ODrOOCr+OCv+OCkua4oeOBmeOBk+OBqOOBjOWHuuadpeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gQWNjZXB0cyBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRhcmdldCBhcmd1bWVudCBtdXN0IGJlIGRlZmluZWQgZm9yIHRoZSBwb3BvdmVyLicpO1xuICAgIH1cblxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xuICAgICAgYWN0aW9uOiAnc2hvdycsXG4gICAgICBiZWZvcmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdoaWRlJyxcbiAgICAgIGFmdGVyOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fY2xlYXJTdHlsZXMoKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfcmVzZXRCYWNrQnV0dG9uSGFuZGxlcigpIHsgLy8gZG8gd2UgbmVlZCB0aGlzIHR3aWNlP1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJykpO1xuXG4gICAgICAvLyBGaXggZm9yIGlmcmFtZXNcbiAgICAgIGlmICghdGhpcy5fbWFyZ2luKSB7XG4gICAgICAgIHRoaXMuX21hcmdpbiA9IDY7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JhZGl1cyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKSk7XG5cbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2RpcmVjdGlvbicsICdhbmltYXRpb24nLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2RpYWxvZy1jYW5jZWwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJ107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtQb3BvdmVyQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvcG92ZXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBQb3BvdmVyQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFBvcG92ZXJBbmltYXRvcigpIHtcbiAgICByZXR1cm4gUG9wb3ZlckFuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXBvcG92ZXInLCBQb3BvdmVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtYmFyJzogJ3Byb2dyZXNzLWJhci0tKicsXG4gICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWJhcl9fcHJpbWFyeS0tKicsXG4gICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnktLSonXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnlcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19wcmltYXJ5XCI+PC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWJhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGxpbmVhciBwcm9ncmVzcyBiYXIuIEl0IGNhbiBlaXRoZXIgZGlzcGxheSBhIHByb2dyZXNzIGJhciB0aGF0IHNob3dzIHRoZSB1c2VyIGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQuIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBwZXJjZW50YWdlIGlzIG5vdCBrbm93biBpdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGFuIGFuaW1hdGVkIHByb2dyZXNzIGJhciBzbyB0aGUgdXNlciBjYW4gc2VlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHp2UWJHalxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXG4gKiBAc2VlYWxzbyBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1jaXJjdWxhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0JhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NvbXBpbGVkKCkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9pc0NvbXBpbGVkKCkge1xuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhckVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChiYXJFbGVtZW50LCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3ZhbHVlJywgJ3NlY29uZGFyeS12YWx1ZScsICdpbmRldGVybWluYXRlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtYmFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtYmFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3ByaW1hcnkuc3R5bGUud2lkdGggPSAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlY29uZGFyeVZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgc2Vjb25kYXJ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScsICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXByb2dyZXNzLWJhcicsIFByb2dyZXNzQmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtY2lyY3VsYXInOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSonLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnktLSonXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gIDwvc3ZnPlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLiBJdCBjYW4gZWl0aGVyIGJlIHVzZWQgdG8gc2hvdyBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkIG9yIHRvIHNob3cgYSBsb29waW5nIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBFVnpNalJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWJhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCAnaW5kZXRlcm1pbmF0ZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWNpcmN1bGFyLS1kZXRlcm1pbmF0ZWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXIgPSBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9ICBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCgpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeScpO1xuXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfaXNDb21waWxlZCgpIHtcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN2ZyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuY29uc3QgcmVtb3ZlVHJhbnNmb3JtID0gKGVsKSA9PiB7XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICBlbC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSAnJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICBlbC5zdHlsZS5XZWJraXRUcmFuc2l0aW9uID0gJyc7XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wdWxsLWhvb2tcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IGFkZHMgKipQdWxsIHRvIHJlZnJlc2gqKiBmdW5jdGlvbmFsaXR5IHRvIGFuIGA8b25zLXBhZ2U+YCBlbGVtZW50LlxuICpcbiAqICAgICBJdCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgdGFzayB3aGVuIHRoZSB1c2VyIHB1bGxzIGRvd24gYXQgdGhlIHRvcCBvZiB0aGUgcGFnZS4gQSBjb21tb24gdXNhZ2UgaXMgdG8gcmVmcmVzaCB0aGUgZGF0YSBkaXNwbGF5ZWQgaW4gYSBwYWdlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFdiSm9nTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3B1bGwtaG9va1xuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1wdWxsLWhvb2s+XG4gKiAgICAgUmVsZWFzZSB0byByZWZyZXNoXG4gKiAgIDwvb25zLXB1bGwtaG9vaz5cbiAqIDwvb25zLXBhZ2U+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignb25zLXB1bGwtaG9vaycpLm9uQWN0aW9uID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVsbEhvb2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlc3RhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWQuIFRoZSBzdGF0ZSBjYW4gYmUgZWl0aGVyIFwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiIG9yIFwiYWN0aW9uXCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu54q25oWL44GM5aSJ44KP44Gj44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CC54q25oWL44Gv44CBXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIsIFwiYWN0aW9uXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wdWxsSG9va1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5zdGF0ZVxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrueKtuaFi+WQjeOCkuWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIFwicHVsbC10by1yZWZyZXNoXCIgZnVuY3Rpb25hbGl0eSBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOCouOCr+OCt+ODp+ODs+OBjOWun+ihjOOBleOCjOOBquOBj+OBquOCiuOBvuOBmVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQuIFdoZW4gcHVsbGVkIGRvd24gZnVydGhlciB0aGFuIHRoaXMgdmFsdWUgaXQgd2lsbCBzd2l0Y2ggdG8gdGhlIFwicHJlYWN0aW9uXCIgc3RhdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiNjRweFwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBrumrmOOBleS7peS4iuOBq3B1bGwgZG93buOBmeOCi+OBqFwicHJlYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga7lgKTjga9cIjY0cHhcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRocmVzaG9sZC1oZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHRocmVzaG9sZCBoZWlnaHQuIFRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byB0aGUgXCJhY3Rpb25cIiBzdGF0ZSB3aGVuIHB1bGxlZCBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI5NnB4XCIuIEEgbmVnYXRpdmUgdmFsdWUgb3IgYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIGhlaWdodCB3aWxsIGRpc2FibGUgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV3plr7lgKTjgajjgarjgovpq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lgKTjgafmjIflrprjgZfjgZ/pq5jjgZXjgojjgorjgoJwdWxsIGRvd27jgZnjgovjgajjgIHjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/oh6rli5XnmoTjgatcImFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtY29udGVudFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBwYWdlIHdpbGwgbm90IG1vdmUgd2hlbiBwdWxsaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBpuOBhOOCi+aZguOBq+OCguOCs+ODs+ODhuODs+ODhOOBr+WLleOBjeOBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCwgdHJ1ZSk7XG4gIH1cblxuICBfc2V0U3R5bGUoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB0aGlzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgdGhpcy5zdHlsZS5saW5lSGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICB0aGlzLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSBgLSR7aGVpZ2h0fXB4YDtcbiAgfVxuXG4gIF9vblNjcm9sbChldmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9wYWdlRWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IDApIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICB9XG4gIH1cblxuICBfZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKDBweCwgJHtzY3JvbGx9cHgsIDBweClgO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFjayB0byBtYWtlIGl0IHdvcmsgb24gQW5kcm9pZCA0LjQgV2ViVmlldy4gU2Nyb2xscyBtYW51YWxseSBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc29cbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGluZXJ0aWFsIHNjcm9sbCB3aGVuIHNjcm9sbGluZyBkb3duLiBBbGxvd2luZyBkZWZhdWx0IHNjcm9sbGluZyB3aWxsXG4gICAgLy8ga2lsbCBhbGwgJ3RvdWNobW92ZScgZXZlbnRzLlxuICAgIGlmIChwbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zdGFydFNjcm9sbCAtIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICAgICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wIDwgd2luZG93LmlubmVySGVpZ2h0ICYmIGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uICE9PSAndXAnKSB7XG4gICAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09PSAwICYmIHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggPSBldmVudC5nZXN0dXJlLmRlbHRhWTtcblxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uO1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbCA9IE1hdGgubWF4KGV2ZW50Lmdlc3R1cmUuZGVsdGFZIC0gdGhpcy5fc3RhcnRTY3JvbGwsIDApO1xuXG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSAmJiBzY3JvbGwgPj0gdGhpcy50aHJlc2hvbGRIZWlnaHQpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUuc3RvcERldGVjdCgpO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xuICAgIH0gZWxzZSBpZiAoc2Nyb2xsID49IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9QUkVBQ1RJT04pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9XG5cbiAgICAvLyBCeSBzdG9wcGluZyBwcm9wYWdhdGlvbiBvbmx5IG9mIGBkcmFndXBgIGFuZCBgZHJhZ2Rvd25gLFxuICAgIC8vIGFsbG93aW5nIGFuY2VzdG9yIGVsZW1lbnRzIHRvIGRldGVjdCBgZHJhZ2xlZnRgIGFuZCBgZHJhZ3JpZ2h0YC5cbiAgICAvLyBJZiB3ZSBjb21tZW50IG91dCB0aGUgZm9sbG93aW5nIGBpZmAgYmxvY2ssIGBvbnMtc3BsaXR0ZXJgIHdpdGggYG9ucy1wdWxsLWhvb2tgIHdpbGwgYmUgYnJva2VuLlxuICAgIGlmIChldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydFNjcm9sbCA9IHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKTtcbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG5cbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25BY3Rpb247XG4gIH1cblxuICBzZXQgb25BY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICB0aGlzLl9vbkFjdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgX2ZpbmlzaCgpIHtcbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9BQ1RJT04pO1xuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHRoaXMuaGVpZ2h0LCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub25BY3Rpb24gfHwgKGRvbmUgPT4gZG9uZSgpKTtcbiAgICBhY3Rpb24oKCkgPT4ge1xuICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA2NHB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGAke3ZhbHVlfXB4YCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJzY0JywgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0aHJlc2hvbGRIZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB0aHJlc2hvbGRIZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA5NnB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IHRocmVzaG9sZEhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0aHJlc2hvbGQgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICB9XG5cbiAgX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSB7XG4gICAgY29uc3QgdGggPSB0aGlzLnRocmVzaG9sZEhlaWdodDtcbiAgICByZXR1cm4gdGggPiAwICYmIHRoID49IHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgIGlmICghbm9FdmVudCAmJiBsYXN0U3RhdGUgIT09IHRoaXMuX2dldFN0YXRlKCkpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XG4gICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzdGF0ZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIF9nZXRDdXJyZW50U2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHB1bGxEaXN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IG51bWJlciBvZiBwaXhlbHMgdGhlIHB1bGwgaG9vayBoYXMgbW92ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gf6Led6Zui44KS44OU44Kv44K744Or5pWw44CCWy9qYV1cbiAgICovXG4gIGdldCBwdWxsRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfaXNDb250ZW50Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdmaXhlZC1jb250ZW50Jyk7XG4gIH1cblxuICBfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29udGVudEZpeGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqL1xuICBfdHJhbnNsYXRlVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09IDAgJiYgc2Nyb2xsID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCk7XG4gICAgICAgIHJlbW92ZVRyYW5zZm9ybShlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gc2Nyb2xsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucGxheShkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbClcbiAgICAgICAgfSlcbiAgICAgICAgLnBsYXkoZG9uZSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVEcmFnTG9jaygpIHsgLy8gZTJlIHRlc3RzIG5lZWQgaXRcbiAgICB0aGlzLl9kcmFnTG9ja0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgZHJhZ0xvY2tUb0F4aXM6ICF0aGlzLl9kcmFnTG9ja0Rpc2FibGVkXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xuICAgIC8vXG4gICAgLy8gTm90ZTpcbiAgICAvLyBJZiB3ZSBzd2lwZSB1cC9kb3duIGEgc2NyZWVuIHRvbyBmYXN0LFxuICAgIC8vIHRoZSBnZXN0dXJlIGRldGVjdG9yIG9jY2FzaW9uYWxseSBkaXNwYXRjaGVzIGEgYGRyYWdsZWZ0YCBvciBgZHJhZ3JpZ2h0YCxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGhhdmUgdGhlIHB1bGwgaG9vayBsaXN0ZW4gdG8gYGRyYWdsZWZ0YCBhbmQgYGRyYWdyaWdodGAgYXMgd2VsbCBhcyBgZHJhZ3VwYCBhbmQgYGRyYWdkb3duYC5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWd1cCBkcmFnZG93biBkcmFnbGVmdCBkcmFncmlnaHQnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWd1cCBkcmFnZG93biBkcmFnbGVmdCBkcmFncmlnaHQnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcblxuICAgIHRoaXMuX2Rlc3Ryb3lFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaGVpZ2h0J107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnaGVpZ2h0Jykge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNUQVRFX0lOSVRJQUwoKSB7XG4gICAgcmV0dXJuIFNUQVRFX0lOSVRJQUw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNUQVRFX1BSRUFDVElPTigpIHtcbiAgICByZXR1cm4gU1RBVEVfUFJFQUNUSU9OO1xuICB9XG5cbiAgc3RhdGljIGdldCBTVEFURV9BQ1RJT04oKSB7XG4gICAgcmV0dXJuIFNUQVRFX0FDVElPTjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2NoYW5nZXN0YXRlJ11cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wdWxsLWhvb2snLCBQdWxsSG9va0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTYgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5cbi8qKlxuICogQGNsYXNzIEFuaW1hdG9yQ1NTIC0gaW1wbGVtZW50YXRpb24gb2YgQW5pbWF0b3IgY2xhc3MgdXNpbmcgY3NzIHRyYW5zaXRpb25zXG4gKi9cbmNsYXNzIEFuaW1hdG9yQ1NTIHtcblxuICAvKipcbiAgICogQG1ldGhvZCBhbmltYXRlXG4gICAqIEBkZXNjIG1haW4gYW5pbWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZmluYWxDU1NcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdIC0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQudGhlbihjYWxsYmFjaykgLSBzZXRzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnN0b3Aob3B0aW9ucykgLSBzdG9wcyB0aGUgYW5pbWF0aW9uOyBpZiBvcHRpb25zLnN0b3BOZXh0IGlzIHRydWUgdGhlbiBpdCBkb2Vzbid0IGNhbGwgdGhlIGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuZmluaXNoKG1zKSAtIGZpbmlzaGVzIHRoZSBhbmltYXRpb24gaW4gdGhlIHNwZWNpZmllZCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnNwZWVkKG1zKSAtIHNldHMgdGhlIGFuaW1hdGlvbiBzcGVlZCBzbyB0aGF0IGl0IGZpbmlzaGVzIGFzIGlmIHRoZSBvcmlnaW5hbCBkdXJhdGlvbiB3YXMgdGhlIG9uZSBzcGVjaWZpZWQgaGVyZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBgXG4gICAqICB2YXIgcmVzdWx0ID0gYW5pbWF0b3IuYW5pbWF0ZShlbCwge29wYWNpdHk6IDAuNX0sIDEwMDApO1xuICAgKlxuICAgKiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICogICAgcmVzdWx0LnNwZWVkKDIwMCkudGhlbihmdW5jdGlvbigpe1xuICAgKiAgICAgIGNvbnNvbGUubG9nKCdkb25lJyk7XG4gICAqICAgIH0pO1xuICAgKiAgfSwgMzAwKTtcbiAgICogYGBgYFxuICAgKi9cbiAgYW5pbWF0ZShlbCwgZmluYWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgdmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgaW5pdGlhbCA9IHt9LFxuICAgICAgICBzdG9wcGVkID0gZmFsc2UsXG4gICAgICAgIG5leHQgPSBmYWxzZSxcbiAgICAgICAgdGltZW91dCA9IGZhbHNlLFxuICAgICAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoZmluYWwpO1xuXG4gICAgdmFyIHVwZGF0ZVN0eWxlcyA9ICgpID0+IHtcbiAgICAgIGxldCBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHMuZ2V0UHJvcGVydHlWYWx1ZS5iaW5kKHMpKTtcbiAgICAgIHMgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzdG9wOiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB2YXIgayA9IE1hdGgubWluKDEsICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb24pO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOZXh0KSB7XG4gICAgICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0aGVuOiAoY2IpID0+IHtcbiAgICAgICAgbmV4dCA9IGNiO1xuICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgc3BlZWQ6IChuZXdEdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgICAgIG5ld0R1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICAgIGNvbnN0IHBhc3NlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcbiAgICAgICAgICBjb25zdCAgayA9IHBhc3NlZCAvIGR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IG5ld0R1cmF0aW9uICogKDEgLSBrKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdXBkYXRlU3R5bGVzKCk7XG5cbiAgICAgICAgICBzdGFydCA9IGVsLnNwZWVkVXBUaW1lO1xuICAgICAgICAgIGR1cmF0aW9uID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogKG1pbGxpc2Vjb25kcyA9IDUwKSA9PiB7XG4gICAgICAgIHZhciBrID0gKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcblxuICAgICAgICByZXN1bHQuc3BlZWQobWlsbGlzZWNvbmRzIC8gKDEgLSBrKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgc3RvcHBlZCB8fCBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICBjb25zdCB2ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGUpKTtcbiAgICAgIGluaXRpYWxbZV0gPSBpc05hTih2KSA/IDAgOiB2O1xuICAgIH0pO1xuXG5cbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHByb3BlcnRpZXMuam9pbignLCcpO1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW2VdID0gZmluYWxbZV0gKyAoZSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9vblN0b3BBbmltYXRpb25zKGVsLCByZXN1bHQuc3RvcCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG4gIH1cblxuICBfb25TdG9wQW5pbWF0aW9ucyhlbCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB2YXIgaSA9IHRoaXMuX2luZGV4Kys7XG4gICAgcXVldWVbZWxdID0gcXVldWVbZWxdIHx8IFtdO1xuICAgIHF1ZXVlW2VsXVtpXSA9IChvcHRpb25zKSA9PiB7XG4gICAgICBkZWxldGUgcXVldWVbZWxdW2ldO1xuICAgICAgaWYgKHF1ZXVlW2VsXSAmJiBxdWV1ZVtlbF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgZGVsZXRlIHF1ZXVlW2VsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcihvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQW5pbWF0aW9uc1xuICAqIEBkZXNjIHN0b3BzIGFjdGl2ZSBhbmltYXRpb25zIG9uIGEgc3BlY2lmaWVkIGVsZW1lbnRcbiAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsZW1lbnQgLSBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICByZXR1cm4gZWwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKHRoaXMuX3F1ZXVlW2VsXSB8fCBbXSkuZm9yRWFjaChlID0+IHsgZShvcHRpb25zIHx8IHt9KTsgfSk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbGxcbiAgKiBAZGVzYyBzdG9wcyBhbGwgYWN0aXZlIGFuaW1hdGlvbnNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbGwob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhPYmplY3Qua2V5cyh0aGlzLl9xdWV1ZSksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBmYWRlXG4gICogQGRlc2MgZmFkZXMgdGhlIGVsZW1lbnQgKHNob3J0IHZlcnNpb24gZm9yIGFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSkpXG4gICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdXG4gICovXG4gIGZhZGUoZWwsIGR1cmF0aW9uID0gMjAwKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9LCBkdXJhdGlvbik7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRvckNTUztcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci1jc3MnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncmlwcGxlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmlwcGxlXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFkZHMgYSBNYXRlcmlhbCBEZXNpZ24gXCJyaXBwbGVcIiBlZmZlY3QgdG8gYW4gZWxlbWVudC4gVGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBzcHJlYWQgZnJvbSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHVzZXIgdGFwcy5cbiAqXG4gKiAgICAgU29tZSBlbGVtZW50cyBzdWNoIGFzIGA8b25zLWJ1dHRvbj5gIGFuZCBgPG9ucy1mYWI+YCAgc3VwcG9ydCBhIGByaXBwbGVgIGF0dHJpYnV0ZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODquODg+ODl+ODq+WKueaenOOCkkRPTeimgee0oOOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB3S1FXZFpcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yaXBwbGVcbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nXG4gKiAgW2VuXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVxuICogIFtqYV1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8ZGl2IGNsYXNzPVwibXktZGl2XCI+XG4gKiAgPG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPlxuICogPC9kaXY+XG4gKlxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIHJpcHBsZT5DbGljayBtZSE8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJpcHBsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLlsvZW5dXG4gICAqICAgW2phXeiDjOaZr+OBruiJsuOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbiAgICBbJ2NvbG9yJywgJ2NlbnRlcicsICdzdGFydC1yYWRpdXMnLCAnYmFja2dyb3VuZCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl93YXZlID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX3dhdmUnKVswXTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX2JhY2tncm91bmQnKVswXTtcblxuICAgIGlmICghKHRoaXMuX2JhY2tncm91bmQgJiYgdGhpcy5fd2F2ZSkpIHtcbiAgICAgIHRoaXMuX3dhdmUgPSB1dGlsLmNyZWF0ZSgnLnJpcHBsZV9fd2F2ZScpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX19iYWNrZ3JvdW5kJyk7XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fd2F2ZSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX2JhY2tncm91bmQpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIHZhciB4LCB5LCBoLCB3LCByO1xuICAgIHZhciBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5fY2VudGVyKSB7XG4gICAgICB4ID0gYi53aWR0aCAvIDI7XG4gICAgICB5ID0gYi5oZWlnaHQgLyAyO1xuICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChlLmNsaWVudFggfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSAtIGIubGVmdDtcbiAgICAgIHkgPSAoZS5jbGllbnRZIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgfVxuICAgIHJldHVybiB7eCwgeSwgcn07XG4gIH1cblxuICBfcmlwcGxlQW5pbWF0aW9uKGUsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgdmFyXG4gICAgICB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXMsXG4gICAgICB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcblxuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RhcnQtcmFkaXVzJzpcbiAgICAgICAgdGhpcy5fbWluUiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoY3VycmVudCkgfHwgMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dhdmUuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgIGlmIChjdXJyZW50IHx8IGxhc3QpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgbGF5b3V0aW5nXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJvdycsIFJvd0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWxlY3QtKicsXG4gICcuc2VsZWN0LWlucHV0JzogJ3NlbGVjdC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VsZWN0JztcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdmb3JtJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncmVxdWlyZWQnLFxuICAnc2l6ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlbGVjdFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3QgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlbGVjdCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgc2VsZWN0IG9uIGEgcGFnZSwgdXNlIGA8b25zLXNlbGVjdD5gLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlbGVjdCBvbiBBbmRyb2lkLlxuICpcbiAqICAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxzZWxlY3Q+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgILjg4Tjg7zjg6vjg5Djg7zjgavjg5zjgr/jg7PjgpLoqK3nva7jgZnjgovloLTlkIjjga/jgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zZWxlY3RcbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWxlY3Q+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIxXCI+MTwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiMlwiPjJuZDwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiM1wiPjNyZCBvcHRpb248L29wdGlvbj5cbiAqIDwvb25zLXNlbGVjdD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG9mb2N1c1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWxlbWVudCBhdXRvbWF0aWNhbGx5IGdhaW5zIGZvY3VzIG9uIHBhZ2UgbG9hZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWxlY3QgaW5wdXQgc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZvcm1cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFzc29jaWF0ZSBhIHNlbGVjdCBlbGVtZW50IHRvIGFuIGV4aXN0aW5nIGZvcm0gb24gdGhlIHBhZ2UsIGV2ZW4gaWYgbm90IG5lc3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtdWx0aXBsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgbXVsdGlwbGUgb3B0aW9ucyBjYW4gYmUgc2VsZWN0ZWQgYXQgb25jZS5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hbWUgdGhlIHNlbGVjdCBlbGVtZW50LCB1c2VmdWwgZm9yIGluc3RhbmNlIGlmIGl0IGlzIHBhcnQgb2YgYSBmb3JtLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJlcXVpcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZSB0aGUgc2VsZWN0IGlucHV0IHJlcXVpcmVkIGZvciBzdWJtaXR0aW5nIHRoZSBmb3JtIGl0IGlzIHBhcnQgb2YuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib3cgbWFueSBvcHRpb25zIGFyZSBkaXNwbGF5ZWQ7IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdGhlIHNpemUgdGhlbiBhIHNjcm9sbCBhcHBlYXJzIHRvIG5hdmlnYXRlIHRoZW0uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfc2VsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnY2hhbmdlJ107XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIG9wdGlvbnMgaW4gdGhlIHNlbGVjdCBib3guWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXZlcmFsIG9wdGlvbnMgZm9yIGhhbmRsaW5nIHRoZSBzZWxlY3QgRE9NIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlbGVjdGVkSW5kZXhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVZhbHVlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBjb25zdCBzZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBzZWwuY2xhc3NMaXN0LmFkZCgnc2VsZWN0LWlucHV0Jyk7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4gc2VsLmFwcGVuZENoaWxkKGVsZW1lbnQpKTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKHNlbCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBbJ2Rpc2FibGVkJywgJ2xlbmd0aCcsICdtdWx0aXBsZScsICduYW1lJywgJ29wdGlvbnMnLCAnc2VsZWN0ZWRJbmRleCcsICdzaXplJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCwgYXJyKSB7XG4gICAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9zZWxlY3Rba2V5XTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5fX2RlZmluZVNldHRlcl9fKGtleSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHNlbGYuX3NlbGVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2Zvcm0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi5fc2VsZWN0Wydmb3JtJ107XG4gICAgfSlcbiAgICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ3R5cGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi5fc2VsZWN0Wyd0eXBlJ107XG4gICAgfSlcbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChvcHRpb24sIGluZGV4ID0gbnVsbCkge1xuICAgICAgc2VsZi5fc2VsZWN0LmFkZChvcHRpb24sIGluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHNlbGYuX3NlbGVjdC5yZW1vdmUoaW5kZXgpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWxlY3QnLCBTZWxlY3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnZmFiIGZhYi0tbWluaSBzcGVlZC1kaWFsX19pdGVtJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3NwZWVkLWRpYWxfX2l0ZW0tLSonLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBkaWFsIGNvbXBvbmVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIE1hdGVyaWFsIERlc2lnbuOBrlNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnj77jgZnjgovopoHntKDjgafjgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWZhYlxuICogICBbZW5db25zLWZhYiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWZhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWREaWFsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoY3VycmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQ2xhc3NOYW1lKGNsYXNzTmFtZSkge1xuICAgIGlmICghZGVmYXVsdENsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmV2ZXJ5KHRva2VuID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucyh0b2tlbik7XG4gICAgfSkpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGRlZmF1bHRDbGFzc05hbWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKHRva2VuID0+IHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCh0b2tlbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLCBTcGVlZERpYWxJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICovXG5jb25zdCBzdHlsZXIgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGVyLmNzcy5hcHBseShzdHlsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNldCBlbGVtZW50J3Mgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5zdHlsZXIuY3NzID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChzdHlsZXIuX3ByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVyLl9wcmVmaXgoa2V5KV0gPSBzdHlsZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuc3R5bGVyLl9wcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgdmFyIHByZWZpeCA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChzdHlsZXMpXG4gICAgLmpvaW4oJycpXG4gICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgKVsxXTtcblxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBuYW1lLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuY2xlYXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHN0eWxlci5fY2xlYXIoZWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuX2NsZWFyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXlzLnB1c2goc3R5bGVbaV0pO1xuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHN0eWxlW2tleV0gPSAnJztcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZXI7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL2xpYi9zdHlsZXInO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3NwZWVkLWRpYWwnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3NwZWVkLWRpYWwtLSonLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbFxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRWxlbWVudCB0aGF0IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIFNwZWVkIERpYWxvZyBjb21wb25lbnQuIEl0IGlzIHVzZWZ1bCB3aGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHByaW1hcnkgYWN0aW9uIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBpbiBhIHBhZ2UuXG4gKlxuICogICAgIFRoZSBTcGVlZCBkaWFsIGxvb2tzIGxpa2UgYSBgPG9ucy1mYWI+YCBlbGVtZW50IGJ1dCB3aWxsIGV4cGFuZCBhIG1lbnUgd2hlbiB0YXBwZWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gZFlRWUxnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BlZWQtZGlhbFxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWwtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWwtaXRlbT5gIHJlcHJlc2VudHMgYSBtZW51IGl0ZW0uWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFsLWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWZhYlxuICogICBbZW5db25zLWZhYiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWZhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWREaWFsRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIG1lbnUgaXRlbXMgYXJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIG1lbnUgaXRlbXMgYXJlIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiAgICAgSS5lLiB0byBkaXNwbGF5IGl0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIHNwZWNpZnkgXCJyaWdodCB0b3BcIi5cbiAgICogICAgIENob29zZSBmcm9tIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIgYW5kIFwiYm90dG9tXCIuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7opoHntKDjgpLooajnpLrjgZnjgovlt6blj7PjgajkuIrkuIvjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOS+i+OBiOOBsOOAgeWPs+S4iuOBq+ihqOekuuOBmeOCi+WgtOWQiOOBq+OBr1wicmlnaHQgdG9wXCLjgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOW3puWPs+OBqOS4iuS4i+OBruS9jee9ruOBruaMh+WumuOBq+OBr+OAgXJpZ2h044GobGVmdOOAgXRvcOOBqGJvdHRvbeOBjOOBneOCjOOBnuOCjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgZGlyZWN0aW9uIHRoZSBpdGVtcyBhcmUgZGlzcGxheWVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCd1cCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydjbGFzcycsICdtb2RpZmllcicsICdyaXBwbGUnLCAnZGlyZWN0aW9uJywgJ3Bvc2l0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlRGlyZWN0aW9uKGN1cnJlbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVQb3NpdGlvbigpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nKSk7XG4gIH1cblxuICBnZXQgX2ZhYigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1mYWInKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgaWYgKHRoaXMuX2ZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gdGhpcy5fZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogdGhpcy5fZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHQuJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2gocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuX2ZhYi5zaG93KCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZUl0ZW1zKCkudGhlbigoKT0+IHRoaXMuX2ZhYi5oaWRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93SXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICBsZXQgdG90YWxEZWxheSA9IDA7XG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIGk7XG4gICAgICAgIHRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5ICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsRGVsYXkgKz0gNTA7XG5cbiAgICAgIHRoaXMuX2l0ZW1TaG93biA9IHRydWU7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ29wZW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICBzZXRUaW1lb3V0KGRlZmVycmVkLnJlc29sdmUsIHRvdGFsRGVsYXkpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgaGlkZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlSXRlbXMoKSB7XG4gICAgbGV0IHRvdGFsRGVsYXkgPSAwO1xuICAgIGlmICh0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKTtcbiAgICAgICAgdG90YWxEZWxheSArPSBkZWxheTtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxEZWxheSArPSA1MDtcblxuICAgICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgc2V0VGltZW91dChkZWZlcnJlZC5yZXNvbHZlLCB0b3RhbERlbGF5KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIH1cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdXRpbC5tYXRjaChlLCAnLmZhYicpICYmIHV0aWwudG9nZ2xlQXR0cmlidXRlKGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmxpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbmxpbmUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCpOODs+ODqeOCpOODs+imgee0oOOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhYi52aXNpYmxlICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVuXG4gICAqIEBzaWduYXR1cmUgaXNPcGVuKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgbWVudSBpcyBvcGVuIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtU2hvd247XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBpdGVtIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGVJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4oKSA/IHRoaXMuaGlkZUl0ZW1zKCkgOiB0aGlzLnNob3dJdGVtcygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnb3BlbicsICdjbG9zZSddO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwnLCBTcGVlZERpYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgZWxlbWVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJDb250ZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSB1cmwgb2YgdGhlIGNvbnRlbnQgcGFnZS4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdXNlZCB0aGUgY29udGVudCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgYDxvbnMtdGVtcGxhdGU+YCB0YWcgb3IgYSByZW1vdGUgZmlsZS5cbiAgICpcbiAgICogICAgIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcHV0IGA8b25zLXBhZ2U+YCBlbGVtZW50IGFzIGEgY2hpbGQgb2YgdGhlIGVsZW1lbnQuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuXG4gICAgICBpZiAocGFnZSkge1xuICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIG11c3QgaGF2ZSBcIm9ucy1zcGxpdHRlclwiIGFzIHBhcmVudE5vZGUuYCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRvIGxvYWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gcGFnZVxuICAgKi9cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXWA8b25zLXBhZ2U+YOimgee0oOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9jb250ZW50KTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItY29udGVudCcsIFNwbGl0dGVyQ29udGVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH0gZWxzZSBpZiAodXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4gc2lkZS5jbG9zZSgnbGVmdCcpLmNhdGNoKCgpID0+IHt9KSk7XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItbWFzaycsIFNwbGl0dGVyTWFza0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJywgZHVyYXRpb24gPSAwLjMsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkdXJhdGlvbiwgZGVsYXkgfSk7XG4gIH1cblxuICB1cGRhdGVPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHtcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLCBkZWxheTogdGhpcy5kZWxheVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2lkZUVsZW1lbnRcbiAgICovXG4gIGFjdGl2YXRlKHNpZGVFbGVtZW50KSB7XG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gc3BsaXR0ZXIuY29udGVudDtcbiAgICAgIHRoaXMuX21hc2sgPSBzcGxpdHRlci5tYXNrO1xuICAgIH0pO1xuICB9XG5cbiAgaW5hY3RpdmF0ZSgpIHtcbiAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fc2lkZSA9IHRoaXMuX21hc2sgPSBudWxsO1xuICB9XG5cbiAgZ2V0IG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLl9zaWRlID09PSAncmlnaHQnID8gJy0nIDogJyc7XG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzfTEwMCUsIDBweCwgMHB4KWBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcxJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gIGRlZmF1bHQ6IFNwbGl0dGVyQW5pbWF0b3IsXG4gIG92ZXJsYXk6IFNwbGl0dGVyQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyXG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBlbmFibGVzIHJlc3BvbnNpdmUgbGF5b3V0IGJ5IGltcGxlbWVudGluZyBib3RoIGEgdHdvLWNvbHVtbiBsYXlvdXQgYW5kIGEgc2xpZGluZyBtZW51IGxheW91dC5cbiAqXG4gKiAgICBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IGV4cGFuZCBpbnRvIGEgY29sdW1uIGxheW91dCBvbiBsYXJnZSBzY3JlZW5zIGFuZCBjb2xsYXBzZSB0aGUgbWVudSBvbiBzbWFsbGVyIHNjcmVlbnMuIFdoZW4gdGhlIG1lbnUgaXMgY29sbGFwc2VkIHRoZSB1c2VyIGNhbiBvcGVuIGl0IGJ5IHN3aXBpbmcuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXIgaWQ9XCJzcGxpdHRlclwiPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlIHN3aXBlYWJsZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBzcGxpdHRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzcGxpdHRlcicpO1xuICogICBzcGxpdHRlci5sZWZ0Lm9wZW4oKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgX2dldFNpZGUoc2lkZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCBlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09IHNpZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlZnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUxlZnQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdsZWZ0Jyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSByaWdodFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmlnaHQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgncmlnaHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2lkZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgcmVnYXJkbGVzcyB0aGUgYWN0dWFsIHNpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzaWRlKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLXNpZGUnKTtcbiAgfVxuXG4gIGdldCBfc2lkZXMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxlZnQsIHRoaXMucmlnaHRdLmZpbHRlcihlID0+IGUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY29udGVudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICB0aGlzLl9zaWRlcy5zb21lKHMgPT4gcy5pc09wZW4gPyBzLmNsb3NlKCkgOiBmYWxzZSkgfHwgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIF9vbk1vZGVDaGFuZ2UoZSkge1xuICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZVtzaWRlLnNpZGVdID0gc2lkZS5tb2RlID09PSAnc3BsaXQnID8gc2lkZS5fd2lkdGggOiAwO1xuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9ib3VuZE9uTW9kZUNoYW5nZSA9IHRoaXMuX29uTW9kZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLm1hc2spIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG5cbiAgX3Nob3coKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yIGluc3RhbmNlb2YgU3BsaXR0ZXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW5pbWF0b3IgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgU3BsaXR0ZXJBbmltYXRvci4nKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBTcGxpdHRlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBTcGxpdHRlckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXInLCBTcGxpdHRlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL29ucy1zcGxpdHRlci9hbmltYXRvcic7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgeyBQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBTcGxpdHRlckVsZW1lbnQgZnJvbSAnLi9vbnMtc3BsaXR0ZXInO1xuXG5jb25zdCBTUExJVF9NT0RFID0gJ3NwbGl0JztcbmNvbnN0IENPTExBUFNFX01PREUgPSAnY29sbGFwc2UnO1xuY29uc3QgQ0xPU0VEX1NUQVRFID0gJ2Nsb3NlZCc7XG5jb25zdCBPUEVOX1NUQVRFID0gJ29wZW4nO1xuY29uc3QgQ0hBTkdJTkdfU1RBVEUgPSAnY2hhbmdpbmcnO1xuXG5jb25zdCBXQVRDSEVEX0FUVFJJQlVURVMgPSBbJ2FuaW1hdGlvbicsICd3aWR0aCcsICdzaWRlJywgJ2NvbGxhcHNlJywgJ3N3aXBlYWJsZScsICdzd2lwZS10YXJnZXQtd2lkdGgnLCAnYW5pbWF0aW9uLW9wdGlvbnMnLCAnb3Blbi10aHJlc2hvbGQnXTtcblxuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoc3BsaXR0ZXJTaWRlRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5jbGFzcyBDb2xsYXBzZURldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhcmdldCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRhcmdldCAmJiB0aGlzLmNoYW5nZVRhcmdldCh0YXJnZXQpO1xuICB9XG5cbiAgY2hhbmdlVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfbWF0Y2godmFsdWUpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXQgPT09ICh2YWx1ZS5pc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XG4gIH1cblxuICBfb25DaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKHRoaXMuX21hdGNoKHZhbHVlKSA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2Uoe2lzUG9ydHJhaXQ6IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IHdpbmRvdy5tYXRjaE1lZGlhKHRoaXMuX3RhcmdldCk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5hZGRMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuX3F1ZXJ5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd2lkdGhUb1B4ID0gKHdpZHRoLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChwYXJlbnQub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5jbGFzcyBDb2xsYXBzZU1vZGUge1xuICBnZXQgX2FuaW1hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Ll9hbmltYXRvcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NFRF9TVEFURTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9sb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSAmJiB0aGlzLl9zdGF0ZSAhPT0gQ0xPU0VEX1NUQVRFO1xuICB9XG5cbiAgaGFuZGxlR2VzdHVyZShlKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZS50eXBlID09PSAnZHJhZ2VuZCcgPyB0aGlzLl9vbkRyYWdFbmQoZSkgOiB0aGlzLl9vbkRyYWcoZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3Qgc2Nyb2xsaW5nID0gIS9sZWZ0fHJpZ2h0Ly50ZXN0KGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2VsZW1lbnQuX3N3aXBlVGFyZ2V0V2lkdGg7XG4gICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW4oKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gc2Nyb2xsaW5nIHx8IChhcmVhICYmIGRpc3RhbmNlID4gYXJlYSAmJiAhaXNPcGVuKTtcblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuX2VsZW1lbnQuX3dpZHRoLCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpO1xuICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9IGlzT3BlbiA/IHRoaXMuX3dpZHRoIDogMDtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9lbGVtZW50Ll9zaWRlID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmRlbHRhWCA6IC1ldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX3dpZHRoLCB0aGlzLl9zdGFydERpc3RhbmNlICsgZGVsdGEpKTtcbiAgICBpZiAoZGlzdGFuY2UgIT09IHRoaXMuX2Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci50cmFuc2xhdGUoZGlzdGFuY2UpO1xuICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGNvbnN0IHtfZGlzdGFuY2U6IGRpc3RhbmNlLCBfd2lkdGg6IHdpZHRoLCBfZWxlbWVudDogZWx9ID0gdGhpcztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IGVsLl9zaWRlICE9PSBkaXJlY3Rpb24gJiYgZGlzdGFuY2UgPiB3aWR0aCAqIGVsLl90aHJlc2hvbGQ7XG4gICAgdGhpcy5leGVjdXRlQWN0aW9uKHNob3VsZE9wZW4gPyAnb3BlbicgOiAnY2xvc2UnKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlID09PSBPUEVOX1NUQVRFKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW50ZXIgY29sbGFwc2UgbW9kZVxuICBlbnRlck1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4aXQgY29sbGFwc2UgbW9kZVxuICBleGl0TW9kZSgpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9pc09wZW5PdGhlclNpZGVNZW51KCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pLnNvbWUoZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlICE9PSB0aGlzLl9lbGVtZW50ICYmIGUuaXNPcGVuO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gJ29wZW4nIG9yICdjbG9zZSdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0QW5pbWF0aW9uXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlXG4gICAqL1xuICBleGVjdXRlQWN0aW9uKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IEZJTkFMX1NUQVRFID0gbmFtZSA9PT0gJ29wZW4nID8gT1BFTl9TVEFURSA6IENMT1NFRF9TVEFURTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwbGl0dGVyIHNpZGUgaXMgbG9ja2VkLicpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ29wZW4nICYmIHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZWxlbWVudC5fZW1pdEV2ZW50KGBwcmUke25hbWV9YCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHtuYW1lfSBldmVudC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlID0gRklOQUxfU1RBVEU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgICB0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHBvc3Qke25hbWV9YCk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy53aXRob3V0QW5pbWF0aW9uKSB7XG4gICAgICBkb25lKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IENIQU5HSU5HX1NUQVRFO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW25hbWVdKCgpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItc2lkZVxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGVpdGhlciB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5cbiAqXG4gKiAgICBJdCBzdXBwb3J0cyB0d28gbW9kZXM6IGNvbGxhcHNlZCBhbmQgc3BsaXQuIFdoZW4gaXQncyBpbiBjb2xsYXBzZWQgbW9kZSBpdCB3aWxsIGJlIGhpZGRlbiBmcm9tIHZpZXcgYW5kIGNhbiBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBzd2lwZXMgdGhlIHNjcmVlbiBvciB0YXBzIGEgYnV0dG9uLiBJbiBzcGxpdCBtb2RlIHRoZSBlbGVtZW50IGlzIGFsd2F5cyBzaG93bi4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggYmV0d2VlbiB0aGUgdHdvIG1vZGVzIGRlcGVuZGluZyBvbiB0aGUgc2NyZWVuIHNpemUuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyU2lkZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBtb2RlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjb21wb25lbnQncyBtb2RlIGNoYW5nZXMuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu44Oi44O844OJ44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5tb2RlXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbW9kZS4gQ2FuIGJlIGVpdGhlciBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZW9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZyBtZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0b3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovjga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbi4gVXNlIG9uZSBvZiBgXCJvdmVybGF5XCJgLCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwib3ZlcmxheVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcGVuLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAgMC4zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIG1lbnUgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBvcGVuaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cbiAgICogIFtqYV3jganjga7jgY/jgonjgYTjgrnjg6/jgqTjg5fjgZnjgozjgbDjgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgpLplovjgY/jgYvjganjgYbjgYvjga7libLlkIjjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMeOBrumWk+OBruaVsOWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODr+OCpOODl+OBrui3nembouOBjOOBk+OBk+OBp+aMh+WumuOBl+OBn+aVsOWApOaOm+OBkeOCi+OBk+OBruimgee0oOOBruW5heOCiOOCiuOCguWkp+OBjeOBkeOCjOOBsOOAgeOCueODr+OCpOODl+OBjOe1guOCj+OBo+OBn+aZguOBq+OBk+OBruimgee0oOOCkumWi+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBrzAuM+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbGxhcHNlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIGNvbGxhcHNlIGJlaGF2aW9yLiBWYWxpZCB2YWx1ZXMgYXJlIGBcInBvcnRyYWl0XCJgLCBgXCJsYW5kc2NhcGVcImAgb3IgYSBtZWRpYSBxdWVyeS5cbiAgICogICAgIFRoZSBzdHJpbmdzIGBcInBvcnRyYWl0XCJgIGFuZCBgXCJsYW5kc2NhcGVcImAgbWVhbnMgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIGRldmljZSBpcyBpbiBsYW5kc2NhcGUgb3IgcG9ydHJhaXQgb3JpZW50YXRpb24uXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgYSBtZWRpYSBxdWVyeSwgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIHRoZSBtZWRpYSBxdWVyeSByZXNvbHZlcyB0byBgdHJ1ZWAuXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQsIHRoZSB2aWV3IGFsd2F5cyBiZSBpbiBgXCJjb2xsYXBzZVwiYCBtb2RlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg5bem5YG044Gu44Oa44O844K444KS6Z2e6KGo56S644Gr44GZ44KL5p2h5Lu244KS5oyH5a6a44GX44G+44GZ44CCcG9ydHJhaXQsIGxhbmRzY2FwZeOAgXdpZHRoICNweOOCguOBl+OBj+OBr+ODoeODh+OCo+OCouOCr+OCqOODquOBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAglxuICAgKiAgICAgcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZnjgovjgajjgIHjg4fjg5DjgqTjgrnjga7nlLvpnaLjgYznuKblkJHjgY3jgoLjgZfjgY/jga/mqKrlkJHjgY3jgavjgarjgaPjgZ/mmYLjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOODoeODh+OCo+OCouOCr+OCqOODquOCkuaMh+WumuOBmeOCi+OBqOOAgeaMh+WumuOBl+OBn+OCr+OCqOODquOBq+mBqeWQiOOBl+OBpuOBhOOCi+WgtOWQiOOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg5YCk44Gr5L2V44KC5oyH5a6a44GX44Gq44GE5aC05ZCI44Gr44Gv44CB5bi444GrY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgorjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10YXJnZXQtd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB3aWR0aCBvZiBzd2lwZWFibGUgYXJlYSBjYWxjdWxhdGVkIGZyb20gdGhlIGVkZ2UgKGluIHBpeGVscykuIFVzZSB0aGlzIHRvIGVuYWJsZSBzd2lwZSBvbmx5IHdoZW4gdGhlIGZpbmdlciB0b3VjaCBvbiB0aGUgc2NyZWVuIGVkZ2UuWy9lbl1cbiAgICogICBbamFd44K544Ov44Kk44OX44Gu5Yik5a6a6aCY5Z+f44KS44OU44Kv44K744Or5Y2Y5L2N44Gn5oyH5a6a44GX44G+44GZ44CC55S76Z2i44Gu56uv44GL44KJ5oyH5a6a44GX44Gf6Led6Zui44Gr6YGU44GZ44KL44Go44Oa44O844K444GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNhbiBiZSBzcGVjaWZpZWQgaW4gZWl0aGVyIHBpeGVscyBvciBhcyBhIHBlcmNlbnRhZ2UsIGUuZy4gYDkwJWAgb3IgYDIwMHB4YC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7mqKrluYXjgpLmjIflrprjgZfjgb7jgZnjgIJweOOBqCXjgafjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJlZy4gOTAlLCAyMDBweFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbGVmdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGljaCBzaWRlIG9mIHRoZSBzY3JlZW4gdGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIGxvY2F0ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44GM5bem44GL5Y+z44GL44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL5YCk44GvXCJsZWZ0XCLjgYtcInJpZ2h0XCLjga7jgb/jgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuIFRoaXMgYXR0cmlidXRlIGlzIHJlYWQgb25seS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgYzoqK3lrprjgZXjgozjgb7jgZnjgIJcImNvbGxhcHNlXCLjgoLjgZfjgY/jga9cInNwbGl0XCLjgYzmjIflrprjgZXjgozjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/oqq3jgb/ovrzjgb/lsILnlKjjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIFVSTCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1zaWRl6KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBlbmFibGUgc3dpcGUgaW50ZXJhY3Rpb24gb24gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieaZguOBq+OCueODr+OCpOODl+aTjeS9nOOCkuacieWKueOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX2NvbGxhcHNlTW9kZSA9IG5ldyBDb2xsYXBzZU1vZGUodGhpcyk7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24gPSBuZXcgQ29sbGFwc2VEZXRlY3Rpb24odGhpcyk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogU3BsaXR0ZXJFbGVtZW50LmFuaW1hdG9ycyxcbiAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdTcGxpdHRlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICAgIHRoaXMuX2JvdW5kSGFuZGxlR2VzdHVyZSA9IChlKSA9PiB0aGlzLl9jb2xsYXBzZU1vZGUuaGFuZGxlR2VzdHVyZShlKTtcbiAgICB0aGlzLl93YXRjaGVkQXR0cmlidXRlcyA9IFdBVENIRURfQVRUUklCVVRFUztcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKHBhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgbXVzdCBiZSBhbiBvbnMtc3BsaXR0ZXIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMucGFyZW50RWxlbWVudCwge2RyYWdNaW5EaXN0YW5jZTogMX0pO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmZvckVhY2goZSA9PiB0aGlzLl91cGRhdGUoZSkpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGdldCBzaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSAncmlnaHQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gV0FUQ0hFRF9BVFRSSUJVVEVTO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICB0aGlzLl91cGRhdGUobmFtZSwgY3VycmVudCk7XG4gIH1cblxuICBfdXBkYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9ICdfdXBkYXRlJyArIG5hbWUuc3BsaXQoJy0nKS5tYXAoZSA9PiBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gdGhpc1tuYW1lXSh2YWx1ZSk7XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfdXBkYXRlQ29sbGFwc2UodmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sbGFwc2UnKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmNoYW5nZVRhcmdldCh2YWx1ZSk7XG4gIH1cblxuICAvLyByZWFkb25seSBhdHRyaWJ1dGUgZm9yIHRoZSB1c2Vyc1xuICBfdXBkYXRlTW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT09IHRoaXMuX21vZGUpIHtcbiAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5fY29sbGFwc2VNb2RlW21vZGUgPT09IENPTExBUFNFX01PREUgPyAnZW50ZXJNb2RlJyA6ICdleGl0TW9kZSddKCk7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kZScsIG1vZGUpO1xuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7c2lkZTogdGhpcywgbW9kZTogbW9kZX0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVPcGVuVGhyZXNob2xkKHRocmVzaG9sZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB7XG4gICAgdGhpcy5fdGhyZXNob2xkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDAuMykpO1xuICB9XG5cbiAgX3VwZGF0ZVN3aXBlYWJsZShzd2lwZWFibGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGVhYmxlJykpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzd2lwZWFibGUgPT09IG51bGwgPyAnb2ZmJyA6ICdvbic7XG5cbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0IGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFnZW5kJywgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlU3dpcGVUYXJnZXRXaWR0aCh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSkge1xuICAgIHRoaXMuX3N3aXBlVGFyZ2V0V2lkdGggPSBNYXRoLm1heCgwLCBwYXJzZUludCh2YWx1ZSkgfHwgMCk7XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgdGhpcy5zdHlsZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB9XG5cbiAgZ2V0IF93aWR0aCgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHJldHVybiAvXlxcZCsocHh8JSkkLy50ZXN0KHdpZHRoKSA/IHdpZHRoIDogJzgwJSc7XG4gIH1cblxuICBzZXQgX3dpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdmFsdWUpO1xuICB9XG5cbiAgX3VwZGF0ZVNpZGUoc2lkZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykpIHtcbiAgICB0aGlzLl9zaWRlID0gc2lkZSA9PT0gJ3JpZ2h0JyA/IHNpZGUgOiAnbGVmdCc7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0aW9uKGFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKHthbmltYXRpb259KTtcbiAgICB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb25PcHRpb25zKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIHtcbiAgICB0aGlzLl9hbmltYXRvci51cGRhdGVPcHRpb25zKEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgbG9jYXRpb24gdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbW9kZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBcInNwbGl0XCIsIFwiY29sbGFwc2VcIiwgXCJjbG9zZWRcIiwgXCJvcGVuXCIgb3IgXCJjaGFuZ2luZ1wiLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaXNPcGVuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIHdoZW4gdGhlIG1lbnUgaXMgb3Blbi4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5pc09wZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9wZW5cbiAgICogQHNpZ25hdHVyZSBvcGVuKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgb3BlbihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ29wZW4nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5leGVjdXRlQWN0aW9uKCdjbG9zZScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbnMgaWYgaXQncyBjbG9zZWQuIENsb3NlcyBpZiBpdCdzIG9wZW4uWy9lbl1cbiAgICogICBbamFd6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaJ44GY44G+44GZ44Gd44GX44Gm6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuID8gdGhpcy5jbG9zZShvcHRpb25zKSA6IHRoaXMub3BlbihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiA8b25zLXRlbXBsYXRlPi5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8ICgoKSA9PiB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgb2xkQ29udGVudCA9IHRoaXMuX2NvbnRlbnQgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQob2xkQ29udGVudCk7XG4gICAgICAgICAgb2xkQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZW9wZW4nLCAncG9zdG9wZW4nLCAncHJlY2xvc2UnLCAncG9zdGNsb3NlJywgJ21vZGVjaGFuZ2UnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLXNpZGUnLCBTcGxpdHRlclNpZGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc3dpdGNoJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoYFxuICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzd2l0Y2hfX2lucHV0XCI+XG4gIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvZ2dsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX2hhbmRsZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG91Y2hcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgbG9jYXRpb25zID0ge1xuICBpb3M6IFsxLCAyMV0sXG4gIG1hdGVyaWFsOiBbMCwgMTZdXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zd2l0Y2hcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFN3aXRjaCBjb21wb25lbnQuIFRoZSBzd2l0Y2ggY2FuIGJlIHRvZ2dsZWQgYm90aCBieSBkcmFnZ2luZyBhbmQgdGFwcGluZy5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHN3aXRjaCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3dpdGNoWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBMcFhaUVFcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zd2l0Y2hcbiAqIEBndWlkZSBhZGRpbmctcGFnZS1jb250ZW50XG4gKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXN3aXRjaCBjaGVja2VkPjwvb25zLXN3aXRjaD5cbiAqIDxvbnMtc3dpdGNoIGRpc2FibGVkPjwvb25zLXN3aXRjaD5cbiAqIDxvbnMtc3dpdGNoIG1vZGlmaWVyPVwibWF0ZXJpYWxcIj48L29ucy1zd2l0Y2g+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpdGNoRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3dpdGNoIGlzIHRvZ2dsZWQuWy9lbl1cbiAgICogICBbamFdT04vT0ZG44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc3dpdGNoXG4gICAqICAgW2VuXVN3aXRjaCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfU3dpdGNo44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC52YWx1ZVxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruWApOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNJbnRlcmFjdGl2ZVxuICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyBvbiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBquOBqeOBruODpuODvOOCtuOBruaTjeS9nOOBq+OCiOOBo+OBpuWkieOCj+OBo+OBn+WgtOWQiOOBq+OBr3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICBbamFd44K544Kk44OD44OB44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLnhKHlirnjga7nirbmhYvjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjaGVja2VkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBrueKtuaFi+OBq+OBmeOCi+OBqOOBjeOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBgaWRgIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIGlmIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICB9XG5cbiAgc2V0IGNoZWNrZWQodmFsdWUpIHtcbiAgICB0aGlzLl9jaGVja2VkID0gISF2YWx1ZTtcbiAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2hlY2tlZCcsIHRoaXMuX2NoZWNrZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSAhIXZhbHVlO1xuICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHRoaXMuX2Rpc2FibGVkKTtcbiAgICB0aGlzLl9jaGVja2JveC5kaXNhYmxlZCA9IHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2JveFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHVuZGVybHlpbmcgY2hlY2tib3ggZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXpg6jjga5jaGVja2JveOimgee0oOOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2hlY2tib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdtb2RpZmllcicsICduYW1lJywgJ2lucHV0LWlkJ10uZm9yRWFjaChlID0+IHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX19pbnB1dCcpICYmIHV0aWwuZmluZENoaWxkKHRoaXMsICcuc3dpdGNoX190b2dnbGUnKSkpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl9jaGVja2JveCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faW5wdXQnKTtcbiAgICB0aGlzLl9oYW5kbGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hfX2hhbmRsZScpO1xuXG4gICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuX2NoZWNrZWQ7XG4gICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7ZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxfSk7XG4gICAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuY2xpY2soKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3N3aXRjaF9fdG91Y2gnKSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBjbGljaygpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZScsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuY2hlY2tlZCxcbiAgICAgICAgc3dpdGNoOiB0aGlzLFxuICAgICAgICBpc0ludGVyYWN0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZS5nZXN0dXJlLmRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9sb2NhdGlvbnNbdGhpcy5jaGVja2VkID8gMSA6IDBdOy8vIC0gZS5nZXN0dXJlLmRlbHRhWDtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWcoZSkge1xuICAgIGUuZ2VzdHVyZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5fZ2V0UG9zaXRpb24oZSkgKyAncHgnO1xuICB9XG5cbiAgX29uUmVsZWFzZShlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKGUpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmNoZWNrZWQ7XG5cbiAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlJywge1xuICAgICAgICB2YWx1ZTogdGhpcy5jaGVja2VkLFxuICAgICAgICBzd2l0Y2g6IHRoaXMsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnaW5wdXQtaWQnLCAnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdjbGFzcyddO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnY2hhbmdlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICAgIHRoaXMuX2lzTWF0ZXJpYWwgPSAoY3VycmVudCB8fCAnJykuaW5kZXhPZignbWF0ZXJpYWwnKSAhPT0gLTE7XG4gICAgICAgICAgdGhpcy5fbG9jYXRpb25zID0gbG9jYXRpb25zW3RoaXMuX2lzTWF0ZXJpYWwgPyAnbWF0ZXJpYWwnIDogJ2lvcyddO1xuICAgICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgICB0aGlzLl9jaGVja2JveC5pZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zd2l0Y2gnLCBTd2l0Y2hFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIFRhYmJhckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGR1cmF0aW9uID0gMC40LCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZHVyYXRpb24sIGRlbGF5IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZW50ZXJQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBsZWF2ZVBhZ2Ugb25zLXBhZ2UgZWxlbWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW50ZXJQYWdlSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlYXZlUGFnZUluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlclBhZ2VJbmRleCwgbGVhdmVQYWdlSW5kZXgsIGRvbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQuJyk7XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgVGFiYmFyTm9uZUFuaW1hdG9yIGV4dGVuZHMgVGFiYmFyQW5pbWF0b3Ige1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJJbmRleCwgbGVhdmVJbmRleCwgZG9uZSkge1xuICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCAvIDYwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFiYmFyRmFkZUFuaW1hdG9yIGV4dGVuZHMgVGFiYmFyQW5pbWF0b3Ige1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFiYmFyU2xpZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluJywgZHVyYXRpb24gPSAwLjE1LCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZHVyYXRpb24sIGRlbGF5IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7anFMaXRlfSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtqcUxpdGV9IGxlYXZlUGFnZVxuICAgKi9cbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVySW5kZXgsIGxlYXZlSW5kZXgsIGRvbmUpIHtcbiAgICBjb25zdCBzZ24gPSBlbnRlckluZGV4ID4gbGVhdmVJbmRleDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgnICsgKHNnbiA/ICcnIDogJy0nKSArICcxMDAlLCAwLCAwKScsXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoJyArIChzZ24gPyAnLScgOiAnJykgKyAnMTAwJSwgMCwgMCknLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi8uLi9vbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7VGFiYmFyQW5pbWF0b3IsIFRhYmJhckZhZGVBbmltYXRvciwgVGFiYmFyTm9uZUFuaW1hdG9yLCBUYWJiYXJTbGlkZUFuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBUYWJFbGVtZW50IGZyb20gJy4uL29ucy10YWInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50YWItYmFyX19jb250ZW50JzogJ3RhYi1iYXItLSpfX2NvbnRlbnQnLFxuICAnLnRhYi1iYXInOiAndGFiLWJhci0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogVGFiYmFyTm9uZUFuaW1hdG9yLFxuICAnZmFkZSc6IFRhYmJhckZhZGVBbmltYXRvcixcbiAgJ3NsaWRlJzogVGFiYmFyU2xpZGVBbmltYXRvcixcbiAgJ25vbmUnOiBUYWJiYXJOb25lQW5pbWF0b3Jcbn07XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeSh0YWJiYXJFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoKCkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiAoKSA9PiAnb25zLXRhYmJhci1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiYmFyXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUEgY29tcG9uZW50IHRvIGRpc3BsYXkgYSB0YWIgYmFyIG9uIHRoZSBib3R0b20gb2YgYSBwYWdlLiBVc2VkIHdpdGggYDxvbnMtdGFiPmAgdG8gbWFuYWdlIHBhZ2VzIHVzaW5nIHRhYnMuWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuODmuODvOOCuOS4i+mDqOOBq+ihqOekuuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy10YWLjgajntYTjgb/lkIjjgo/jgZvjgabkvb/jgYbjgZPjgajjgafjgIHjg5rjg7zjgrjjgpLnrqHnkIbjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYlxuICogICBbZW5dVGhlIGA8b25zLXRhYj5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5dVGhlIGA8b25zLXBhZ2U+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBiZWZvcmUgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIGNoYW5nZSBldmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjga7lpInmm7TjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYWZ0ZXIgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OBo+OBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCByZWFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMgaWYgdGhlIGFscmVhZHkgb3BlbiB0YWIgaXMgdGFwcGVkIGFnYWluLlsvZW5dXG4gICAqICAgW2phXeOBmeOBp+OBq+OCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBjOOCguOBhuS4gOW6puOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBleOCjOOBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgdmFsdWVzIGFyZSBgXCJub25lXCJgLCBgXCJzbGlkZVwiYCBhbmQgYFwiZmFkZVwiYC4gRGVmYXVsdCBpcyBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOiqreOBv+i+vOOBv+aZguOBruOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44CBXCJmYWRlXCLjgIFcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cIm5vbmVcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgYm90dG9tXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGlPUyBib3R0b20sIEFuZHJvaWQgdG9wKS5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcImJvdHRvbVwi44KC44GX44GP44GvXCJ0b3BcIuOCkumBuOaKnuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wiYm90dG9tXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcblxuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnRlbnQuY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fdGFiYmFyRWxlbWVudDtcbiAgICAgIGlmIChhY3RpdmVJbmRleCAmJiB0YWJiYXIuY2hpbGRyZW4ubGVuZ3RoID4gYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgdGFiYmFyLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgICBiYXNlQ2xhc3M6IFRhYmJhckFuaW1hdG9yLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lOiAnVGFiYmFyQW5pbWF0b3InLFxuICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX3RhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnRFbGVtZW50ICYmIHRoaXMuX3RhYmJhckVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgICAgIGNvbnN0IGJhciA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuXG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ29ucy10YWItYmFyX19jb250ZW50Jyk7XG4gICAgICBiYXIuY2xhc3NMaXN0LmFkZCgnb25zLXRhYi1iYXJfX2Zvb3RlcicpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmNyZWF0ZSgnLm9ucy10YWItYmFyX19jb250ZW50LnRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgICAgIGNvbnN0IHRhYmJhciA9IHV0aWwuY3JlYXRlKCcudGFiLWJhci5vbnMtdGFiLWJhcl9fZm9vdGVyJyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGFiYmFyLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRhYmJhcik7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xuXG4gICAgYWN0aW9uKHRoaXMsICd0b3AnKTtcblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSA6ICcnO1xuXG4gICAgICBpZiAodXRpbC5tYXRjaChwYWdlLmZpcnN0Q2hpbGQsICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICAgIGFjdGlvbihwYWdlLmZpcnN0Q2hpbGQsICdub3NoYWRvdycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgdG9wICYmICFmaWxsZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgX2dldFRhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFBhZ2VcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHNpZ25hdHVyZSBsb2FkUGFnZSh1cmwsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn2lk5bGe5oCn44Gu5YCk44KS5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXlzIGEgbmV3IHBhZ2Ugd2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCouOCr+ODhuOCo+ODluOBquOCpOODs+ODh+ODg+OCr+OCueOCkuWkieabtOOBm+OBmuOBq+OAgeaWsOOBl+OBhOODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc29sZS53YXJuKCdUaGUgbG9hZFBhZ2UgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtaW5vciB2ZXJzaW9uLicpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgdGFiID0gdGhpcy5fdGFiYmFyRWxlbWVudC5jaGlsZHJlblswXSB8fCBuZXcgVGFiRWxlbWVudCgpO1xuICAgICAgdGFiLl9sb2FkUGFnZShwYWdlLCB0aGlzLl9jb250ZW50RWxlbWVudCwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFnZUVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgKi9cbiAgX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcblxuICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLl9zd2l0Y2hQYWdlKHBhZ2VFbGVtZW50LCBvcHRpb25zKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IHBhZ2VFbGVtZW50O1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRUYWJiYXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiYmFySWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudC9udWxsfVxuICAgKi9cbiAgX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpIHtcbiAgICBjb25zdCBwYWdlcyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuO1xuICAgIGxldCBwYWdlID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGFnZXNbaV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHBhZ2UgPSBwYWdlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhZ2UgJiYgcGFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXBhZ2UnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IHBhZ2UgZWxlbWVudCBtdXN0IGJlIGEgXCJvbnMtcGFnZVwiIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2U7XG4gIH1cblxuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zZWxlY3RlZFRhYkluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByZXZpb3VzVGFiSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuXG4gICAqL1xuICBfc3dpdGNoUGFnZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2xkUGFnZUVsZW1lbnQgPSB0aGlzLl9vbGRQYWdlRWxlbWVudCB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpZiAob2xkUGFnZUVsZW1lbnQgIT09IGludGVybmFsLm51bGxFbGVtZW50KSB7XG4gICAgICAgIG9sZFBhZ2VFbGVtZW50Ll9oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdG9yLmFwcGx5KGVsZW1lbnQsIG9sZFBhZ2VFbGVtZW50LCBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXgsIG9wdGlvbnMucHJldmlvdXNUYWJJbmRleCwgKCkgPT4ge1xuICAgICAgICBpZiAob2xkUGFnZUVsZW1lbnQgIT09IGludGVybmFsLm51bGxFbGVtZW50KSB7XG4gICAgICAgICAgb2xkUGFnZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGVsZW1lbnQuX3Nob3coKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlVGFiXG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlVGFiKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UYWIgaW5kZXguWy9lbl1cbiAgICogICBbamFd44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMua2VlcFBhZ2VdXG4gICAqICAgW2VuXUlmIHRydWUgdGhlIHBhZ2Ugd2lsbCBub3QgYmUgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjgYznj77lnKjooajnpLrjgZfjgabjgYTjgotwYWdl44KS5aSJ44GI44Gq44GE5aC05ZCI44Gr44GvdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCwgYFwic2xpZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCYFwiZmFkZVwiYOOAgWBcInNsaWRlXCJg44CBYFwibm9uZVwiYOOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBzcGVjaWZpZWQgdGFiIHBhZ2UuIEFuaW1hdGlvbnMgYW5kIG90aGVyIG9wdGlvbnMgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgc2Vjb25kIHBhcmFtZXRlci5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jgqTjg7Pjg4fjg4Pjgq/jgrnjga7jgr/jg5bjgpLooajnpLrjgZfjgb7jgZnjgILjgqLjg4vjg6Hjg7zjgrfjg6fjg7Pjgarjganjga7jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlVGFiKGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgaWYgKCFvcHRpb25zLmFuaW1hdGlvbiAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnYW5pbWF0aW9uJykpIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZpb3VzVGFiID0gdGhpcy5fZ2V0QWN0aXZlVGFiRWxlbWVudCgpLFxuICAgICAgc2VsZWN0ZWRUYWIgPSB0aGlzLl9nZXRUYWJFbGVtZW50KGluZGV4KSxcbiAgICAgIHByZXZpb3VzVGFiSW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCksXG4gICAgICBzZWxlY3RlZFRhYkluZGV4ID0gaW5kZXgsXG4gICAgICBwcmV2aW91c1BhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG5cbiAgICBpZiAoIXNlbGVjdGVkVGFiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFiLicpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZFRhYkluZGV4ID09PSBwcmV2aW91c1RhYkluZGV4KSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3JlYWN0aXZlJywge1xuICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByZXZpb3VzUGFnZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVjaGFuZ2UnLCB7XG4gICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiLFxuICAgICAgY2FuY2VsOiAoKSA9PiBjYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgc2VsZWN0ZWRUYWIuc2V0SW5hY3RpdmUoKTtcbiAgICAgIGlmIChwcmV2aW91c1RhYikge1xuICAgICAgICBwcmV2aW91c1RhYi5zZXRBY3RpdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlY2hhbmdlIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHNlbGVjdGVkVGFiLnNldEFjdGl2ZSgpO1xuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHByZXZpb3VzVGFiSW5kZXg6IHByZXZpb3VzVGFiSW5kZXgsXG4gICAgICBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4XG4gICAgfTtcblxuICAgIGlmIChwcmV2aW91c1RhYikge1xuICAgICAgcHJldmlvdXNUYWIuc2V0SW5hY3RpdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBzZWxlY3RlZFRhYi5fbG9hZFBhZ2VFbGVtZW50KHRoaXMuX2NvbnRlbnRFbGVtZW50LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHBhZ2VFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICB0aGlzLl9zd2l0Y2hQYWdlKHBhZ2VFbGVtZW50LCBwYXJhbXMpXG4gICAgICAgICAgLnRoZW4ocGFnZSA9PiB7XG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHBhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRUYWJiYXJWaXNpYmlsaXR5XG4gICAqIEBzaWduYXR1cmUgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZWQgdG8gaGlkZSBvciBzaG93IHRoZSB0YWIgYmFyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICB0aGlzLl9jb250ZW50RWxlbWVudC5zdHlsZVt0aGlzLl90b3AgPyAndG9wJyA6ICdib3R0b20nXSA9IHZpc2libGUgPyAnJyA6ICcwcHgnO1xuICAgIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNldFRhYmJhclZpc2liaWxpdHkodHJ1ZSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgdGFiYmFyIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZVRhYkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGFiIGluZGV4IG9uIGN1cnJlbnQgYWN0aXZlIHRhYi4gSWYgYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgdGFicyA9IHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhYnNbaV0gaW5zdGFuY2VvZiBUYWJFbGVtZW50ICYmIHRhYnNbaV0uaXNBY3RpdmUgJiYgdGFic1tpXS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFdoZW4gYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuXG4gICAqL1xuICBfZ2V0QWN0aXZlVGFiRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGFiRWxlbWVudCh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBfZ2V0VGFiRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW5baW5kZXhdO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7IH1cblxuICBfc2hvdygpIHtcbiAgICBjb25zdCBjdXJyZW50UGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFBhZ2VFbGVtZW50KSB7XG4gICAgICBjdXJyZW50UGFnZUVsZW1lbnQuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBjb25zdCBjdXJyZW50UGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFBhZ2VFbGVtZW50KSB7XG4gICAgICBjdXJyZW50UGFnZUVsZW1lbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCB0YWJzID0gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSB0YWJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YWJzW2ldLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgVGFiYmFyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFRhYmJhckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlY2hhbmdlJywgJ3Bvc3RjaGFuZ2UnLCAncmVhY3RpdmUnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUYWJiYXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBUYWJiYXJFbGVtZW50LlRhYmJhckFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRhYmJhcicsIFRhYmJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgVGFiYmFyRWxlbWVudCBmcm9tICcuL29ucy10YWJiYXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3RhYi1iYXJfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndGFiLWJhci0tKl9faXRlbScsXG4gICcudGFiLWJhcl9fYnV0dG9uJzogJ3RhYi1iYXItLSpfX2J1dHRvbidcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdj5cbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cInRhYi1iYXJfX2J1dHRvblwiPjwvYnV0dG9uPlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cbiAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWNsb3VkXCI+PC9vbnMtaWNvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGFiLWJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0YWItYmFyX19iYWRnZSBub3RpZmljYXRpb25cIj4xPC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYlxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgdGFiIGluc2lkZSB0YWIgYmFyLiBFYWNoIGA8b25zLXRhYj5gIHJlcHJlc2VudHMgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXG4gKiAgICAgb25zLXRhYuimgee0oOOBruS4reOBq+OBr+OAgeOCv+ODluOBq+ihqOekuuOBleOCjOOCi+OCs+ODs+ODhuODs+ODhOOCkuebtOaOpeiomOi/sOOBmeOCi+OBk+OBqOOBjOWHuuadpeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5db25zLXRhYmJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRhYmJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5db25zLXBhZ2UgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pY29uXG4gKiAgIFtlbl1vbnMtaWNvbiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGFiYmFyPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxuICogICAgIGxhYmVsPVwiSG9tZVwiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cInNldHRpbmdzLmh0bWxcIlxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogPC9vbnMtdGFiYmFyPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYiBpcyB0YXBwZWQuWy9lbl1cbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZSBmb3IgdGhlIHRhYi4gQ2FuIHNwZWNpZnkgdGhlIHNhbWUgaWNvbiBuYW1lIGFzIGA8b25zLWljb24+YC5cbiAgICogICAgIElmIHlvdSBuZWVkIHRvIHVzZSB5b3VyIG93biBpY29uLCBjcmVhdGUgYSBDU1MgY2xhc3Mgd2l0aCBgYmFja2dyb3VuZC1pbWFnZWAgb3IgYW55IENTUyBwcm9wZXJ0aWVzIGFuZCBzcGVjaWZ5IHRoZSBuYW1lIG9mIHlvdXIgQ1NTIGNsYXNzIGhlcmUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJvbnMtaWNvbuOBqOWQjOOBmOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICAg5YCL5Yil44Gr44Ki44Kk44Kz44Oz44KS44Kr44K544K/44Oe44Kk44K644GZ44KL5aC05ZCI44Gv44CBYmFja2dyb3VuZC1pbWFnZeOBquOBqeOBrkNTU+OCueOCv+OCpOODq+OCkueUqOOBhOOBpuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZS1pY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbmFtZSBvZiB0aGUgaWNvbiB3aGVuIHRoZSB0YWIgaXMgYWN0aXZlLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBrumam+OBruOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxhYmVsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbGFiZWwgb2YgdGhlIHRhYiBpdGVtLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+S4i+OBq+ihqOekuuOBleOCjOOCi+ODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhZGdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IGEgbm90aWZpY2F0aW9uIGJhZGdlIG9uIHRvcCBvZiB0aGUgdGFiLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCuOOBq+ihqOekuuOBmeOCi+WGheWuueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byB0aGUgdGFiIHRoYXQgaXMgYWN0aXZlIGJ5IGRlZmF1bHQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSB8fCB0aGlzLmhhc0F0dHJpYnV0ZSgnYmFkZ2UnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gIH1cblxuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgX3RlbXBsYXRlTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzSW5wdXQgPSB0aGlzLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAncmFkaW8nO1xuICAgIGNvbnN0IGhhc0J1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG5cbiAgICByZXR1cm4gaGFzSW5wdXQgJiYgaGFzQnV0dG9uO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlTG9hZGVkKCkpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgbGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBoYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG5cbiAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgLy8gdXRpbC51cGRhdGVSaXBwbGUodGhpcy5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fYnV0dG9uJyksIHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgaWYgKGJ1dHRvbi5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKSkge1xuICAgICAgYnV0dG9uLmluc2VydEJlZm9yZSh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpLCBidXR0b24uZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJykpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2JhZGdlJykpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fYmFkZ2UnKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJyk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcbiAgICBjb25zdCBiYWRnZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdiYWRnZScpO1xuXG4gICAgaWYgKHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgaWNvbkVsZW1lbnQgPSBnZXRJY29uRWxlbWVudCgpO1xuICAgICAgY29uc3QgbGFzdCA9IGljb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgICAgaWNvbkVsZW1lbnQuc2V0QXR0cmlidXRlKCdpY29uJywgaWNvbik7XG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9PbnNlblVJL09uc2VuVUkvaXNzdWVzLzE2NTRcbiAgICAgIGdldEljb25FbGVtZW50KCkuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdpY29uJywgbGFzdCwgaWNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKTtcbiAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGdldExhYmVsRWxlbWVudCgpLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWxFbGVtZW50KCk7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBiYWRnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGdldEJhZGdlRWxlbWVudCgpLnRleHRDb250ZW50ID0gYmFkZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJhZGdlID0gZ2V0QmFkZ2VFbGVtZW50KCk7XG4gICAgICBpZiAoYmFkZ2UpIHtcbiAgICAgICAgYmFkZ2UucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SWNvbkVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5xdWVyeVNlbGVjdG9yKCdvbnMtaWNvbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJhZGdlRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBzZWxmLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19iYWRnZScpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG4gICAgICBpZiAodGFiYmFyKSB7XG4gICAgICAgIHRhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5fZmluZFRhYkluZGV4KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZSgpIHtcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgIHJhZGlvLmNoZWNrZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnKTtcbiAgfVxuXG4gIHNldEluYWN0aXZlKCkge1xuICAgIGNvbnN0IHJhZGlvID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gICAgcmFkaW8uY2hlY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCcpO1xuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX2xvYWRQYWdlRWxlbWVudChwYXJlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9sb2FkZWRQYWdlICYmICF0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKS5wYWdlcztcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZmluZFRhYkluZGV4KCk7XG4gICAgICBpZiAoIXBhZ2VzW2luZGV4XSkge1xuICAgICAgICB0aHJvdyBFcnJvcignUGFnZSB3YXMgbm90IHByb3ZpZGVkIHRvIDxvbnMtdGFiPiBpbmRleCAnICsgaW5kZXgpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2socGFnZXNbaW5kZXhdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xvYWRpbmdQYWdlKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nUGFnZS50aGVuKHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgICB0aGlzLl9sb2FkaW5nUGFnZSA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZTogdGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBwYXJlbnR9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nUGFnZTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodGhpcy5fbG9hZGVkUGFnZSk7XG4gICAgfVxuICB9XG5cbiAgX2xvYWRQYWdlKHBhZ2UsIHBhcmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudH0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZFBhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuXG4gICAgcmV0dXJuIHRhYmJhci5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9sb2FkZWRQYWdlKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9lbnN1cmVFbGVtZW50UG9zaXRpb24oKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSArICcgJyA6ICcnO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBwcmVmaXggKyB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSAmJiAhdGhpcy5oYXNMb2FkZWQpIHtcbiAgICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbG9hZFBhZ2VFbGVtZW50KHRhYmJhci5fY29udGVudEVsZW1lbnQsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICB0YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuX2ZpbmRUYWJJbmRleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsIG9uUmVhZHkpO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMgPT09IGVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb25zLXRhYiBlbGVtZW50IGlzIG11c3QgYmUgY2hpbGQgb2Ygb25zLXRhYmJhciBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoZGVmYXVsdENsYXNzTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWUgKyAnICcgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICBjYXNlICdsYWJlbCc6XG4gICAgICBjYXNlICdiYWRnZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFnZSc6XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiJywgVGFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAndG9vbGJhci1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICd0b29sYmFyLWJ1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyLWJ1dHRvblxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUEgYnV0dG9uIHdpdGggYW4gb3V0bGluZS5bL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS44KC44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQnV0dG9uIGNvbXBvbmVudCBmb3Igb25zLXRvb2xiYXIgYW5kIG9ucy1ib3R0b20tdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgYLjgovjgYTjga9vbnMtYm90dG9tLXRvb2xiYXLjgavoqK3nva7jgafjgY3jgovjg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wYWdlXG4gKiBAZ3VpZGUgYWRkaW5nLWEtdG9vbGJhclxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGRlZmF1bHRDbGFzc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lICsgJyAnICsgY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10b29sYmFyLWJ1dHRvbicsIFRvb2xiYXJCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhbmdlJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9fbGVmdCc6ICdyYW5nZS0tKl9fbGVmdCdcbn07XG5cbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8ZGl2PlxuICA8ZGl2IGNsYXNzPVwicmFuZ2VfX2xlZnRcIj48L2Rpdj5cbiAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwicmFuZ2VcIj5cbjwvZGl2PmApO1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ25hbWUnLFxuICAncGxhY2Vob2xkZXInLFxuICAncmVhZG9ubHknLFxuICAnc2l6ZScsXG4gICdzdGVwJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJhbmdlXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc2xpZGVyWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFJhbmdlIGlucHV0IGNvbXBvbmVudC4gVXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHNsaWRlci5cbiAqXG4gKiAgICAgV29ya3MgdmVyeSBzaW1pbGFyIHRvIHRoZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4WlFvbU1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yYW5nZVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxuICogPG9ucy1yYW5nZSBtb2RpZmllcj1cIm1hdGVyaWFsXCIgdmFsdWU9XCIxMFwiPjwvcmFuZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICghKHV0aWwuZmluZENoaWxkKHRoaXMsICcucmFuZ2VfX2xlZnQnKSAmJiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKSkpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICB0aGlzLl9sZWZ0LnN0eWxlLndpZHRoID0gKDEwMCAqIHRoaXMuX3JhdGlvKSArICclJztcbiAgfVxuXG4gIF9vbkRyYWdzdGFydChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBnZXQgX3JhdGlvKCkge1xuICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmF0aW8uXG4gICAgY29uc3QgbWluID0gdGhpcy5faW5wdXQubWluID09PSAnJyA/IDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5taW4pO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2lucHV0Lm1heCA9PT0gJycgPyAxMDAgOiBwYXJzZUludCh0aGlzLl9pbnB1dC5tYXgpO1xuXG4gICAgcmV0dXJuICh0aGlzLnZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdtaW4nIHx8IG5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdzdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnc3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9sZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yYW5nZV9fbGVmdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2lucHV0JywgJ2NoYW5nZSddO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhbmdlJywgUmFuZ2VFbGVtZW50KTtcbiIsImltcG9ydCBvbnMgZnJvbSAnLi9vbnMvb25zJztcblxuaW1wb3J0IFRlbXBsYXRlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgSWZFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCBBbGVydERpYWxvZ0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nJztcbmltcG9ydCBCYWNrQnV0dG9uRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgQm90dG9tVG9vbGJhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYm90dG9tLXRvb2xiYXInO1xuaW1wb3J0IEJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCBDYXJvdXNlbEl0ZW1FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0IENhcm91c2VsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgQ29sRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jb2wnO1xuaW1wb3J0IERpYWxvZ0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtZGlhbG9nJztcbmltcG9ydCBGYWJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBJY29uRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCBMYXp5UmVwZWF0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1sYXp5LXJlcGVhdCc7XG5pbXBvcnQgTGlzdEhlYWRlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXInO1xuaW1wb3J0IExpc3RJdGVtRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0nO1xuaW1wb3J0IExpc3RFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWxpc3QnO1xuaW1wb3J0IElucHV0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pbnB1dCc7XG5pbXBvcnQgTW9kYWxFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLW1vZGFsJztcbmltcG9ydCBOYXZpZ2F0b3JFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLW5hdmlnYXRvcic7XG5pbXBvcnQgUGFnZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcGFnZSc7XG5pbXBvcnQgUG9wb3ZlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgUHJvZ3Jlc3NCYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXInO1xuaW1wb3J0IFB1bGxIb29rRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1wdWxsLWhvb2snO1xuaW1wb3J0IFJpcHBsZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcbmltcG9ydCBSb3dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXJvdyc7XG5pbXBvcnQgU2VsZWN0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zZWxlY3QnO1xuaW1wb3J0IFNwZWVkRGlhbEl0ZW1FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XG5pbXBvcnQgU3BlZWREaWFsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsJztcbmltcG9ydCBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0IFNwbGl0dGVyTWFza0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XG5pbXBvcnQgU3BsaXR0ZXJTaWRlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlJztcbmltcG9ydCBTcGxpdHRlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXInO1xuaW1wb3J0IFN3aXRjaEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCBUYWJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRhYic7XG5pbXBvcnQgVGFiYmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10YWJiYXInO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uJztcbmltcG9ydCBUb29sYmFyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcbmltcG9ydCBSYW5nZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuXG5vbnMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xub25zLklmRWxlbWVudCA9IElmRWxlbWVudDtcbm9ucy5BbGVydERpYWxvZ0VsZW1lbnQgPSBBbGVydERpYWxvZ0VsZW1lbnQ7XG5vbnMuQmFja0J1dHRvbkVsZW1lbnQgPSBCYWNrQnV0dG9uRWxlbWVudDtcbm9ucy5Cb3R0b21Ub29sYmFyRWxlbWVudCA9IEJvdHRvbVRvb2xiYXJFbGVtZW50O1xub25zLkJ1dHRvbkVsZW1lbnQgPSBCdXR0b25FbGVtZW50O1xub25zLkNhcm91c2VsSXRlbUVsZW1lbnQgPSBDYXJvdXNlbEl0ZW1FbGVtZW50O1xub25zLkNhcm91c2VsRWxlbWVudCA9IENhcm91c2VsRWxlbWVudDtcbm9ucy5Db2xFbGVtZW50ID0gQ29sRWxlbWVudDtcbm9ucy5EaWFsb2dFbGVtZW50ID0gRGlhbG9nRWxlbWVudDtcbm9ucy5GYWJFbGVtZW50ID0gRmFiRWxlbWVudDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3JFbGVtZW50ID0gR2VzdHVyZURldGVjdG9yRWxlbWVudDtcbm9ucy5JY29uRWxlbWVudCA9IEljb25FbGVtZW50O1xub25zLkxhenlSZXBlYXRFbGVtZW50ID0gTGF6eVJlcGVhdEVsZW1lbnQ7XG5vbnMuTGlzdEhlYWRlckVsZW1lbnQgPSBMaXN0SGVhZGVyRWxlbWVudDtcbm9ucy5MaXN0SXRlbUVsZW1lbnQgPSBMaXN0SXRlbUVsZW1lbnQ7XG5vbnMuTGlzdEVsZW1lbnQgPSBMaXN0RWxlbWVudDtcbm9ucy5JbnB1dEVsZW1lbnQgPSBJbnB1dEVsZW1lbnQ7XG5vbnMuTW9kYWxFbGVtZW50ID0gTW9kYWxFbGVtZW50O1xub25zLk5hdmlnYXRvckVsZW1lbnQgPSBOYXZpZ2F0b3JFbGVtZW50O1xub25zLlBhZ2VFbGVtZW50ID0gUGFnZUVsZW1lbnQ7XG5vbnMuUG9wb3ZlckVsZW1lbnQgPSBQb3BvdmVyRWxlbWVudDtcbm9ucy5Qcm9ncmVzc0JhckVsZW1lbnQgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5vbnMuUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgPSBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudDtcbm9ucy5QdWxsSG9va0VsZW1lbnQgPSBQdWxsSG9va0VsZW1lbnQ7XG5vbnMuUmlwcGxlRWxlbWVudCA9IFJpcHBsZUVsZW1lbnQ7XG5vbnMuUm93RWxlbWVudCA9IFJvd0VsZW1lbnQ7XG5vbnMuU2VsZWN0RWxlbWVudCA9IFNlbGVjdEVsZW1lbnQ7XG5vbnMuU3BlZWREaWFsSXRlbUVsZW1lbnQgPSBTcGVlZERpYWxJdGVtRWxlbWVudDtcbm9ucy5TcGVlZERpYWxFbGVtZW50ID0gU3BlZWREaWFsRWxlbWVudDtcbm9ucy5TcGxpdHRlckNvbnRlbnRFbGVtZW50ID0gU3BsaXR0ZXJDb250ZW50RWxlbWVudDtcbm9ucy5TcGxpdHRlck1hc2tFbGVtZW50ID0gU3BsaXR0ZXJNYXNrRWxlbWVudDtcbm9ucy5TcGxpdHRlclNpZGVFbGVtZW50ID0gU3BsaXR0ZXJTaWRlRWxlbWVudDtcbm9ucy5TcGxpdHRlckVsZW1lbnQgPSBTcGxpdHRlckVsZW1lbnQ7XG5vbnMuU3dpdGNoRWxlbWVudCA9IFN3aXRjaEVsZW1lbnQ7XG5vbnMuVGFiRWxlbWVudCA9IFRhYkVsZW1lbnQ7XG5vbnMuVGFiYmFyRWxlbWVudCA9IFRhYmJhckVsZW1lbnQ7XG5vbnMuVG9vbGJhckJ1dHRvbkVsZW1lbnQgPSBUb29sYmFyQnV0dG9uRWxlbWVudDtcbm9ucy5Ub29sYmFyRWxlbWVudCA9IFRvb2xiYXJFbGVtZW50O1xub25zLlJhbmdlRWxlbWVudCA9IFJhbmdlRWxlbWVudDtcblxuLy8gZmFzdGNsaWNrXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcbn0sIGZhbHNlKTtcblxuLy8gb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICB9KTtcbiAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XG59LCBmYWxzZSk7XG5cbi8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbm9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgb25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMoKTtcbn0pO1xuXG4vLyB2aWV3cG9ydC5qc1xubmV3IFZpZXdwb3J0KCkuc2V0dXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl19
